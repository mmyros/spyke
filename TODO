TODO:

- INTERPOLATION
    - waveform widgets should display data with the current level of interpolation (surfbawd only ever displayed raw data)
        - only bother displaying interpolated data for spike frame - not necessary for chart and lfp frames, and will conserve update speed to a large extent compared to uninterpolated mode
    - if matplotlib is used for waveform widgets, will get subpixel rendering and antialiasing for free, which should make interpolated data visibly different from raw data even at low zoom

- recreate Detector with current setting whenever user clicks on method or threshold radios
    - clicking on other options can just update the current Detector
    - or better, Detector is updated from other options only when you hit search or F3 or eq'v

- toggle chan selection by Ctrl+click on chan in any of the data frames - this either makes them invisible (but that could cause problems for tooltip when it's looking for the nearest line) or toggles their colour to dark grey or something.


- plot and control thresh level on spike and chart plots
    - use picker - when a thresh line is picked (within a tolerance of a couple pix), change mouse cursor to hand or vertical sizer, and while button is down, adjust position of thresh lines and value of the manual thresh level in Events tab

- check if y data is being updated as efficiently as possible, want to prevent copying, increase scrolling speed
    - seems alright: mostly just doing line.set_ydata() on each plot call
    - check if you can shift a line's y_data, instead of having to replace it entirely on every plot call
    - actually, looks like the limiting factor for speed is window size - if you resize the windows so they're really small, plotting is lightning fast. So this is a backend drawing issue, and probably has nothing to do with the efficiency of updating y values
    - keyboard navigation commands and mouse paging on slider cause two slider scroll events, and hence two plot calls, probably cutting performance in half. Doesn't happen with mouse seeking (dragging marker directly with the mouse). This seems to be inherent to the slider widget. wx bug, or by design? Might be separate slider events for key down and key up? Can prolly work around this by handling keyboard events directly

- try parsing by restoring from .parse files again for speed, especially when it comes to testing...

- make playback buttons work
    - add really big skip buttons, that skip one page of chartwindow at a time

- add keyboard event handling, and pass all keyboard events from data frames to main spyke frame to handle

- separate groups of 3 digits in spin edit and end labels with commas (time in us)

- add 1ms wide chart window to sort window, so you can see chan layout of events in both real space and chart space, might make it easier to sort

- combined message and stimulus DIN window:
    - messages: maybe just a combo box with timestamp:message entries. Choosing one of them skips you to that timestamp. Changing current file position with other methods should automatically scroll you through the combo box at appropriate times
    - stimulus din: similar to above: drop down combo box with timestamp:DIN value entries


------------------------------------
EVENT DETECTION:

    - randomly sample the srf file to get some (hopefully) representative subset of all the multichannel spike waveforms
    - be able to specify time range(s?) within a file to limit spike detection to - this could be useful for limiting detection and template generation to parts of the file during different levels of animal wakefulness, as indicated by the dominant frequencies in the LFP
    - static and dynamic thresholds, independent for each chan, based on stdev or median (or other measures?)
    - specify chans that you want to search for events on. 2 benefits:
        - helps you increase n for a template that rarely fires
        - say you notice a shortage of cells in a certain part of the probe - you want to be sure there aren't any cells there that you've missed
    - F3 and F2 to search forward and back one event

    - dynamic spatiotemporal lockout: some spikes span greater space and time than others, yet they're all given the same lockout. I guess on thresh xing and again on finding a spike, you could search locally in time and space and within the fixed slock and tlock, and see if signal drops below thresh in something less than slock and tlock, and adjust the lockout accordingly for that thresh xing or found spike

------------------------------------
TEMPLATES:

    - subtemplates - recognize that two distinct events might be from the same cell, but in a different mode of operation
    - toggle the display of all the templates (their means) at once (button, or Ctrl-A?), with just their active channels displayed. This way, you can quickly see if some templates are very similar, and how the cells are distributed across the electrode. This also lets you decide which templates need more/fewer channels enabled to help distinguish between them. Each template should be a different colour (up to say 16 or so).
    - manual spike alignment
        - do this on a per spike basis as a feature, if automated alignment can't always get it right
        - when doing alignment on a template, move all member events too

    - custom spike duration per template
        - Need to make the spike duration (currently 1ms) user settable for every template. Some spikes are broad, others narrow, and it's best to confine the templates to just those times with useful information about the spike. Otherwise, if there's too much flatline on either side, then you're basically saying "it ain't a spike unless stuff doesn't happen immediately before or after it", which isn't true. You might get a spike very soon after from another cell, or even from the same cell if it's a fast spiker.
        - in other words, we want the ability to crop a template in time. This complements the ability to crop a template in channel space



------------------------------------
RIPPING:

    - instead of ripping against all the raw data, spike detect the whole file, and then rip against the detected spikes. If you center both your templates and your events on the peak, then comparing a template to an event is a one-shot process - no timeshifting required. 2 benefits:
        - much faster
        - error histograms will be more sharply bimodal, since you're not comparing templates to noise ever, just to events
            - also, no longer have to worry so much about selecting as few flat chans as possible in your template, in the worry that it'll start triggering against flatish lines of noise in the raw data
    - to reduce spike variability due to correlated noise, for any given comparison between template and data (be it against any timepoint in data, or against a detected event), take the channels that aren't selected in the template (purportedly because they have no significant signal on them), and at every timepoint, take their mean, and subtract that from _all_ channels. This should make spikes in the raw data (or in the detected events) look more like one of the templates
        - mean might not be ideal - maybe take their covariance and subtract it or something (see hyperellipsoidal method ref'd in 200x Blanche)
        - this should be done during any comparison between template and data, including during min rips (see below)

MINI RIPS:
    - while building up templates, have ability to do sort of a mini rip of your current templates across the current subset of spikes.
    - this would allow you to quickly increase the number of spikes in each template, and would reveal which spikes in your subset are still very different from any templates you've generated so far, so you can prioritize and focus on those next
    - more importantly, this will aid in sweeping up spikes from those cells that fire a lot and distract you from those that fire rarely
    - a degenerate version of this would be to do a self rip, where you rip across only the set of spikes that are currently members of the template. This would allow you to adjust the error thresh until the self rip just barely returns all of the current members of the template
    - just as for a normal rip, you'll first need to set an error thresh for the template
    - as you progress in your template building, you can occasionally do a mini rip and look at the error histogram, to see how well that template separates spikes out from the subset. Should be able to adjust the error thresh such that you get exactly the spikes that are already members




------------------------------------
VERIFICATION:

    - after completing a rip of the whole file, assemble the spike times from all the templates into a single list. Compare it to the list of spike times generated by applying the spike detection algorithm to the whole file. See how the two sets of spike times overlap. Imagine a venn diagram: if there are spikes that the detection algorithm found that the MTM algorithm did not find, then you need to examine those spikes. Either:
        A) you set your error thresh too stringently for the template that should have matched that spike;
        B) you have bad templates, or you're missing templates

    - plot autocorrelograms for each template, and cross-correlograms for all template pairs, make sure the bin heights are ~0 for abs(deltaT) < 1ms for autocorrs, make sure you don't have ridiculously huge peaks in xcorrs
        - wasn't there some other related test that we should be doing?
    - Nick: create a distance/similarity metric that, for all pairs of templates, for all overlapping channels, measures the difference between the signals, normalized by, say, the number of overlapping channels and the number of points per channel. This would help confirm that two templates are indeed two separate cells

    - plot spikes as fat bright vertical lines or something underneath the chart window so you can scroll through and see just what was classified as a spike and what wasn't. line colour should match template colour

    - limit template generation to specific part of file
        - Nick's idea: randomly sample events from, say, only the first 10 minutes of a recording, build up your templates with those. Then, rip across the whole file, and watch if the goodness of fit gets worse the further away you get in time.
            - plot goodness of fit over time - Goodness of fit might change over time, especially over hours, and in recordings different from which the templates were generated. Either divide each recording up into pieces say 10 minutes long, and plot that, or have a sliding window that calculates the goodness of fit for the last 10 minutes (that would give you lots more data points)



------------------------------------
LOW-PRIORITY:

- try creating win32 package installer, see if it automatically compiles weave code so you don't need gcc on the client system

- CTRL-B to bookmark a position (plot a red vline at that timepoint in all data frames? and/or add that timepoint to a time drop-down combo box, which could be changed from the current spin edit type), CTRL-F3 and CTRL-F2 to skip forward/back to next/previous bookmark (or select it from list of bookmarked times in time combo box)
    - good for skipping back and forth quickly between two (or more) spikes

- or, replace spinctrl with a spin button + text field next to each other, and catch the spin button's events (see wx manual pdf page 240) to control step size (say 40us instead of just 1us)

- add scroll wheel support for data frames, for scrolling through data
    - scroll by 40us in spike frame, 1ms in chart frame, 50ms in lfp frame
        - add a .tres attrib to each data frame?

- add vertical zoom controls to all DataFrames

- toggle between garish rainbow colours and normal green

- toggle plot points

- make moving of main spyke window retain existing spatial relations to data frames, instead of resetting to original spacing
    - worked on this for quite a while, couldn't figure it out, had recursive calling problems and stuff
    - ah, I was looking for something like this for a long time: wx.PostEvent(window, event) lets you send any event to any given window. Should try this out...

- goto feature: CTRL+G brings file position spin control into focus where you can enter the time that you want to jump to
    - maybe add ability to choose units (us or ms or s) from a combo box

- parsing progress bar with pause/stop button
    - use threading, so widget draw events aren't blocked during parsing

- event detection progress bar with pause/stop button

- ripping progress bar with pause/stop button

- move simple matplotlib plot() method from Stream class to WaveForm class, that way, you no longer need to pass a trange argument
    - instead of:
        f.highpassstream.plot(chanis=None, trange=(135e6, 135.1e6))
      you'd slice instead:
        f.highpassstream[135e6:135.1e6].plot(chanis=None)
    - would have to add more stuff as attribs to WaveForm class, such as .records and .rts






------------------------------------
OLDER:

- have a log window at bottom that details everything going on behind the scenes
    - this could simply be an integrated pyshell window (see manual), so you can do things from command line instead of being forced to use the GUI
    - also, use it to examine and mess with internals, including wxpy internals

- keep spyke importable as a library, not just as a standalone program. This way, you can parse files, spike sort, etc directly from interpreter, or neuropy, or any other python project.

- low priority: automated template generation
    - need to look into just how complex and slow the (automated) sorting will be
        - can it all be done in pure Python?
    - stick to manual template generation for now

- spike (and lfp? hardly worth it?) data need to be corrected for sample and hold (S+H) delay offsets
    - do this during interpolation as in Surfbawd?

- lfp data need to be corrected for offsets induced by low-pass filters
    - what are the spectral phase and amplitude characteristics of the filters?
    - Tim mentioned Hilbert transforms are useful for this
    - want to do CSDs as well - I guess these don't need to be filter offset corrected, since you're just comparing between lfp chans, not between lfp and spike chans

- can latest wxPy 2.8 reuse numpy data w/o copy?
    - yes, I think so. certainly matplotlib no longer has to do any copying to get data into wxpy, since the interface between them is now pure python, yet still fast

- could eventually add monopole and dipole modelling for 3d localization and to distinguish between pyramidal and stellate cells

- to deal with spike adaptation and attenuation during bursts, for each template, rip not just its mean across the file, but also the biggest and smallest (in terms of something like sum of peak-to-peak voltage across template channels, or variance across channels, or...) spike assigned to that template.
    - or, for each template, plot the distribution of spike sizes for all spikes in that template. For some templates, you might get a skewed distrib in which case: A) you've got a polluted template that needs to be split
                                    B) you need to do something, can't remember what I was gonna write, maybe increase the error thresh for that template?
    - maybe have ability to go from bins in spike size histogram (say its tail, or some weird peak) back to a display of the individual spike(s) that contributed to that bin


- need to be able to select which channels to enable in the template before doing a rip
    - for each template, use mouse controlled bounding box/clicking to pick out significant channels
    - if there's another template nearby in channel space, it's good to also select a few surrounding flat channels to help distinguish the fits of the two templates during the rip



much of this might be outdated, since a Collection class instance now includes all spikes and all templates:

- event collection: a class that represents a specific collection of event times - or maybe be more specific and just call it a spike collection?
    - the event collection class could be results from a spike detection run, members of templates, results from a rip, or any sort of collection of spikes you might generate. Could even be a collection of random times in the recording (noise times) that have nothing to do with spikes
    - event collections should have methods such that you can easily reveal times that two (or more?) collections have or don't have in common (venn diagrams)
        - implement this in GUI using drag and drop? right mouse button drag one collection window onto another, up pops a menu with options like:
            - merge collections
            - copy event times to collection
            - move event times to collection
            - generate new collection of event times in source but not destination
            - generate new collection of event times in destination but not in source
            - generate new collection of overlapping event times (common to both source and destination)
            - plot venn diagram
        - the Python Sets module would be good for this
    - should be able to name event collections, should automatically be named with incrementing numbers
    - the collections themselves would technically only consist of event times in us
        - copies of waveforms wouldn't be stored in spike collections, displaying the waveforms in a collection would require going back to the waveform data, armed with the spike time
    - is spike time in us good enough for uniquely identifying a spike? should we also associate a channel list with it? what exactly is the output of the spike detection algorithm? just spike times, or a list of significant channels as well? Perhaps channel designation should only be allowed in templates. An event/spike is a 54 channel waveform.
    - A template is an event collection plus:
        - channel designation
        - error threshold designation
    - so a template is a subclass of an event collection
    - should ultimately be able to do collections and templates on any of the layouts in the file, not just the main polytrode layout. This means potentially LFP data (lowpassrecords and lowpassmultichanrecords)...

    - maybe "File:New event collection" and "File:New template" items in the main menu, and maybe corresponding main toolbar buttons

    - event collection window GUI:
        - After a round of spike detection, an event collection window pops up. An event collection window has a full channel layout display. It has a combo box that lets you choose an event, labelled by its timepoint and a colour. Choosing it displays the event. To the right of the waveform display, there's a button corresponding to the event, with its timestamp and color in it. The button has a right click context menu that lets you:
            - delete the event
            - remove the event and make a new collection from it
            - remove it and make a new template from it
            - move it to the current template (see below)
        - Or, you can just drag and drop the button to another template or event/collection window to move it to that template/collection
        - dragging the event button off into space removes the event and pops open a new event collection window
        - Clicking the event button toggles its display. Also, there's a spin edit box next to the combo box that allows you to control how many events to display at once. If n > 1, the current event chosen in the combo box is used as the first event, and the n-1 subsequent events are also displayed, and also get their own button next to the waveform display. Each event is given a different colour. Make the color of the first (or only) event always the same, say red.
        - the GUI also has another combo box to the left of the waveform display for selecting the current template to overplot on top of the event(s) in the waveform display. As for events, there's a spin edit box, and buttons representing templates, so you can overplot multiple templates on top of the events, though you normally wouldn't do that much
            - dragging the template buttons off into space would pop open a new template window...

    - template window GUI:
        - pretty much the same as the event collection window, except now events in the combo box on the right are members of the currently selected template. If more than one template is selected, the event combo box and event buttons gray out or disappear completely, and you're in a mode where you're just overplotting and comparing templates.
        - some way of merging currently selected templates
        - some widget for controlling rip error threshold for current template
        - to designate which channels to include in the current template when it comes time to use it for ripping, just click each channel in the waveform display to toggle that channel
- closing a collection or template window just closes its GUI, doesn't delete it. Can bring it back by selecting it from the main window's view menu, or something.

- transparency would be good for overplots

- hard to do?: would be good to have undo/redo for all the collection/template membership manipulations

- what kind of window should we have around the spike time? Does the spike time represent the time of absolute value of peak voltage on the channel with the biggest signal? Then the temporal window around that is -0.25 ms and + 0.75 ms for a total of 1 ms window? I think that's roughly the standard in surfbawd. Temporal window parameters (-ve and +ve offset from spike time) should be a global setting that everything uses, but one that you can change at will (at least when spyke isn't currently doing a rip) to accomodate the display of the occasional long slow spike

- neuron ids should be incrementing integers. When you delete a template, the following templates' ids and colours should remain unchanged, until you hit a toolbar button (or something) to indicate that you want to renumber (and recolour) the whole lot, which will effectively only renumber and recolour those templates following the one that was deleted

- template files
    - contain python syntax that can be eval'd, or config file format, to get you everything you might ever want to know about the template:
        - file (files?) it was generated from
        - member spike times (and their associated files?)
        - date time it was last modified
        - ...
    - store all templates in one file ala surfbawd? or one file per template?
    - store it all in a single SQL database file?
    - or, pickle the whole Collection class instance to file, but also make it possible to export to separate binary spike files (plus the binary .din file)

- do we want to allow templates to be generated from spikes from multiple recordings? this could add annoying complexity, but might be handly for getting enough spikes from those rarely firing neurons - some neurons might fire only during one stimulus type and not the other. Neurons might have opposing preferences, such that you never see them all fire within the same recording

- low probability: in case of electrode drift within a recording, allow user to make executive decision that two templates that are significantly different in voltage+channel space due to drift, yet sufficiently similar to the eye, that they should be assigned the same neuron id (keep their template ids separate?)
    - should there be a distinction between template and neuron ids just in case we want to do something like the above? Maybe the template id should become alphanumeric, with a number followed by a letter, say 12a, 12b, etc.





----------------------------------------------------
DONE:

- move code to /spyke subfolder, make a setup.py in root, keep TODO in root

- how hard will it be to generate highpass, lowpass, chartwindow, and fistogram widgets in wxpython?
    - email wxpython list on displaying time series data.
    - wxpy 2.8 should be faster, doesn't need to copy data, can use numpy data directly?
    - borrow something from MPL?

- need ability to take a spike that's assigned to an existing template and remove it and generate a new template from it
- NOPE: destory data windows instead of hiding them - should be simpler in the end
    - set up config system to, among other things, remember window positions and sizes when you re-open a window, whether within the same session or across sessions
- try making data frames MiniFrames (see manual) instead of passing them the TOOL_WINDOW flag
    - consider making data frames children of the main spyke frame again - maybe this could be done to automatically iconize and activate the data frames when main spyke frame gets the event - yup, this is exactly the case. hooray!
- chart window channel layout is wrong
- arrange data windows so they overlap as little as possible
- end range problem for chart window, allow plotting of nothing...
- remove hard coding in data window positioning
- have a dock mode, where moving one window, whether main spyke frame or any of the data frames, moves all windows the same amount
    - I think all you need to do is give all frames an OnMove method (or something), call all other windows' OnMoves, pass them the event, and then event.Skip()
    - or better yet, make moving the main spyke window always move in dock mode, and moving the dataframes not do so (er, this last one seems hard to do, leave it out)
- make seek move chartwin's center to that position
    - that way you can look at stuff before and after the spike win data
    - also, a centered seek will allow for natural centered zooming in and out in time
- for laying out channels in space, should really be doing a um to uV conversion vertically, and a um to us conversion horizontally. Instead, right now I'm just maintaining vertical and horizontal order, and assuming all chans are equally spaced within those ordered lists
- shade the 1ms (or whatever the spike frame width is) on the chart window with a slightly lighter background than pure black, to indicate what part of the chartwin data you're currently looking at in the spike window
- make spike frame use same colours and chan to colour mapping as chart frame - chart frame is rainbow, spike frame will be similar, but not exactly the same for probes with chans that line up horizontally (like the 3 col probes)
- make spike frame width depend on number of columns in probe, so you get consistent channel width for all probes
- replace default slider position text (which keeps corrupting anyway) with proper spin edit and dedicated text boxes to indicate current position and start and end of recording
- nah: add chan id toggle button to display chan id directly underplotting (or shown next to?) each channel in all the dataframes
    - instead: show timestamp and chan id tooltip on hover
- add faint 0 uV horizontal lines for spike and LFP windows (not necessary for chart win)
    - add faint vertical lines at center of each column in spike window
- add horizontal zoom controls to all DataFrames

