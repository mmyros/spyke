{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f56\froman\fcharset238\fprq2 Times New Roman CE;}{\f57\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f59\froman\fcharset161\fprq2 Times New Roman Greek;}{\f60\froman\fcharset162\fprq2 Times New Roman Tur;}{\f61\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f62\froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f63\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f64\fswiss\fcharset238\fprq2 Arial CE;}{\f65\fswiss\fcharset204\fprq2 Arial Cyr;}{\f67\fswiss\fcharset161\fprq2 Arial Greek;}{\f68\fswiss\fcharset162\fprq2 Arial Tur;}
{\f69\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f70\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f71\fswiss\fcharset186\fprq2 Arial Baltic;}{\f72\fmodern\fcharset238\fprq1 Courier New CE;}{\f73\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f75\fmodern\fcharset161\fprq1 Courier New Greek;}{\f76\fmodern\fcharset162\fprq1 Courier New Tur;}{\f77\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f78\fmodern\fcharset178\fprq1 Courier New (Arabic);}
{\f79\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}}{\info{\author Swindale Lab}{\operator Swindale Lab}
{\creatim\yr2002\mo5\dy23\hr14\min32}{\revtim\yr2002\mo5\dy23\hr14\min34}{\version2}{\edmins2}{\nofpages13}{\nofwords4075}{\nofchars23232}{\nofcharsws28530}{\vern8247}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale100\nolnhtadjtbl \fet0\sectd \linex0\sectdefaultcl 
{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs40\cf1 AsyncFree library}{
\f2\fs18\cf2 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs18\cf2 
\par }{\b\f1\fs20\cf1 Document conventions (text formatting and colors):}{\f1\fs20\cf1 
\par 
\par Standard text
\par }{\f1\fs20\ul\cf1 Important text (warnings etc.)
\par }{\b\f1\fs20\cf1 Component description}{\f1\fs20\ul\cf1 
\par }{\f2\fs18\cf2 
\par public methods and properties
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 published properties
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 published events}{\f2\fs18\lang1029\langfe1033\langnp1029 
\par 
\par }{\fs20 {\*\shppict{\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex99\picscaley99\piccropl0\piccropr0\piccropt0\piccropb0
\picw517\pich517\picwgoal293\pichgoal293\pngblip\bliptag-1334857219{\*\blipuid b06fb1fd6568eb83244cb03b5f23f1d7}89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f13264900000009704859730000122b0000122b011e9de4c100
0000564944415428cf632847020c7838b5774108485c0772ae975f07223807cc07024c0e48d9f5daf2eb7003a01cdcf6143040013b90c373060a0e6070fe4001a6cc790800730a603220d360ea0e802d2d805983d739b838002e7e9dc59f206a750000000049454e44ae426082}}{\nonshppict
{\pict\picscalex97\picscaley97\piccropl0\piccropr0\piccropt0\piccropb0\picw517\pich517\picwgoal293\pichgoal293\wmetafile8\bliptag-1334857219\blipupi118{\*\blipuid b06fb1fd6568eb83244cb03b5f23f1d7}
010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc000000180018000000000018001800000000002800000018000000180000000100040000000000200100002b1200002b120000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb00000000000000bbbbbbbbb022222222222
2220bbbbbbb022222222222222220bbbbb022f2f2f2f2f2f2f2220bbbb02222222222222222220bbbb02f2f2f2f2f2f2f2f220bbbb02222222222222222220bb
bb02222222222222222220bbbbb000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb666bbb666bb6bb6bb6bbbbb6bbb6b
6bbb6b6bb6bb6bbbbb6bbbbb6bbb6b6b6b6b6bbbbb6bbbbb6bbb6b6b6b6b6bbbbb6bbb6b6bbb6b66bbb66bbbbbb666bbb666bb66bbb66bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb05000000070101000000030000000000}}}{\fs40  }{\b\f2\fs44 TAfComPort}{
\b\f2\fs44\lang1029\langfe1033\langnp1029 
\par }{\b\f1\fs20 Provides basic serial communication functions. It can be used as a data provider for a data dispatcher.
\par 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure Close;
\par }\pard \ql \li0\ri0\nowidctlpar\tx568\faauto\rin0\lin0\itap0 {\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Closes the communication port
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function ExecuteConfigDialog: Boolean;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Executes the standard communication device setup dialog
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function InBufUsed: Integer;
\par }{\f1\fs18\cf1\lang1029\langfe1033\langnp1029 Returns the number of bytes in device driver}{\f1\fs18\cf1 's }{\f1\fs18\cf1\lang1029\langfe1033\langnp1029 input buffer
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure Open;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Opens the communication port
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function OutBufFree: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the number of bytes free in output buffer
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function OutBufUsed: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns then number of bytes in output buffer
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure PurgeRX;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Clears device driver}{\f1\fs20\cf1 's }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 input buffer
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure PurgeTX;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Clears device driver}{\f1\fs20\cf1 's and internal output buffer 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function ReadChar: Char;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Reads the character from the input buffer. If there isn}{\f1\fs20\cf1 't any character to read, an exception is raised}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure ReadData(var Buf; Size: Integer);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Reads the specified number of bytes from input buffer. If there aren}{\f1\fs20\cf1 't enough data to read, an exception is raised}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function ReadString: String;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Reads all the data from the input buffer into string
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure SynchronizeEvent(EventKind: TAfComPortEventKind; 
\par   Data: TAfComPortEventData; Timeout: Integer);
\par }{\f1\fs20\cf1 Performs normal synchronized events processing. This method should be called from OnNonSyncEvent only.}{\f1\fs20\cf2 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteChar(C: Char);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the character to the output buffer. If there isn}{\f1\fs20\cf1 't enough space in the output buffer, an exception is raised. See OutBufSize property}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf1 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure WriteData(const Data; Size: Integer); override;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the data to the output buffer. It there isn}{\f1\fs20\cf1 't enough space in the output buffer, an exception is raised. See OutBufSize property}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure WriteString(const S: String);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the string to the output buffer. It there isn}{\f1\fs20\cf1 't enough space in the output buffer, an exception is raised. See OutBufSize property}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 property Active: Boolean;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Indicates whether the communication port is open}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property Core: TAfComPortCore; }{\f2\fs18\cf2 [ReadOnly]
\par }{\f1\fs20\cf1 Returns the instance of the core communication object}{\f1\fs20\cf2 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property DCB: TDCB;
\par }{\f1\fs20\cf1 Specifies the DCB port configuration. 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property Handle: THandle; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the handle of communication device for Windows API calls
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property CTSHold: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns whether transmission is waiting for the CTS signal to be sent
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property DSRHold: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs18\cf1\lang1029\langfe1033\langnp1029 Returns whether transmission is waiting for the DSR signal to be sent
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property RLSDHold: Boolean;  }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns whether transmission is waiting for the RLSD signal to be sent
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property XOffHold: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns whether transmission is waiting because the XOFF character was received}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property XOffSent: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns whether transmission is waiting because the XOFF character was transmitted}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property CTS: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the state of CTS signal
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property DSR: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the state of DSR signal
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property RING: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029  
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the state of RING signal}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property RLSD: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the state of RLSD signal}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure SetDefaultParameters;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Sets the communication port parameters according system default setting}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function SettingsStr: String;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns string that contains port number and current communication parameters
\par }{\f1\fs20\cf1 (e.g. COM1: 115200,N,8,1)}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property AutoOpen: Boolean;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 When it is True, the Open method is called after creating the component. Default}{\f1\fs20\cf1  }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 is False.
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property BaudRate: TAfBaudrate;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfBaudrate = (br110, br300, br600, br1200, br2400, br4800, br9600, br14400,
\par   br19200, br38400, br56000, br57600, br115200, br128000, br256000, brUser);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the baud rate used by the communication port. Value brUser allows to specify non-standard baud rate. See UserBaudRate property}{\i\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property Databits: TAfDatabits;
\par }\pard \ql \li0\ri0\nowidctlpar\tx5822\faauto\rin0\lin0\itap0 {\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfDatabits = (db4, db5, db6, db7, db8);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the number of data bits of the communication port}{\i\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property DTR: Boolean;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the current state of the DTR signal
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property EventThreadPriority: TThreadPriority;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the priority of the event thread in communication core object}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property FlowControl: TAfFlowControl;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfFlowControl = (fwNone, fwXOnXOff, fwRtsCts, fwDtrDsr);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the flow control mode}{\i\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property InBufSize: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the size of internal device}{\f1\fs20\cf1 's input buffer}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Options: TAfComOptions;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfComOption = (coParityCheck, coDsrSensitivity, coIgnoreXOff, coErrorChar, coStripNull);
\par TAfComOptions = set of TAfComOption;
\par }{\f1\fs20\cf1 Specifies some special communication device flags
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property OutBufSize: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the size of the output buffer }{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Parity: TAfParity;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfParity = (paNone, paOdd, paEven, paMark, paSpace);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the parity checking mode of the communication port
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property RTS: Boolean;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the current state of the RTS signal
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Stopbits: TAfStopbits;
\par }\pard \ql \li0\ri0\nowidctlpar\tx6106\faauto\rin0\lin0\itap0 {\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfStopbits = (sbOne, sbOneAndHalf, sbTwo);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the number of stop bits of the communication port.
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property UserBaudRate: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the user-defined baud rate of the communication port. Setting this property causes setting BaudRate property to brUser}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property WriteThreadPriority: TThreadPriority;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the priority of the write thread in communication core object}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property XOnChar: Char;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the XON character when XON/XOFF control is used
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property XOffChar: Char;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the XOFF character when XON/XOFF control is used
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property XOnLim: Word;
\par 
\par property XOffLim: Word;
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnCTSChanged: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when the state of CTS signal is changed. To determine the state of CTS signal use CTS property
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnDataRecived: TAfCPTDataReceivedEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCPTDataReceivedEvent = procedure(Sender: TObject; Count: Integer) of object;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when a data is received by communication port. Count is the actual number of bytes avaiable to read. 
\par You should read the whole number of bytes given in Count parameter. If you read less than Count number of bytes, the remained data is still kept in internal device}{\f1\fs20\cf1 's driver }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
buffer, but this event won}{\f1\fs20\cf1 
't occur until any new data is received. So you would never see the unread data until new data came to the communication port.There is an internal checking of the number of unread bytes every 200ms, it can solve this situation. 
If there are any unread data, the "false" event will occur to allow you read that data.}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\ul\cf1 Remember, the OnDataReceived event however never occurs when a data dispatcher has assigned this component as a data provider. In this case, this event is delegated to the data dispatcher. See TDataDispatcher.OnDataReceived
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnDSRChanged: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when the state of DSR signal is changed. To determine the state of DSR signal use DSR property
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnRLSDChanged: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when the state of RLSD signal is changed. To determine the state of}{\f1\fs20\cf1  }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 RLSD signal use RLSD property
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnRINGDetected: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when the state of RING signal is changed. To determine the state of RING signal use RING property
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnLineError: TAfCPTErrorEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCPTErrorEvent = procedure(Sender: TObject; Errors: DWORD) of object;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when the communication port detects line error or line break. Errors is a code that indicates type of error. See ClearCommError function and its lpErrors parameter in Win32 API Help for details.
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029   }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnNonSyncEvent: TAfCPTCoreEvent;
\par }\pard \ql \li0\ri0\nowidctlpar\tx5964\faauto\rin0\lin0\itap0 {\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCPTCoreEvent = procedure(Sender: TObject; EventKind: TAfComPortEventKind; 
\par   Data: TAfComPortEventData) of object;
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfComPortEventData = DWORD;
\par TAfComPortEventKind = TAfCoreEvent;
\par }{\f1\fs20\cf1 If assigned it allows you to handle communication event from the event thread directly instead handling it within VCL main thread synchronized events (e.g. OnDataReceived, OnSyncEvent..). This approach allows you to hand
le this event faster than in synchronized events, for example if your application must respond very fast. 
\par Because VCL is not thread-safe, you can NEVER call any VCL method here, but you can call SynchronizeEvent method from here and continue with normal message processing or use any other synchronizing mechanism. Refer to the Examples\\
NonsyncEventExample for details.
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnOutBufFree: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when all the data in output buffer was sent.
\par }{\f1\fs20\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnPortClose: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when communication port is closed}{\f1\fs20\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnPortOpen: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when communication port is opened}{\f1\fs20\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnSyncEvent: TAfCPTCoreEvent;
\par }\pard \ql \li0\ri0\nowidctlpar\tx5964\faauto\rin0\lin0\itap0 {\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCPTCoreEvent = procedure(Sender: TObject; EventKind: TAfComPortEventKind; 
\par   Data: TAfComPortEventData) of object;
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfComPortEventData = DWORD;
\par TAfComPortEventKind = TAfCoreEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 This is centralized event of all the communication port events described above. 
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par 
\par }{\f2\fs20\cf1\lang1029\langfe1033\langnp1029 {\*\shppict{\pict{\*\picprop\shplid1026{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}
\picscalex99\picscaley99\piccropl0\piccropr0\piccropt0\piccropb0\picw517\pich517\picwgoal293\pichgoal293\pngblip\bliptag-1185570217{\*\blipuid b955a2574749ef0c1799e0b6af195ca3}
89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f13264900000009704859730000122b0000122b011e9de4c100
0000794944415428cf5d90c10dc02008004d9ab0907112e30a1d413e305f3ffdf3729782568bbd17278a40404758511327ac52cf0ea298040390ed4d3da20228
434a4c11188764056449c9a0a18c6bb90baf024d11cb642d3033e9bd2643ca57ad67e63fbe83ad37dfb51edcd79c079188dca4e47740b7b12de42f0ffec5772668b293470000000049454e44ae426082}}{\nonshppict{\pict\picscalex97\picscaley97\piccropl0\piccropr0\piccropt0\piccropb0
\picw517\pich517\picwgoal293\pichgoal293\wmetafile8\bliptag-1185570217\blipupi118{\*\blipuid b955a2574749ef0c1799e0b6af195ca3}010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc000000180018000000000018001800000000002800000018000000180000000100040000000000200100002b1200002b120000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb22222222222bbbbbbbbbbbbb2bbbbbbbbbbbbbbbbbbbbb2b2b2bbbbbbbb666bbbbbbbbb222bbbbbbb
bbb66bbbb8888888888888bbbb6b6bbbb8000000000008bbb6bbbbbbb8099999999908bb6bbbbbbbb8099499494908b6bbbbbbbbb80994994449086bbbbbbbbb
b8099499494908bbbbbb6bbbb8094449949908bbbbbbb6bbb8099999999908666666666bb8094499494908bbbbbbb6bbb8094949444908bbbbbb6bbbb8094949
4949086bbbbbbbbbb8094499949908b6bbbbbbbbb8099999999908bb6bbbbbbbb8000000000008bbb6bbbbbbb8888888888888bbbb6b6bbbbbbbbbbbbbbbbbbbbbb66bbbbbbbbbbbbbbbbbbbbb666bbbbbbbbbbbbbbbbbbbbbbbbbbb05000000070101000000030000000000}}}{
\f2\fs18\cf1\lang1029\langfe1033\langnp1029  }{\b\f2\fs44\cf1 TAfDataDispatcher}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\b\f1\fs20\cf1 Provides dispatching of incoming data and events into one or more "data-aware" components. It has its own dispatcher buffer. It can be used with any data provider component (e.g. TAfComPort) or separately.
\par 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure AbortWriteStream;
\par }{\f1\fs20\cf1 Terminates sending data from the stream
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function BufFree: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the number of bytes free in dispatcher buffer
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function BufUsed: Integer;
\par }{\f1\fs20\cf1\lang1024\langfe1024\noproof Returns}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029  the number of bytes currently in dispatcher buffer
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure Clear;
\par }{\f1\fs20\cf1 Performs clear command to the all "data-aware" components linked to the dispatcher}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par 
\par procedure ClearBuffer;
\par }{\f1\fs20\cf1 Do not use, it isn't full implemented yet}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par 
\par procedure Dispatcher_WriteBufFree;
\par procedure Dispatcher_WriteTo(const Data; Size: Integer);
\par 
\par function ReadChar: Char;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Reads the character from dispatcher buffer. If there isn}{\f1\fs20\cf1 't any character to read, an exception is raised.
\par If it is called within OnDataReceived event it doesn't remove any data from dispatcher buffer until all linked components have seen them.}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure ReadData(var Buf; Size: Integer);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Reads the specified number of bytes from dispatcher buffer. If there aren}{\f1\fs20\cf1 
't enough data to read, an exception is raised. If it is called within OnDataReceived event it doesn't remove any data from dispatcher buffer until all linked 
\par components have seen them.}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 function ReadString: String;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Reads all the data from dispatcher buffer to string. }{\f1\fs20\cf1 If it is called within OnDataReceived event it doesn't remove any data from dispatcher buffer until all linked components have seen them.}{
\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure WriteChar(C: Char);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the character to the specified data provider.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteData(const Data; Size: Integer);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the data to the specified data provider.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteString(const S: String);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the string to the specified data provider.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteStream(Stream: TStream; FreeAtferWrite: Boolean);
\par }{\f1\fs20\cf1 Writes the stream to the specified data provider. If FreeAfterWrite is True, the stream will be automatically destroyed after write finished
 or be aborted. The stream is sent by small blocks of data which size is specified in StreamBlockSize property.}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par 
\par property LinksList: TList;
\par 
\par property ReceivedBytes: Integer; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Do not use, it isn't full implemented yet}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par 
\par property SentBytes: Integer; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Do not use, it isn't full implemented yet}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par 
\par property StreamWriting: Boolean; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Indicates whether writing stream is in progress.}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par 
\par property OnWriteToDevice: TAfDispWriteToEvent;
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property BufferSize: Integer;
\par }{\f1\fs20\cf1 Specifies the size of the dispatcher buffer
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property DataProvider: TAfDataDispConnComponent;
\par }{\f1\fs20\cf1 Specifies the data provider
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property StreamBlockSize: Integer;
\par }{\f1\fs20\cf1 Specifies the maximum size of stream write data block
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnDataReceived: TNotifyEvent;
\par }{\f1\fs20\cf1 Occurs when a data are received from data provider (written to the dispatcher's buffer)}{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par 
\par property OnWriteBufFree: TNotifyEvent;
\par }{\f1\fs20\cf1 Occurs when data provider's output data was sent. This event however won't occurs when writing stream is in progress.}{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par 
\par property OnWriteStreamBlock: TAfDispStreamEvent;
\par }{\f1\fs20\cf1 Occurs when the block of stream data was written
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnWriteStreamDone: TNotifyEvent;
\par }{\f1\fs20\cf1 Occurs when writing stream is done
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par 
\par }{\f11\fs20\cf1\lang1029\langfe1033\langnp1029 {\*\shppict{\pict{\*\picprop\shplid1027{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}
\picscalex99\picscaley99\piccropl0\piccropr0\piccropt0\piccropb0\picw513\pich513\picwgoal291\pichgoal291\pngblip\bliptag-662543013{\*\blipuid d882655ba0238fcd70e934260f5a4de1}
89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f13264900000009704859730000123d0000123d01d78ab09000
0000654944415428cf632847020c050c70c0ce50f01f0af8bf2373d8819c0f1035fcec154832a87aea91957d47973903056099f310893f9832844dc374284819dca13019b043513d57505f5f0f24cbcb417a0abe7ffffee1038453de0092296f007390f520071500275294f4b216cca50000000049454e44ae426082}
}{\nonshppict{\pict\picscalex98\picscaley98\piccropl0\piccropr0\piccropt0\piccropb0\picw513\pich513\picwgoal291\pichgoal291\wmetafile8\bliptag-662543013\blipupi118{\*\blipuid d882655ba0238fcd70e934260f5a4de1}
010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc000000180018000000000018001800000000002800000018000000180000000100040000000000200100003d1200003d120000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbbbbb
bbbbbbbbbbbbbbbbb0000000000000000000000bb0bba0bfbfbfb0bba0bbbb0bb0f0b0fbfbfbf0f0b0bbbb0bb0ffb0bfbfbfb0ffb0bbbb0bb000000000000000
0000000bb0ffffffffffffffff0bba0bb0f0000000ffffffff0f0b0bb0ffffffffffffffff0ffb0bb0ffffffffffffffff00000bb0f00000000000000f0bfb0b
b0ffffffffffffffff0fbf0bb022222222222222220bfb0bb02ffffffffffffff20fbf0bb022222222222222220bfb0bb0ffffffffffffffff0fbf0bb0f00000
000000000f0bfb0bb0ffffffffffffffff0fbf0bb0ffffffffffffffff00000bb0f00000000000000f0bba0bb0ffffffffffffffff0f0b0bb0ffffffffffffffff0ffb0bb0000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbb05000000070101000000030000000000}}}{
\fs44\cf1\lang1029\langfe1033\langnp1029  }{\b\f2\fs44\cf1\lang1029\langfe1033\langnp1029 TAfLineViewer }{\b\f2\fs44\cf1 
\par }{\b\f1\fs20\cf1 Represents a virtual text viewer that displays text rows. It also support text highlighting and user painted area on the control's left side.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property FocusedPoint}{\f2\fs18\cf2 : TPoint;}{\f2\fs18\cf1  }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Cursor coordinates. TPoint here doesn't mean screen coordinates, but row and col.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property SelectedText}{\f2\fs18\cf2 : String}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 ; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Returns the selected text, lines are terminated by #13#10}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property SelStart: TPoint;}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Coordinates of the first selected character
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property SelEnd}{\f2\fs18\cf2 : TPoint}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 ;
\par }{\f1\fs20\cf1 Coordinates of the last selected character
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property TopLeft}{\f2\fs18\cf2 : TPoint}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 ;}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Coordinates of the top-left character
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property UseScroll}{\f2\fs18\cf2 : Boolean}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 ;}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 When it is True (default), the control scrolls its context (if it is possible) instead repainting all visible lines. 
\par }{\f2\fs18\cf1   
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure CopyToClipboard;
\par }{\f1\fs20\cf1 Copies the selected text to the Clipboard
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure DrawToCanvas(DrawCanvas: TCanvas; StartLine, EndLine: Integer; Rect: TRect);
\par }{\f1\fs20\cf1 For future use, not full implemented yet.}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029   
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029  
\par procedure DrawLineToCanvas(DrawCanvas: TCanvas; LineNumber: Integer; Rect: TRect; 
\par   TextMetric: TTextMetric);
\par }{\f1\fs20\cf1 For future use, not full implemented yet.}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029   
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure InvalidateDataRect(R: TRect; FullLine: Boolean);
\par }{\f1\fs20\cf1 Invalidates the desired text area. R here doesn't mean screen coordinates. When FullLine parameter is True and R.Top = R.Bottom, R.Left and R.Right values are ignored and full text line is invalidated.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure InvalidateFocusedLine;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Invalidates the line which has focus }{\f1\fs20\cf1 (see FocusedPoint).}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure InvalidateLeftSpace(StartLine, EndLine: Integer);
\par }{\f1\fs20\cf1 Invalidates the left "user painted area".
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function MouseToPoint(X, Y: Integer): TPoint;
\par }{\f1\fs20\cf1 Converts screen coordinates to the text coordinates (TPoint here doesn't mean screen coordinates).
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure ScrollIntoView;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Use ScrollIntoView to ensure that a focused row and column is in the visible area.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029   
\par property CharHeight: Integer; }{\f2\fs18\cf2 [ReadOnly]
\par }{\f1\fs20\cf1 The current font height in pixels}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property CharWidth: Integer; }{\f2\fs18\cf2 [ReadOnly]}{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 The current font width in pixels}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property CaretBlinkTime: TAfCLVCaretBlinkTime}{\f2\fs18\cf12 ;}{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVCaretBlinkTime = 1..MaxInt;
\par }{\f1\fs20\cf1 Sets the caret blink time to the specified number of milliseconds}{\i\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property CaretType: TAfCLVCaretType}{\f2\fs18\cf12 ;}{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVCaretType = (ctVertical, ctHorizontal, ctBlock);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Sets the shape of the caret}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property LeftSpace: TAfCLVLeftSpace;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVLeftSpace = 0..MaxInt;
\par }{\f1\fs20\cf1 Sets the size of left user-painted area. This area resides between left side of the control and text area. See }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 OnDrawLeftSpace for details.
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property LineCount: Integer;
\par }{\f1\fs20\cf1 Sets the number of lines
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property MaxLineLength: TAfCLVMaxLineLength}{\f2\fs18\cf12 ;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVMaxLineLength = 1..AfCLVMaxLineLength;
\par }{\f1\fs20\cf1 Sets the number of columns (max. 512)}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Options: TAfCLVOptions;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVOptions = set of (loCanSelect, loSelectByShift, loDrawFocusSelect,
\par loThumbTracking, loScrollToRowCursor, loScrollToColCursor, loShowLineCursor, 
\par loShowCaretCursor, loTabs);
\par }{\f1\fs20\cf1 Specifies various display and behavioral properties of the AfLineViewer:
\par loCanSelect\tab \tab - users can select range of text 
\par loSelectByShift     \tab - users have to press Shift key for selecting text 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 loDrawFocusSelect   \tab - if loShowLineCursor included, enables drawing focused line the same way like TListBox}{\f1\fs20\cf1 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 loThumbTracking     \tab - the viewer image updates while the user is dragging the thumb of the scrollbar.}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 loScrollToRowCursor \tab - the viewer always try to scroll area to make focused row visible
\par loScrollToColCursor \tab - the viewer always try to scroll area to make focused column visible
\par loShowLineCursor    \tab - focused line is drawn the same way like TListBox
\par loShowCaretCursor   \tab - shows caret
\par loTabs              \tab \tab - Tab key does}{\f1\fs20\cf1 n't cause selection next control}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property SelectedColor: TColor;
\par }{\f1\fs20\cf1 Specifies the background color of selected text
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property SelectedTextColor: TColor}{\f2\fs18\cf12 ;}{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Specifies the foreground color of selected text
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property SelectedStyle: TFontStyles}{\f2\fs18\cf12 ;}{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Specifies the font style of selected text, see }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 UsedFontStyles for details.}{\f1\fs20\cf1 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property UseFontCache: Boolean}{\f2\fs18\cf12 ;}{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 When True (default is False), the font style cache is used. It can speed up painting if different font styles in each line are frequently used.}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property UsedFontStyles: TFontStyles;
\par }{\f1\fs20\cf1 Specifies font styles for calculating global font height and width. This is important when different font styles are used in painting. 
\par For example, you would like to highlight some keywords in text by setting font style to Bold. If you don't include [fsBold] in this property, the bold characters may not fit to calculated size.
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnBof: TNotifyEvent}{\f2\fs18\cf6 ;}{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1 Occurs when the first line is focused (FocusedPoint.Y = 0) and user presses UPARROW key.}{\f1\fs20\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnCursorChange: TAfCLVCursorEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVCursorEvent = procedure (Sender: TObject; CursorPos: TPoint) of object;
\par }{\f1\fs20\cf1 Occurs when the focused row or column is changed. CursorPos contains new coordinates.
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnDrawLeftSpace: TAfCLVDrawLeftSpEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVDrawLeftSpEvent = procedure (Sender: TObject; const Line, LeftCharPos: Integer;
\par   Rect: TRect; State: TAfCLVLineState) of object;
\par TAfCLVLineState = (lsNormal, lsFocused, lsSelected);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when a left user}{\f1\fs20\cf1 -painted area }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 needs to be drawn. Line indi
cates the row for that area should be drawn. LeftCharPos indicates the first left visible position of text. State indicates state of the row.
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnEof: TNotifyEvent;
\par }{\f1\fs20\cf1 Occurs when the last line is focused (FocusedPoint.Y = LineCount - 1) and user presses DOWNARROW key.}{\f1\fs20\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnFontChanged: TNotifyEvent;
\par }{\f1\fs20\cf1 Occurs after the Font property was changed. }{\f1\fs20\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnGetText: TAfCLVGetTextEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCLVGetTextEvent = procedure (Sender: TObject; Line: Integer; var Text: String;
\par   var ColorMode: TAfCLVColorMode; var CharColors: TAfCLVCharColors) of object;
\par TAfCLVColorMode = (cmDefault, cmLine, cmChars, cmCheckLength); 
\par TAfCLVCharAttr = packed record 
\par   BColor, FColor: TColor;
\par   Style: TFontStyles;
\par end;
\par TAfCLVCharColors = array[0..AfCLVMaxLineLength] of TAfCLVCharAttr; 
\par TAfCLVFocusSource = (fsKey, fsMouse, fsHScroll, fsVScroll); 
\par }{\f1\fs20\cf1 Occurs when the text of line is requested. 
\par ColorMode specifies the ColorMode:
\par cmDefault\tab - default color is used
\par cmLine\tab \tab - tells that the same color and style will be used for whole line. This color have to be 
\par \tab \tab specified in CharColors[0]
\par cmChars\tab - tells that the each character can have different color and style. You have to fill CharColor
\par \tab \tab array with desired values.
\par cmCheckLength - used internally for checking the length of text
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnLeftSpaceMouseDown: TMouseEvent;
\par }{\f1\fs20\cf1 Occurs when the user presses a mouse button with the mouse pointer over a left user-painted area
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnSelectionChange: TNotifyEvent;
\par }{\f1\fs20\cf1 Occurs when the current selection changes
\par }{\f2\fs20\cf1 
\par }{\fs20\cf1 
\par }{\fs20\cf1\lang1029\langfe1033\langnp1029 {\*\shppict{\pict{\*\picprop\shplid1028{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}
\picscalex97\picscaley97\piccropl0\piccropr0\piccropt0\piccropb0\picw497\pich497\picwgoal282\pichgoal282\pngblip\bliptag-1937639968{\*\blipuid 8c81f5e0f2f60afe7ef585b8b638a000}
89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f1326490000000970485973000012d3000012d3013b39140000
0000674944415428cf63a8ff0f07df197e74c0413fc30f06380072f8ffffffc039130826a0cba070b8562d5805440b3065d04de3ff80550685c3c37386e7cc9903586478ef820076a39138c8fe41f16939107074743480680c0e03480303845300d1ce0ee1400c06720036a6691cef48fa690000000049454e44ae426082}
}{\nonshppict{\pict\picscalex96\picscaley96\piccropl0\piccropr0\piccropt0\piccropb0\picw497\pich497\picwgoal282\pichgoal282\wmetafile8\bliptag-1937639968\blipupi122{\*\blipuid 8c81f5e0f2f60afe7ef585b8b638a000}
010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc00000018001800000000001800180000000000280000001800000018000000010004000000000020010000d3120000d3120000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbb000
00000000000bbbbbbbbbb0aaaaaaaaaaaa0bbbbbbbbbbb00aaaaaaaa00bbbbbbbbbbbbbb0aaaaaa0bbbbbbbbbbbbbbbb0aaaaaa0bbbbbbbbbfffffffffffffff
fffffffbfaaaaaaaaaaaaaaaaaaaaaaffa0fff0000000000000000affa00000000000000000000affa06666666666600000000affa00000000000000000000af
fa02022202222220000000affa00000000000000000000affa00000000000000000000affa0fffff0ff00000000000affa00000000000000000000affa000000
00000000000000affa0cccc0ccccc0ccc00000affa00000000000000000000affa00000000000000000000affa0ffffff0055555555550affa00000000000000000000affaaaaaaaaaaaaaaaaaaaaaafbffffffffffffffffffffffb05000000070101000000030000000000}}}{
\fs40\cf1\lang1029\langfe1033\langnp1029  }{\b\f2\fs44\cf1\lang1029\langfe1033\langnp1029 TAfTerminal
\par }{\b\f1\fs20\cf1 Representes a terminal window with circular buffer and scroll back mode capability. It doesn't support terminal emulation like ANSI or VT102, but it can highlight text with up to 16 different colors. 
\par }{\f2\fs18\cf1 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure ClearBuffer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Clears terminal buffer
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function DefaultTermColor: TAfTRMCharAttr;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMCharAttr = packed record  
\par   FColor, BColor: TAfTRMCharColor;
\par end}{\i\f2\fs18\cf1 ;
\par }{\f1\fs20\cf1 Returns default terminal colors}{\i\f1\fs20\cf1 
\par }{\i\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure DrawChangedBuffer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Draws the buffer. This should be called after WriteChar or WriteColorChar methods was called
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029  }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteChar(C: Char); 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the character to buffer. The characters written by this method won}{\f1\fs20\cf1 't be visible until DrawChangedBuffer method is called}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteColorChar(C: Char; BColor, FColor: TAfTRMCharColor); 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the character to buffer with specified color. The characters written by this method won}{\f1\fs20\cf1 't be visible until DrawChangedBuffer method is called.}{
\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteColorStringAndData(const S: String; BColor, FColor: TAfTRMCharColor;
\par   UserDataItem: Pointer);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the text with specified color and userdata }{\f1\fs20\cf1 (when UserDataItem <> nil) }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 to buffer. You don}{\f1\fs20\cf1 
't have to call DrawChangedBuffer method after calling this method. See UserDataSize property for details.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure WriteString(const S: String);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Writes the text to buffer. You don}{\f1\fs20\cf1 't have to call DrawChangedBuffer method after calling this method.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property BufferLine[Index: Integer]: String; }{\f2\fs18\cf2 [ReadOnly]
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the text of line in circular terminal buffer.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property BufferLineNumber: Integer; }{\f2\fs18\cf2 [ReadOnly]
\par }{\f1\fs20\cf1 Returns the number of last line in terminal buffer}{\f1\fs20\cf2 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property ColorTable: TAfTRMColorTable;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMCharColor = 0..15;
\par TAfTRMColorTable = array[TAfTRMCharColor] of TColor;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 ColorTable contains 16 colors which can be used in terminal. You can set another color palette by this property.}{\i\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property RelLineColors[Index: Integer]: TAfTRMCharAttrs;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMCharAttrs = array[0..AfCLVMaxLineLength] of TAfTRMCharAttr;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 This property is intended for use in OnGetColors event. You can set colors in any previous line specified by offset from current line being processed. For example, RelLineColors}{\f1\fs20\cf1 
[-1] returns or set }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 colors for the previous line.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property ScrollBackMode: Boolean;
\par }{\f1\fs20\cf1 When False (default), the terminal can show data written to it, users can't scroll back and read older data.
\par When True, the terminal doesn't show new data, but users can scroll back and see whole context of buffer. In this mode, new data are written to temporary buffer and after setting this property to Fals
e are copied to terminal buffer and shown. See AutoScrollBack property.}{\f1\fs20\cf2\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property TermColor[Color: TColor]: Integer; }{\f2\fs18\cf2 [ReadOnly]
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns terminal color index for the specified color. If the color }{\f1\fs20\cf1 exist, it raises an exception.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property UserData[Index: Integer]: Pointer;
\par }{\f1\fs20\cf1 
Internal terminal buffer contains text and color information (depended on TermColor property). Sometimes can be useful to have room for extra data in each line. The size of this room is specified in UserDataSize property. You can read or wri
te data using this property. 
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property AutoScrollBack: Boolean;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 When True (default), the ScrollBackMode is automatically set by users action.
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property BkSpcMode: TAfTRMBkSpcMode;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMBkSpcMode = (bmBack, bmBackDel);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the behavior of terminal for }{\f1\fs20\cf1 #08 char processing:
\par bmBack\tab }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 - moves the cursor back only}{\f1\fs20\cf1 
\par bmBackDel\tab - moves the cursor back and clears character at its position
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property DisplayCols: Byte;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the number of columns. It also clears terminal buffer.}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Logging: TAfTRMLogging;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMLogging = (lgOff, lgCreate, lgAppend);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies logging mode:
\par lgOff\tab \tab - no logging
\par lgCreate\tab - log file is always created, old file will be overwritten
\par lgAppend\tab - new data will be appended to existing log file. It file doesn}{\f1\fs20\cf1 't exist, it'll be created}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property LogFlushTime: TAfTRMLogFlushTime;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMLogFlushTime = 1..MaxInt;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the flushing time to the number in milliseconds. 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property LogName: String;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Sets the name of log file. }{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property LogSize: TAfTRMLogSize;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMLogSize = 1..MaxInt;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Do NOT use, it}{\f1\fs20\cf1 'll be removed in future versions}{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Options: TAfCLVOptions;
\par 
\par property ScrollBackCaret: TAfCLVCaretType;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the shape of caret when ScrollBackMode is True}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property ScrollBackKey: TShortCut;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the shortcut key which switches ScrollBackMode
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property ScrollBackRows: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the number of rows in terminal buffer. It also clears terminal buffer.}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property TerminalCaret: TAfCLVCaretType;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the shape of caret when ScrollBackMode is False}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property TermColorMode: TAfTRMColorMode;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMColorMode = (cmLDefault, cmL16_16, cmC16_16);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the color mode}{\f1\fs20\cf1 :
\par cmLDefault\tab - default colors are used only
\par cmL16_16\tab - each line can have different colors
\par cmC16_16\tab - each character can have different colors
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property UserDataSize: Integer;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the size of user data room in terminal buffer. It also clears terminal buffer.}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnBeepChar: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when }{\f1\fs20\cf1 #07 character is written to the buffer
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnDrawBuffer: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Do NOT use, it is for debugging purposes only. It}{\f1\fs20\cf1 'll be removed in future versions
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnFlushLog: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when the log file}{\f1\fs20\cf1 's }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 buffers were flushed.
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnGetColors: TAfTRMGetColorsEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMGetColorsEvent = procedure (Sender: TObject; Line: Integer; var Colors: TAfTRMCharAttrs) of object;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs before DrawChangedBuffer method is called to get color information for newly inserted data. If TermColorMode = cmL}{\f1\fs20\cf1 16_16 you have to specify the color information in Colors[0] }{
\f1\fs20\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 property OnLoggingChange: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when Logging property is changed
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnNewLine: TAfTRMLineEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMLineEvent = procedure (Sender:TObject; Line: Integer) of object;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when LF character is written into terminal buffer. Line contains line number}{\f1\fs20\cf1  }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 of current line.
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnProcessChar: TAfTRMProcessCharEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMProcessCharEvent = procedure (Sender: TObject; var C: Char) of object; 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when new character is written into terminal buffer. You can replace it}{\f1\fs20\cf1  }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 here or discard it by setting C to }{\f1\fs20\cf1 #00}{
\f1\fs20\cf1\lang1029\langfe1033\langnp1029 . 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnScrBckBufChange: TAfTRMScrBckBufChange;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMScrBckBufChange = procedure (Sender: TObject; BufferSize: Integer) of object;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when ScrollBackMode is True and new character is written to the temporary buffer. The temporary buffer is theoretically unlimited, but you can limit its size her
e, by setting ScrollBackMode to False when BufferSize exceeded some size.
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnScrBckModeChange: TNotifyEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when ScrollBackMode property is changed
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnSendChar: TKeyPressEvent;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when user presses a character key and ScrollBackMode is False
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnUserDataChange: TAfTRMLineEvent;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfTRMLineEvent = procedure (Sender: TObject; Line: Integer) of object;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when UserData is changed. Line contains number of line which use
\par }{\fs20\cf1\lang1029\langfe1033\langnp1029 
\par 
\par }{\f2\fs20\cf1 {\*\shppict{\pict{\*\picprop\shplid1029{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex99\picscaley99\piccropl0\piccropr0\piccropt0\piccropb0
\picw547\pich547\picwgoal310\pichgoal310\pngblip\bliptag998117907{\*\blipuid 3b7e1213a491a847d9cc99bc194add7e}89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f13264900000009704859730000112c0000112c017f77e67a00
00007e4944415428cf6d903d0ec0200846d91cbdaa1bddecc8e6c59af42a6e32985081fed8b4249abc3c209f024e0509ee0a90e4acd80630914350102e0210c3
e2c06a6c863b53d1b66c46a4689b2de8dbfe36e33c66b4fd9813dc10d1bdedcaf60d5a3d7fb4a097b1a0efc7a59cf3b8117526b5d66a75c0550dae06f3ccfc5507a18295ab3f420d890000000049454e44ae426082}}{\nonshppict{\pict\picscalex97\picscaley97\piccropl0\piccropr0\piccropt0\piccropb0
\picw547\pich547\picwgoal310\pichgoal310\wmetafile8\bliptag998117907\blipupi111{\*\blipuid 3b7e1213a491a847d9cc99bc194add7e}010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc000000180018000000000018001800000000002800000018000000180000000100040000000000200100002c1100002c110000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbbbbb
bbbbbbbbbbbbbbbbb0000000000000000000000bb0bba0bfbfbfb0bba0bbbb0bb0f0b0fbfbfbf0f0b0bbbb0bb0ffb0bfbfbfb0ffb0bbbb0bb000000000000000
0000000bb0ffffffffffffffff0bba0bb0f00000000000000f0f0b0bb0ffffffffffffffff0ffb0bb0ffffffffffffffff00000bb0faaaaaaaaf00000f0bfb0b
b0faffffffafffffff0fbf0bb0faffffffafffffff0bfb0bb0faf2222faf00000f0fbf0bb0faffffffafffffff0bfb0bb0faf2222fafffffff0fbf0bb0faffff
ffaf00000f0bfb0bb0faf2faaaafffffff0fbf0bb0fafffafaffffffff00000bb0fafffaafff00000f0bba0bb0faaaaaffffffffff0f0b0bb0ffffffffffffffff0ffb0bb0000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbb05000000070101000000030000000000}}}{\f2\fs18\cf1  }{
\b\f2\fs44\cf1\lang1029\langfe1033\langnp1029 TAfFileViewer
\par }{\b\f1\fs20\cf1 Represents a simple unlimited text file viewer. It can be used for displaying log files from terminal window.
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 procedure CloseFile;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Closes the file
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par function FilePtrFromLine(Line: Integer): PChar;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns pointer to the text buffer for specified line
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure OpenFile;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Opens the file specified in FileName property
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure OpenData(const TextBuf: PChar; const TextSize: Integer);
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Opens buffer specified by pointer and its size.
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par property FileName: String;
\par }{\f1\fs20\cf1 Specifies the filename, but doesn't open the file. See OpenFile method 
\par }{\f2\fs18\cf2 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 property FileSize: DWORD; }{\f2\fs18\cf2 [ReadOnly] }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the size of text}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 property ScanPosition: Integer; }{\f2\fs18\cf2 [ReadOnly] }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Returns the position in text during scanning the number of lines}{\f1\fs20\cf12\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property ScanBlockStep}{\f2\fs18\cf12 : }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 TAfCVFScanStep;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfCVFScanStep = 1..MaxInt;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the size of block for OnScanBlock event
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property UseThreadScan}{\f2\fs18\cf12 : Boolean}{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 ;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 When True }{\f1\fs20\cf1 (default) scanning the number of lines runs in separate thread}{\f1\fs20\cf6\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par property OnScanBlock: TNotifyEvent}{\f2\fs18\cf6 ;}{\f2\fs18\cf6\lang1029\langfe1033\langnp1029 
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Occurs when the next block (which size is specified in ScanBlockStep) has}{\f1\fs20\cf1  }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 been scanned
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par 
\par }{\f2\fs20\cf1\lang1029\langfe1033\langnp1029 {\*\shppict{\pict{\*\picprop\shplid1030{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}
\picscalex99\picscaley99\piccropl0\piccropr0\piccropt0\piccropb0\picw517\pich517\picwgoal293\pichgoal293\pngblip\bliptag-340162368{\*\blipuid ebb988c00621b2c9960c14c059443b5f}
89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f13264900000009704859730000122b0000122b011e9de4c100
0000744944415428cf63a8ff0f07df197e74c0413fc30f06380072f8ffffffc039130826a0cba070b8562d5805440b3065504dfb802273978197e1ee055e08e7
0210f002492087074881c4ef5e802a83cbf05ec065340a07d93f283e2d07028e8e8e06108dc16100696080700a20dad9211c88c1400e00b8c870064630b4d10000000049454e44ae426082}}{\nonshppict{\pict\picscalex97\picscaley97\piccropl0\piccropr0\piccropt0\piccropb0
\picw517\pich517\picwgoal293\pichgoal293\wmetafile8\bliptag-340162368\blipupi118{\*\blipuid ebb988c00621b2c9960c14c059443b5f}010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc000000180018000000000018001800000000002800000018000000180000000100040000000000200100002b1200002b120000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbb000
00000000000bbbbbbbbbb0aaaaaaaaaaaa0bbbbbbbbbbb00aaaaaaaa00bbbbbbbbbbbbbb0aaaaaa0bbbbbbbbbbbbbbbb0aaaaaa0bbbbbbbbbfffffffffffffff
fffffffbfaaaaaaaaaaaaaaaaaaaaaaffa00000000000000000000affa00000000000000000000affa06600000000000000000affa00006600606006006060af
fa02006060666006006660affa00006060606006006060affa00006600060066600600affa0ff00000000000000000affa00000000000000000000affa000000
00000000000000affa0cccc0ccccc0ccc00000affa00000000000000000000affa00000000000000000000affa0ffffff0055555555550affa00000000000000000000affaaaaaaaaaaaaaaaaaaaaaafbffffffffffffffffffffffb05000000070101000000030000000000}}}{
\f2\fs18\cf1\lang1029\langfe1033\langnp1029  }{\b\f2\fs44\cf1 TAfDataTerminal
\par }{\b\f1\fs20\cf1 Represents a "data-aware" terminal window. It is descendant of TAfTerminal and it allows connect to a data dispatcher.
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property Active: Boolean;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the state of terminal. When True (default), terminal can receive and send data through assigned data dispatcher.
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Dispatcher: TAfCustomDataDispatcher;
\par }{\f1\fs20\cf1\lang1029\langfe1033\langnp1029 Specifies the data dispatcher
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par 
\par }{\f11\fs20\cf1\lang1029\langfe1033\langnp1029 {\*\shppict{\pict{\*\picprop\shplid1031{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}
\picscalex99\picscaley99\piccropl0\piccropr0\piccropt0\piccropb0\picw527\pich527\picwgoal299\pichgoal299\pngblip\bliptag-2054720518{\*\blipuid 858773fa6254133e673ff78130447919}
89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f1326490000000970485973000011c1000011c1013e7d638700
0000664944415428cf632847020c78381d10c0c0c000e4f4ff0703feff05208e0b08f8f3331420c9742071d8cb419c0606180019cd0f91faff01ccf90231e203a6ccddff7feffffdff17cce1fd7ffffedfbff7ef4239ff819cbfc8325065287a88b407c56dc40408001545a31a03dd82490000000049454e44ae426082}
}{\nonshppict{\pict\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0\picw527\pich527\picwgoal299\pichgoal299\wmetafile8\bliptag-2054720518\blipupi115{\*\blipuid 858773fa6254133e673ff78130447919}
010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc00000018001800000000001800180000000000280000001800000018000000010004000000000020010000c1110000c1110000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb000000000000000000bbbbbb0ffffffffffffffff0bbbbbb0ff111111111
111ff0bbbbbb0ffffffffffffffff0bbbbbb0f66fff66ff6fff6f0bbbbbb06ff6f6ff6f6fff6f0bbbbbb06ffff6ff6f6f6f6f0bbbbbb06ff6f6ff6f66f66f0bb
bbbb0f66fff66ff6fff6f0bbbbbb0ffffffffffffffff0bbbbbb0ff111111111111ff0bbbbbb0ffffffffffffffff0bbbba0000000000000000000bbbbafffff
ffffffff0bbbb0bbbbafffffffffffff0faab0bbbbaf11111111111f0f00b0bbbbafffffffffffff0fffb0bbbbaaaaaaaaaaaaaa000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb05000000070101000000030000000000}}}{
\f2\fs18\cf1\lang1029\langfe1033\langnp1029  }{\b\f2\fs44\cf1 TAfPortComboBox}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\b\f1\fs20\cf1 This is a specialized combo box that allows users to select desired serial port.
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 property ComNumber: Word;
\par }{\f1\fs20\cf1 Specifies the number of serial port
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property ComPort: TAfComPort;
\par }{\f1\fs20\cf1 Specifies the TAfComPort component
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Options: TAfPortCtlOptions;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfPortCtlOptions = set of (pcCheckExist, pcDisableOpen, pcHighlightOpen);
\par }{\f1\fs20\cf1 Specifies the behavior of this component:
\par pcCheckExist\tab - removes non existing serial port from list
\par pcDisableOpen\tab - removes currently opened serial port from list
\par pcHighlightOpen\tab - highlights currently opened serial port in drop down list
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property MaxComPorts: SmallInt;
\par }{\f1\fs20\cf1 Specifies the maximum number of serial ports in combo box list}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par 
\par 
\par }{\f11\fs20\cf1\lang1029\langfe1033\langnp1029 {\*\shppict{\pict{\*\picprop\shplid1032{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}
\picscalex99\picscaley99\piccropl0\piccropr0\piccropt0\piccropb0\picw527\pich527\picwgoal299\pichgoal299\pngblip\bliptag1785024817{\*\blipuid 6a6551314d6275a48f9a6d78cdfe7926}
89504e470d0a1a0a0000000d4948445200000018000000180403000000125920cb00000001735247420240c07dc500000030504c544500000080000000800080
8000000080800080008080c0c0c0808080ff000000ff00ffff000000ffff00ff00ffffffffff4f1326490000000970485973000011c1000011c1013e7d638700
0000694944415428cf632847020c689c121717177728a703cce9e8e8680772fa5b801c8fffffffdb8338c650d08fc96946e25870980075b9609121a4c7199b9e
bbc6b6976d8d6dc11c5be3cb976d6d2fdf85728c811c5b6419a832643dcd1d5000e2d4ff87018c30c0c10100730878e512b824ce0000000049454e44ae426082}}{\nonshppict{\pict\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0
\picw527\pich527\picwgoal299\pichgoal299\wmetafile8\bliptag1785024817\blipupi115{\*\blipuid 6a6551314d6275a48f9a6d78cdfe7926}010009000003f60000000000d200000000000400000003010800050000000b0200000000050000000c021800180005000000070104000000d2000000430f2000
cc00000018001800000000001800180000000000280000001800000018000000010004000000000020010000c1110000c1110000100000001000000000000000
80000000ff00000000008000800080000000ff00ff00ff0000800000808000000080800080808000c0c0c00000ff0000ffff000000ffff00ffffff00bbbbbbbb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbfffffffffffffffffffbbbba9aaaaaaaaaaaaaaaaafbbbbaf996699966996
9996afbbbbaf9699696996969996afbbbbaf9699996996969696afbbbbaf9699696996966966afbbbbaf9966999669969996afbbbbaf99a9999999999999afbb
bbaf9a0a911111111999afbbbbaf99a9999999999999afbbbbaf9999999999999999afbbbbaf99a9999999999999afbbbbaf9a0a911111111199afbbbbaf99a9
999999999999afbbbbaf9999999999999999afbbbbaf9999999999999999afbbbbafa11111111affffff9fbbbbaab11111111baaaaaaabbbbbbbb11111111bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb05000000070101000000030000000000}}}{
\f2\fs18\cf1\lang1029\langfe1033\langnp1029  }{\b\f2\fs44\cf1 TAfPortRadioGroup}{\b\f2\fs44\cf1\lang1029\langfe1033\langnp1029 
\par }{\b\f1\fs20\cf1 This is a specialized radio group that allows users to select desired serial port.
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 property ComNumber: Word;
\par }{\f1\fs20\cf1 Specifies the number of serial port
\par }{\f2\fs18\cf2\lang1029\langfe1033\langnp1029 
\par procedure UpdatePortList;
\par }{\f1\fs20\cf1 Updates the radio group
\par }{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 property ComPort: TAfComPort;
\par }{\f1\fs20\cf1 Specifies the TAfComPort component
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property Options: TAfPortCtlOptions;
\par }{\i\f2\fs18\cf1\lang1029\langfe1033\langnp1029 TAfPortCtlOptions = set of (pcCheckExist, pcDisableOpen, pcHighlightOpen);
\par }{\f1\fs20\cf1 Specifies the behavior of this component:
\par pcCheckExist\tab - disables non existing serial port items
\par pcDisableOpen\tab - disables currently opened serial port items
\par pcHighlightOpen\tab - highlights currently opened serial port items
\par }{\f2\fs18\cf12\lang1029\langfe1033\langnp1029 
\par property MaxComPorts: SmallInt;
\par }{\f1\fs20\cf1 Specifies the maximum number of serial ports in radio group}{\f2\fs18\cf1\lang1029\langfe1033\langnp1029 
\par 
\par }}