unit ReadSurfMain;
interface

uses Windows, Classes, Messages, Dialogs, Menus, Controls, ComCtrls, Forms,
     SysUtils, StdCtrls, Graphics, ExtCtrls,
     Gauges,WaveFormUnit, SurfPublicTypes, SurfAnal;

type
  TChanObj = class(TWaveFormWin)
    public
      Procedure ThreshChange(pid,cid : integer; ShiftDown,CtrlDown : boolean); override;
    end;

  TReadSurfForm = class(TForm)
    StatusBar: TStatusBar;
    Label1: TLabel;
    nspikeprobes: TLabel;
    Label2: TLabel;
    ncrprobes: TLabel;
    Label4: TLabel;
    nspikes: TLabel;
    Label5: TLabel;
    ncr: TLabel;
    Label6: TLabel;
    ndig: TLabel;
    StopButton: TButton;
    ProbeLabel: TLabel;
    Overlay: TCheckBox;
    Label3: TLabel;
    DigVal: TLabel;
    Pause: TCheckBox;
    label13: TLabel;
    mseq: TLabel;
    label12: TLabel;
    ori: TLabel;
    label11: TLabel;
    phase: TLabel;
    Label7: TLabel;
    time: TLabel;
    label0: TLabel;
    DataFileName: TLabel;
    WaveForms: TPanel;
    Guage: TGauge;
    Label8: TLabel;
    xpos: TLabel;
    Label10: TLabel;
    ypos: TLabel;
    Label15: TLabel;
    con: TLabel;
    Label17: TLabel;
    sf: TLabel;
    Label19: TLabel;
    wid: TLabel;
    Label21: TLabel;
    len: TLabel;
    MainMenu1: TMainMenu;
    FileMenu: TMenuItem;
    OpenFile: TMenuItem;
    OpenDialog: TOpenDialog;
    SurfAnal: TSurfAnal;
    procedure StopButtonClick(Sender: TObject);
    procedure ExperimentClick(Sender: TObject);
    procedure OpenFileClick(Sender: TObject);
    procedure SurfAnalSurfFile(SurfFile: TSurfFileInfo);
  private
    { Private declarations }
    HaltRead : boolean;
  public
    { Public declarations }
  end;

var
  ReadSurfForm: TReadSurfForm;

implementation

uses About;

{$R *.DFM}

procedure TReadSurfForm.StopButtonClick(Sender: TObject);
begin
  HaltRead := TRUE;
end;

procedure TReadSurfForm.ExperimentClick(Sender: TObject);
begin
  mseq.caption := inttostr(0);
  ori.caption := inttostr(0);
  phase.caption := inttostr(0);
end;

Procedure TChanObj.ThreshChange(pid,cid : integer; ShiftDown,CtrlDown : boolean);
begin
end;


procedure TReadSurfForm.OpenFileClick(Sender: TObject);
begin
  If OpenDialog.Execute then
    SurfAnal.SendFileRequestToSurf(OpenDialog.Filename);
end;

procedure TReadSurfForm.SurfAnalSurfFile(SurfFile: TSurfFileInfo);
type
  TWaveFormWin = record
    exists : boolean;
    Win : TChanObj;
  end;
var
  spikeprobeindex,crprobeindex : array[0..32] of boolean;
  c,np,p,e,i,nsp,ncp,OrigHeight,OrigWidth : integer;
  w : WORD;
  msb,lsb : BYTE;
  WaveFormWin : array[0..32] of TWaveFormWin;

begin
//check integrity of file
  ReadSurfForm.BringToFront;
  DataFileName.Caption := SurfFile.FileName;
  mseq.caption := inttostr(0);
  ori.caption := inttostr(0);
  phase.caption := inttostr(0);
  digval.caption := inttostr(0);

  for p := 0 to 32 do
  begin
    spikeprobeindex[p] := FALSE;
    crprobeindex[p] := FALSE;
  end;

  HaltRead := FALSE;

  nspikeprobes.caption := inttostr(0);
  ncrprobes.caption := inttostr(0);
  nspikes.caption := inttostr(0);
  ncr.caption := inttostr(0);
  ndig.caption := inttostr(0);

  For c := 0 to 32 do
    WaveFormWin[c].exists := FALSE;

  OrigWidth := ReadSurfForm.ClientWidth;
  OrigHeight := ReadSurfForm.ClientHeight;

  With SurfFile do
  begin
    np := length(ProbeArray);
    //Setup WaveForm Windows
    for p := 0 to np-1 do
      case ProbeArray[p].ProbeSubType of
        SPIKETYPE :
          begin
            spikeprobeindex[p] := TRUE;
            for c := 0 to ProbeArray[p].numchans-1 do
            begin
              WaveFormWin[ProbeArray[p].chanlist[c]].exists := TRUE;
              WaveFormWin[ProbeArray[p].chanlist[c]].win := TChanObj.CreateParented(WaveForms.Handle);
              WaveFormWin[ProbeArray[p].chanlist[c]].win.InitPlotWin({npts}ProbeArray[p].pts_per_chan,
                                                           {left}ProbeArray[p].screenlayout[c].x,
                                                           {top} ProbeArray[p].screenlayout[C].y,
                                                       {bmheight}50,
                                                        {intgain}ProbeArray[p].intgain,
                                                         {thresh}ProbeArray[p].threshold,
                                                         {trigpt}ProbeArray[p].trigpt,
                                                        {probeid}p,
                                                         {chanid}ProbeArray[p].chanlist[c],
                                                      {probetype}ProbeArray[p].ProbeSubType,
                                                          {title}'Chan '+inttostr(ProbeArray[p].chanlist[c]),
                                                           {view}TRUE,
                                                {acquisitionmode}FALSE);
              WaveFormWin[ProbeArray[p].chanlist[c]].win.MarkerV.Visible := FALSE;
              WaveFormWin[ProbeArray[p].chanlist[c]].win.MarkerH.Visible := FALSE;
              if ReadSurfForm.ClientWidth < ProbeArray[p].screenlayout[c].x + WaveFormWin[ProbeArray[p].chanlist[c]].win.width
                then ReadSurfForm.ClientWidth := ProbeArray[p].screenlayout[c].x + WaveFormWin[ProbeArray[p].chanlist[c]].win.width;
              if ReadSurfForm.ClientHeight      < StatusBar.height + Guage.Height + WaveForms.Top + WaveFormWin[ProbeArray[p].chanlist[c]].win.top + WaveFormWin[ProbeArray[p].chanlist[c]].win.height
                then ReadSurfForm.ClientHeight := StatusBar.height + Guage.Height + WaveForms.Top + WaveFormWin[ProbeArray[p].chanlist[c]].win.top + WaveFormWin[ProbeArray[p].chanlist[c]].win.height;
            end;
          end;
        CONTINUOUSTYPE :
          begin
            crprobeindex[p] := TRUE;
            c := ProbeArray[p].chanlist[0];
            WaveFormWin[c].exists := TRUE;
            WaveFormWin[c].win := TChanObj.CreateParented(WaveForms.Handle);
            WaveFormWin[c].win.InitPlotWin({npts}ProbeArray[p].pts_per_chan,
                                        {left}ProbeArray[p].screenlayout[0].x,
                                        {top} ProbeArray[p].screenlayout[0].y,
                                    {bmheight}50,
                                     {intgain}ProbeArray[p].intgain,
                                      {thresh}ProbeArray[p].threshold,
                                      {trigpt}ProbeArray[p].trigpt,
                                     {probeid}p,
                                      {chanid}c,
                                   {probetype}ProbeArray[p].ProbeSubType,
                                       {title}ProbeArray[p].probe_descrip,
                                        {view}TRUE,
                             {acquisitionmode}FALSE);

            if ReadSurfForm.ClientWidth < ProbeArray[p].screenlayout[0].x + WaveFormWin[c].win.width
              then ReadSurfForm.ClientWidth := ProbeArray[p].screenlayout[0].x + WaveFormWin[c].win.width;
            if ReadSurfForm.ClientHeight      < StatusBar.height + Guage.Height + WaveForms.Top + WaveFormWin[c].win.top + WaveFormWin[c].win.height
              then ReadSurfForm.ClientHeight := StatusBar.height + Guage.Height + WaveForms.Top + WaveFormWin[c].win.top + WaveFormWin[c].win.height;
          end;
      end{case};

    nsp := 0;
    ncp := 0;
    for p := 0 to 32 do
    begin
      if spikeprobeindex[p] then inc(nsp);
      if crprobeindex[p] then inc(ncp);
    end;
    nspikeprobes.caption := inttostr(nsp);
    ncrprobes.caption := inttostr(ncp);

    // Now read the data using the event array
    Guage.MinValue := 0;
    Guage.MaxValue := NEvents-1;

    for e := 0 to NEvents-1 do
    begin
      p := SurfEventArray[e].probe;
      i := SurfEventArray[e].Index;
      case SurfEventArray[e].EventType of
        SURF_PT_REC_UFFTYPE {'N'}: //handle spikes and continuous records
          case SurfEventArray[e].subtype of
            SPIKETYPE  {'S'}:
              begin //spike record found
                time.caption := inttostr(ProbeArray[p].spike[i].time_stamp);
                for c := 0 to ProbeArray[p].numchans-1 do
                  WaveFormWin[ProbeArray[p].ChanList[c]].win.PlotWaveForm(ProbeArray[p].spike[i].WaveForm[c],ProbeArray[p].spike[i].cluster,overlay.checked);
                nspikes.caption := inttostr(i+1);
              end;
            CONTINUOUSTYPE {'C'}:
              begin //continuous record found
                time.caption := inttostr(ProbeArray[p].cr[i].time_stamp);
                WaveFormWin[ProbeArray[p].ChanList[0]].win.PlotWaveForm(ProbeArray[p].cr[i].WaveForm,2{ltgreen},FALSE{overlay});
                ncr.caption := inttostr(i+1);
              end;
          end;
        SURF_SV_REC_UFFTYPE {'V'}: //handle single values (including digital signals)
          case SurfEventArray[e].subtype of
            SURF_DIGITAL {'D'}:
              begin
                time.caption := inttostr(SValArray[i].time_stamp);
                w := SValArray[i].sval;
                digval.caption := inttostr(w);
                msb := w and $00FF; {get the last byte of this word}
                lsb := w shr 8;      {get the first byte of this word}
                mseq.caption := inttostr(msb*256+lsb);
                ori.caption := inttostr((msb and $01) shl 8 + lsb); //get the last bit of the msb
                phase.caption := inttostr(msb shr 1);//get the first 7 bits of the msb

                ndig.caption := inttostr(i+1);
              end;
          end;
        SURF_MSG_REC_UFFTYPE {'M'}://handle surf messages
          begin
            time.caption := inttostr(SurfMsgArray[i].time_stamp);
            StatusBar.SimpleText := SurfMsgArray[i].Msg;
          end;
      end {case};
      Guage.Progress := e;
      Application.ProcessMessages;
      if HaltRead then break;
      While pause.checked do
      begin
        Application.ProcessMessages;
        if HaltRead then break;
      end;
    end{event loop};
  end;

  ShowMessage('done');
  For c := 0 to 32 do
    if WaveFormWin[c].exists then WaveFormWin[c].win.free;

  StatusBar.SimpleText := 'Done';

  //free memory?
  ReadSurfForm.ClientWidth := OrigWidth;
  ReadSurfForm.ClientHeight := OrigHeight;
  Guage.Progress := 0;
end;

end.
