unit SurfLocateAndSort;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  ExtCtrls, ComCtrls, StdCtrls, SurfPublicTypes, ElectrodeTypes, NumRecipies,
  Spin;

const MAXARRAY = 5000;
      ELECTRODEBORDER = 150;
      MINDIST = 180;
      V2uV = 1000000;//1 million (uV -> V)

type
  PointRec = record
    x,y,z,c : integer;
  end;
  DistArrayType = array of single;

  LocEstLevMarqObj = class(LevMarqObj)
    public
      Procedure CheckBounds(var a : DArrayNP); override;
      Procedure func(xx : double; var a : DArrayNP; var yfit : double;
               var dyda : DarrayNP;  ma,mfit : integer; computedyda : boolean); override;
      //Procedure CallOut(var well : wellrec; var iter,ma,mfit : integer; var a : DArrayNP; chisq,chidiff : double; wellhist : wellhisttype; final : boolean); {override;}
  end;

  TLocSortForm = class(TForm)
    StatusBar: TStatusBar;
    Timer: TTimer;
    Panel1: TPanel;
    BSave: TButton;
    BWag: TButton;
    SpinDegrees: TSpinEdit;
    Label1: TLabel;
    CShowElectrode: TCheckBox;
    SpinMaxAngle: TSpinEdit;
    Label2: TLabel;
    Label3: TLabel;
    procedure TimerTimer(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure FormHide(Sender: TObject);
    procedure BSaveClick(Sender: TObject);
    procedure BWagClick(Sender: TObject);
  private
    { Private declarations }
    CurPixIndex : Integer;
    theta : single;
    thetasign : integer; // +/- 1
    Electrode : ElectrodeRec;
    xoff,yoff,ADGain,ExtGain,LoopCount : integer;
    LocEstLevMarq : LocEstLevMarqObj;
    Saving : boolean;
    Function  Rx(x,y,z : integer) : integer;//the three d to 2d transform
    Procedure DrawElectrode;
    Procedure ComputeXYZ(Distance : DistArrayType; var px,py,pz : integer);
    Procedure TransForm(x,y,z : integer; var tx,ty : integer);//the three d to 2d transform
    procedure AddAPixel(x,y,z,c : integer);
  public
    { Public declarations }
    Wagging : Boolean;
    lsbm,ebm : TBitmap;
    PixelArray : array of PointRec;
    Distance : DistArrayType;
    procedure Render;
    Function CreateElectrode(ElectrodeName : ShortString;
                             a2dgain,exgain : Integer) : boolean;
    procedure ComputeLoc(var Spike : TSpike; m,b : double);
  end;

var
  LocSortForm: TLocSortForm;
  VInfinite : single;

implementation

{$R *.DFM}

{--------------------------------------------------------------------}
Function TLocSortForm.CreateElectrode(ElectrodeName : ShortString;
                                     a2dgain,exgain : Integer) : boolean;
var maxx,minx,maxy,miny,i : integer;
begin
  ADGain := a2dgain;
  ExtGain := ExGain;

  if not GetElectrode(Electrode,ElectrodeName) then
  begin
    CreateElectrode := FALSE;
    ShowMessage(ElectrodeName+' is an unknown electrode');
    exit;
  end else
  With Electrode do
  begin
    if NumPoints > MAXELECTRODEPOINTS then NumPoints := MAXELECTRODEPOINTS;
    minx := 10000;
    miny := 10000;
    maxx := -10000;
    maxy := -10000;
    For i := 0 to NumSites-1 do
    begin
      if minx > SiteLoc[i].x then minx := SiteLoc[i].x;
      if miny > SiteLoc[i].y then miny := SiteLoc[i].y;
      if maxx < SiteLoc[i].x then maxx := SiteLoc[i].x;
      if maxy < SiteLoc[i].y then maxy := SiteLoc[i].y;
    end;
    TopLeftSite.x := minx;
    TopLeftSite.y := miny;
    BotRightSite.x := maxx;
    BotRightSite.y := maxy;

    minx := minx - ELECTRODEBORDER;
    miny := miny - ELECTRODEBORDER;
    maxx := maxx + ELECTRODEBORDER;
    maxy := maxy + ELECTRODEBORDER;
    For i := 0 to NumPoints-1 do
    begin
      if minx > Outline[i].x then minx := Outline[i].x;
      if miny > Outline[i].y then miny := Outline[i].y;
      if maxx < Outline[i].x then maxx := Outline[i].x;
      if maxy < Outline[i].y then maxy := Outline[i].y;
    end;

    ebm.Width := maxx-minx;
    ebm.Height := maxy-miny;
    lsbm.Width := ebm.width;
    lsbm.Height := ebm.height;
    LocSortForm.ClientWidth := ebm.width;
    LocSortForm.ClientHeight := ebm.height;

    xoff := -minx;
    yoff := -miny;

    ebm.canvas.Brush.Color := clBlack;
    lsbm.Canvas.Brush.Color := clBlack;
    ebm.canvas.font.color := clDkGray;

    Created := TRUE;
  end;
  SetLength(Distance,Electrode.NumSites);
  CreateElectrode := TRUE;
  Wagging := TRUE;
  Timer.Enabled := TRUE;
  BWag.Caption := 'Stop';
end;

{--------------------------------------------------------------------}
Function TLocSortForm.DrawElectrode;
var i,x1,y1 : integer;
    plg : array of TPoint;
begin
  With Electrode do
  begin
    ebm.Canvas.FillRect(LocSortForm.clientRect);//clear electrode bm
    ebm.canvas.Pen.Color := clDkGray;
    x1 := Rx(Outline[0].x+xoff,Outline[0].y+yoff,0);
    y1 := Outline[0].y+yoff;
    ebm.canvas.moveto(x1,y1); //draw outline
    SetLength(plg,NumPoints+1);
    For i := 0 to NumPoints-1 do
    begin
      plg[i].x := Rx(Outline[i].x+xoff,Outline[i].y+yoff,0);
      plg[i].y := Outline[i].y+yoff;
    end;
    plg[NumPoints].x := plg[0].x;
    plg[NumPoints].y := plg[0].y;

    //For i := 1 to NumPoints-1 do
      //ebm.canvas.lineto(Rx(Outline[i].x+xoff,Outline[i].y+yoff,0),Outline[i].y+yoff);
    ebm.canvas.Brush.Color := RGB(48,64,48);
    ebm.canvas.PolyGon(plg);
    ebm.canvas.Brush.Color := clBlack;
    ebm.canvas.Font.Color := clBlack;
    //ebm.canvas.FloodFill(Rx(SiteLoc[0].x+xoff,SiteLoc[0].y+yoff,0),SiteLoc[0].y+yoff,clBlack,fsSurface);

    ebm.canvas.Pen.Color := $005E879B;
    ebm.canvas.Brush.Color := $005E879B;
    For i := 0 to NumSites-1 do  //draw the electrode sites
    begin
      ebm.canvas.Brush.Color := $005E879B;
      case roundsite of
        TRUE : ebm.canvas.ellipse(RX(SiteLoc[i].x+xoff-SiteSize.x div 2,SiteLoc[i].y+yoff-SiteSize.y div 2,0),SiteLoc[i].y+yoff-SiteSize.y div 2,
                                  RX(SiteLoc[i].x+xoff+SiteSize.x div 2,SiteLoc[i].y+yoff+SiteSize.y div 2,0),SiteLoc[i].y+yoff+SiteSize.y div 2);
        {TRUE : ebm.canvas.arc(RX(SiteLoc[i].x+xoff-SiteSize.x div 2,SiteLoc[i].y+yoff-SiteSize.y div 2,0),SiteLoc[i].y+yoff-SiteSize.y div 2,
                              RX(SiteLoc[i].x+xoff+SiteSize.x div 2,SiteLoc[i].y+yoff+SiteSize.y div 2,0),SiteLoc[i].y+yoff+SiteSize.y div 2,
                              RX(SiteLoc[i].x+xoff-SiteSize.x div 2,SiteLoc[i].y+yoff,0),SiteLoc[i].y+yoff,
                              RX(SiteLoc[i].x+xoff-SiteSize.x div 2,SiteLoc[i].y+yoff,0),SiteLoc[i].y+yoff);}
        FALSE : ebm.canvas.framerect(rect(SiteLoc[i].x+xoff-SiteSize.x div 2,SiteLoc[i].y+yoff-SiteSize.y div 2,
                                          SiteLoc[i].x+xoff+SiteSize.x div 2,SiteLoc[i].y+yoff+SiteSize.y div 2));
      end;
      if not wagging then
      begin
        ebm.canvas.Brush.Color := RGB(48,64,48);
        ebm.canvas.TextOut(RX(SiteLoc[i].x+xoff+SiteSize.x div 2+1,SiteLoc[i].y+yoff,0),SiteLoc[i].y+yoff,inttostr(i));
      end;
    end;
    //ebm.canvas.TextOut(RX(ebm.width div 2-ebm.canvas.TextWidth(Name) div 2,0,0),0,Name);
  end;
  ebm.canvas.Brush.Color := clBlack;
end;

{--------------------------------------------------------------------}
Function TLocSortForm.Rx(x,y,z : integer) : integer;//the three d to 2d transform
begin
  Rx := round((x-xoff) * cos(theta) + z * sin(theta)) + xoff;
end;

{--------------------------------------------------------------------}
procedure TLocSortForm.TransForm(x,y,z : integer; var tx,ty : integer);//the three d to 2d transform
begin
  tx := Rx(x,y,z);
  ty := y;
end;

{--------------------------------------------------------------------}
procedure TLocSortForm.Render;
var p,tx,ty,ang : integer;
    pb : PByteArray;
    col : TColor;
function outofbounds(x,y : integer) : boolean;
begin
  if (x < 0) or (x >= lsbm.Width) or (y < 0) or (y >= lsbm.Height)
    then OutOfBounds := TRUE
    else OutOfBounds := FALSE;
end;
begin
  //lsbm.Canvas.FillRect(LocSortForm.clientRect);
  //xo := round((lsbm.width - ebm.width * 2*cos(theta)/2));
  //lsbm.canvas.StretchDraw(rect(xo,0,lsbm.width-xo-1,lsbm.height-1),ebm);//draw the electrode bm
  DrawElectrode;
  lsbm.Canvas.Brush.Color := clBlack;
  if CShowElectrode.Checked
    then lsbm.canvas.Draw(0,0,ebm)//draw the electrode bm
    else  lsbm.Canvas.FillRect(LocSortForm.clientRect);
  For p := 0 to Length(PixelArray)-1 do
    With PixelArray[p] do
    begin
      TransForm(x,y,z,tx,ty);//The 3D to 2D Transform
      if not outofbounds(tx,ty) then
      begin
        if p = (CurPixIndex+MAXARRAY-1) mod MAXARRAY then
        begin
          lsbm.Canvas.Pen.Color := clRed;
          lsbm.Canvas.Brush.Color := clRed;
          lsbm.Canvas.Rectangle(tx-2,ty-2,tx+2,ty+2);
        end else
        begin
          pb := lsbm.ScanLine[ty];
          col := {clYellow}COLORTABLE[c];
          pb[tx*3]   := GetBValue(col);
          pb[tx*3+1] := GetGValue(col);
          pb[tx*3+2] := GetRValue(col);
        end;
      end;
    end;
  //BitBlt(LocSortForm.Canvas.Handle,0,0,lsbm.Height,lsbm.Width,lsbm.canvas.handle,0,0,SRCCOPY);
  ang := round(theta/PI*180);
  If Saving and (ang >= 0) and (LoopCount in [1,2])
    then lsbm.SaveToFile('3DPic_'+inttostr(ang)+'_deg.bmp');

  LocSortForm.Canvas.Draw(0,0,lsbm);
  LocSortForm.Update;
end;

{--------------------------------------------------------------------}
procedure TLocSortForm.AddAPixel(x,y,z,c : integer);
var l : integer;
begin
  if not electrode.Created then begin beep; exit; end;
  l := Length(PixelArray);
  If l < MAXARRAY then
    SetLength(PixelArray,l+1);
  PixelArray[CurPixIndex].x := x;
  PixelArray[CurPixIndex].y := y;
  PixelArray[CurPixIndex].z := z;
  PixelArray[CurPixIndex].c := c;

  CurPixIndex := (CurPixIndex+1) mod MAXARRAY;
  //TransForm(x,y,z,tx,ty);//the three d to 2d transform
  //LocSortForm.Canvas.Pixels[tx,ty] := clYellow{COLORTABLE[c]};//COLORTABLE[c];
end;

{--------------------------------------------------------------------}
Procedure TLocSortForm.ComputeXYZ(Distance : DistArrayType; var px,py,pz : integer);
var c : integer;
    x,y,sig     : DArrayNDATA;
    ndata       : integer;
    a           : DArrayNP;
    ma          : integer;
    lista       : IArrayNP;
    mfit        : integer;
    covar,alpha : DArrayNPbyNP;
    firstchisq,chisq,alamda,lastchisq,chidiff: double;
    iter : integer;

Procedure RunLevenberg;
const RUNAVEWIN = 10;
var
    runningchidiff : double;
begin
  //Initialize
  iter := 0;
  chisq := 0;
  alamda := -1.0;
  //ra := highgrey - lowgrey;
  //if ra < 0 then ra := 0;
  //range := sqrt(sqrt(ra));

  //LocEstLevMarq.CallOut(well,iter,ma,mfit,a,chisq/ndata,runningchidiff,wellhist,false);
  LocEstLevMarq.mrqmin(x,y,sig,ndata,a,ma,lista,mfit,covar,alpha,chisq,alamda);
  firstchisq := chisq;
  //StatusBar.SimpleText := floattostr(chisq);//+' , '+floattostr(lastchisq)+' , '+floattostr(chidiff)+' , '+floattostr(runningchidiff);

  //if mfit > 3 then WellProfileLevMarq.CallOut(well,iter,ma,mfit,a,chisq/ndata,runningchidiff,wellhist,false);
  iter := 1;
  lastchisq := chisq;
  runningchidiff := 1;
  While true do
  begin
    Application.ProcessMessages;
    LocEstLevMarq.mrqmin(x,y,sig,ndata,a,ma,lista,mfit,covar,alpha,chisq,alamda);

    {if iter mod 5 = 0 then
      then WellProfileLevMarq.CallOut(well,iter,ma,mfit,a,chisq/ndata,runningchidiff,wellhist,false);
    }
    inc(iter);
    if iter > 1000 then break;
    chidiff := ((lastchisq-chisq)/(lastchisq))*100000;
    if chidiff >= 0 then //there has been litle or no decrease, but not an increase
    begin
      runningchidiff := runningchidiff * 0.8 + chidiff * 0.2;
      if runningchidiff < 0.00001{%} then break;
    end;
    {if iter=2 then
      StatusBar.SimpleText := floattostr(chisq)+' , '+floattostr(chidiff)+' , '+floattostr(runningchidiff);}
    lastchisq := chisq;
  end;
  alamda := 0.0;
  LocEstLevMarq.mrqmin(x,y,sig,ndata,a,ma,lista,mfit,covar,alpha,chisq,alamda);

  {StatusBar.SimpleText := inttostr(iter)+','+floattostrf(firstchisq,fffixed,4,2)
                                        +' , '+floattostrf(chisq,fffixed,4,2)
                                        +' , '+floattostrf(chidiff,fffixed,4,2)
                                        +' , '+floattostrf(runningchidiff,fffixed,4,2);
  }//if mfit > 3 then LocEstLevMarq.CallOut(well,iter,ma,mfit,a,chisq/ndata,runningchidiff,wellhist,true);
end{RunLevenberg};
begin
  //px,py,pz are the initial guesses based on weight mean
  //ndata := Length(Distance);
  ndata := 0;
  for c := 1 to Length(Distance) do
  begin
    if sqrt(sqr(px-Electrode.SiteLoc[c-1].x)+sqr(py-Electrode.SiteLoc[c-1].y)) < MINDIST then
    begin
      inc(ndata);
      x[ndata] := c;
      y[ndata] := Distance[c-1];
      sig[ndata] := sqrt(Distance[c-1]);
    end;
  end;
  (*for c := 1 to ndata do
  begin
    x[c] := c;
    if Distance[c-1] < 1 then Distance[c-1] := 1;
    y[c] := Distance[c-1];
    sig[c] := {sqrt}(Distance[c-1]);
  end; *)
  ma := 3;
  a[1] := px;
  a[2] := py;
  a[3] := pz;
  mfit := 3;
  lista[1] := 1;
  lista[2] := 2;
  lista[3] := 3;

  RunLevenberg;
  px := round(a[1]);
  py := round(a[2]);
  pz := round(a[3]);
  //StatusBar.SimpleText := inttostr(iter);//+','+inttostr(px)+','+inttostr(py)+','+inttostr(pz);
end;

{=========================================================================}
Procedure LocEstLevMarqObj.CheckBounds(var a : DArrayNP); //parameters
begin
  if a[3] < 0 then a[3] := 0;//}abs(a[3]);
end;

{=========================================================================}
Procedure LocEstLevMarqObj.func(xx : double;   //xindex
                             var a : DArrayNP; //parameters
                          var yfit : double;   //return
                          var dyda : DarrayNP; //derivatives wr2 params
                           ma,mfit : integer;  //numparams, numfit
                       computedyda : boolean); //compute the derivatives
var i,sx,sy,sz : integer;
    r2,rx,ry,rz,rx2,ry2,rz2 : double;
begin
   i := round(xx)-1;
   sx := LocSortForm.Electrode.SiteLoc[i].x;
   sy := LocSortForm.Electrode.SiteLoc[i].y;
   sz := 0;

   rx := a[1]-sx;
   ry := a[2]-sy;
   rz := a[3]-sz;
   rx2 := sqr(rx);
   ry2 := sqr(ry);
   rz2 := sqr(rz);

   r2 := rx2 + ry2 + rz2;
   if r2 < 1 then r2 := 1;
   yfit{radius} := sqrt(r2);
   if computedyda then
   begin
     dyda[1] := rx/r2;
     dyda[2] := ry/r2;
     dyda[3] := rz/r2;
   end;
end;

{--------------------------------------------------------------------}
procedure TLocSortForm.ComputeLoc(var Spike : TSpike; m,b : double);
const MAXDIST = 999;
var  np,x,y,z,w,meanx,meany,c,maxad : integer;
     f,amp,d,Doff : single;
     s : String;
  procedure GetCentroid(pass : integer);
  var sumw,sumwx,sumwy : double;
      c : integer;
  begin
    With Spike do
    begin
      sumwx := 0;
      sumwy := 0;
      sumw := 0;
      for c := 0 to np-1 do
      begin
        x := Electrode.SiteLoc[c].x;
        y := Electrode.SiteLoc[c].y;
        if (pass=1) or (sqrt(sqr(x-meanx)+sqr(y-meany)) < MINDIST) then
        begin
          w := param[c*2];{SHRT peak for chan c}
          w := w*w;
          sumwx := sumwx + w*x;
          sumwy := sumwy + w*y;
          sumw := sumw + w;
        end;
      end;
      if sumw = 0 then sumw := 1;
      meanx := round(sumwx/sumw);
      meany := round(sumwy/sumw);
    end;
  end;

begin
  if not electrode.Created then begin beep; exit; end;
  np := Length(Spike.param) div 2;
  if electrode.NumSites < np{pk,vl} then begin beep; exit; end;
  meanx := 0;
  meany := 0;

  GetCentroid(1); //pass1
  GetCentroid(2); //pass2
  x := meanx; //initial guess for levmarq
  y := meany; //initial guess for levmarq
  z := 50;    //initial guess for levmarq

  amp := 10 {* V2uV }/ (2048 * ExtGain * ADGAin);
  //maxv := VINFINITE{uV};
  //v2d_m := 1/971;
  //xoff2 := sqrt(maxv)/(maxv*v2d_m);{the distance to the point where the voltage would be near infinite}
  Doff := sqrt(V2uV/VINFINITE);
  s := '';
  maxad := 0;
  for c := 0 to np-1 do
  begin
    f := Spike.param[c*2];{peak in a/d}
    if f < 1 then f := 1;
    f := Spike.param[c*2]*amp;{peak in uV}
    //linear
    {d := (Vinfinite-V2uV*f - b)/m;
    if d < 0 then d := 0;
    if d > MAXDIST then d := MAXDIST;
    }
    if f > 0 then d := (sqrt(1/f)-Doff{-b})/m
             else d := MAXDIST;

    (*f := Spike.param[c*2] * amp;{peak in uV}
    if f > 0 then d := sqrt(f)/(f*m) - b{the volt to dist transform plus xoffset(b/a)}
             else d := MAXDIST;
    *)
    if d < 1 then d := 1;
    if maxad < Spike.param[c*2] then
    begin
      maxad := Spike.param[c*2];
      //s := 'ad='+inttostr(maxad)+', v='+inttostr(round(f))+'uV, dist='+inttostr(round(d))+'uM';
    end;//
    s := s + {inttostr(round(f*V2uV))+'='+}inttostr(round(d))+' ';
    Distance[c] := d;
  end;
  //StatusBar.SimpleText := s;
  statusbar.refresh;
  ComputeXYZ(Distance,x,y,z);
  //SortSpike(x,y,z,Spike.Cluster);
  if maxad < 2047 then
    AddAPixel(x+xoff,y+yoff,z,Spike.Cluster);
end;

{--------------------------------------------------------------------}
procedure TLocSortForm.TimerTimer(Sender: TObject);
var ThetaStep,MaxTheta : Single;

begin
  if wagging then
  begin
    thetastep := SpinDegrees.Value * PI/180;
    maxtheta := SpinMaxAngle.Value*PI/180;

    theta := theta + thetasign * thetastep;
    if theta > maxtheta then
    begin
      theta := maxtheta;
      thetasign := -thetasign; //reverse
      inc(LoopCount);
    end;
    if theta < -maxtheta then
    begin
      theta := -maxtheta;
      thetasign := -thetasign; //reverse
      inc(LoopCount);
    end;
  end;
  Render;
end;

{--------------------------------------------------------------------}
procedure TLocSortForm.FormShow(Sender: TObject);
begin
  lsbm := TBitmap.Create;
  lsbm.PixelFormat := pf24bit;

  ebm := TBitmap.Create;
  ebm.PixelFormat := pf24bit;

  Wagging := FALSE;
  Saving := FALSE;
  theta := 0;
  LoopCount := 0;
  Timer.Enabled := FALSE;
  thetasign := 1;
  CurPixIndex := 0;
  Electrode.Created := FALSE;
  LocEstLevMarq := LocEstLevMarqObj.Create;
end;

{--------------------------------------------------------------------}
procedure TLocSortForm.FormHide(Sender: TObject);
begin
  timer.enabled :=FAlSE;
  wagging := false;
  LocSortForm.lsbm.Free;
  LocSortForm.ebm.Free;
  LocSortForm.PixelArray := nil;
  Distance := nil;
  LocEstLevMarq.Free;
end;

procedure TLocSortForm.BSaveClick(Sender: TObject);
begin
  Saving := TRUE;
  LoopCount := 0;
end;

procedure TLocSortForm.BWagClick(Sender: TObject);
begin
  If Wagging then
  begin
    Wagging := FALSE;
    BWag.Caption := 'Wag';
  end else
  begin
    Wagging := TRUE;
    BWag.Caption := 'Stop';
  end;
end;

end.


