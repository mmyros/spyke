unit MSeqAnal;

interface

USES
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  Gauges, ComCtrls, SurfFile, StdCtrls, SurfTypes, Spin, Math, ExtCtrls,ShellApi,
  MPlayer;

CONST
  MAXLEN = 31;
  POLYPRIMATIVES : array[1..MAXLEN,0..4] of longint
  = ((1,1, 0, 0, 0),{1}
     (2,1, 2, 0, 0),{2}
     (2,1, 3, 0, 0),{3}
     (2,1, 4, 0, 0),{4}
     (2,2, 5, 0, 0),{5}
     (2,1, 6, 0, 0),{6}
     (2,1, 7, 0, 0),{7}
     (4,2, 3, 4, 8),{8}
     (2,4, 9, 0, 0),{9}
     (2,6,10, 0, 0),{10 was (2,3,10, 0, 0)}
     (4,1, 2, 4,11),{11 was (2,2,11, 0, 0)}
     (4,1, 4, 6,12),{12}
     (4,1, 3, 4,13),{13}
     (4,1, 3, 5,14),{14}  //this is 16x16 (2^4 * 2^4) with an offset of 64 (2^6) = 2^14
     (2,1,15, 0, 0),{15}
     (4,2, 3, 5,16),{16}  //this is 32x32 (2^5 * 2^5) with an offset of 64 (2^6) = 2^16
     (2,3,17, 0, 0),{17}
     (4,1, 2, 5,18),{18}
     (4,1, 2, 5,19),{19}
     (2,3,20, 0, 0),{20 was (2,3,20, 0, 0)}
     (2,2,21, 0, 0),{21 was (2,2,21, 0, 0)}
     (2,1,22, 0, 0),{22}
     (2,5,23, 0, 0),{23}
     (4,1, 3, 4,24),{24}
     (2,3,25, 0, 0),{25}
     (4,1, 2, 6,26),{26}
     (4,1, 2, 5,27),{27}
     (2,3,28, 0, 0),{28}
     (2,2,29, 0, 0),{29}
     (4,1, 4, 6,30),{30}
     (2,3,31, 0, 0)){31};

     AD2DEG = 81.92;

type
  TMSeqForm = class(TForm)
    Guage: TGauge;
    StatusBar: TStatusBar;
    Label4: TLabel;
    nspikes: TLabel;
    label13: TLabel;
    mseqval: TLabel;
    Label3: TLabel;
    DigVal: TLabel;
    StopButton: TButton;
    Label7: TLabel;
    time: TLabel;
    Label6: TLabel;
    ndig: TLabel;
    Pause: TCheckBox;
    Label1: TLabel;
    Label5: TLabel;
    NPixelPower: TSpinEdit;
    offset: TSpinEdit;
    mseqimg: TImage;
    DisplayMSeq: TCheckBox;
    TicSound: TCheckBox;
    Label2: TLabel;
    Label8: TLabel;
    Label9: TLabel;
    Label10: TLabel;
    Label11: TLabel;
    lxpos: TLabel;
    lypos: TLabel;
    llen: TLabel;
    lwid: TLabel;
    lcon: TLabel;
    Label14: TLabel;
    ltime: TLabel;
    CellNum: TSpinEdit;
    Label12: TLabel;
    Label15: TLabel;
    Label16: TLabel;
    Label17: TLabel;
    Label18: TLabel;
    GroupBox1: TGroupBox;
    RecovAll: TImage;
    procedure StopButtonClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormActivate(Sender: TObject);
    procedure TimeSliceSpinChange(Sender: TObject);
  private
    { Private declarations }
    HaltRead : boolean;
    mseq : array of smallint;
    NPixels,patno,morder,mlength,moffset,mask : integer{longword};
    //mousedown,hitstop : boolean;
    mseqbm : Tbitmap;
    white,black : byte;
    wid,hei : integer;
    grayvals : array[0..255] of byte;
    Procedure UpdateStimulus(var stim : StimRec; timestamp : LNG; var x,y,len,wid,con,ori : integer);
    Function irbit2(var iseed: integer{longword}; loib,hiib : integer{longword}): SmallInt;
    Function Color2Grey(col : TColor) : smallint;
    Function Grey2Color (gval : smallint) : TColor;
    Procedure GenerateMSeq;
    procedure DoMseq;
    procedure ShowMseq(index,ir : integer{longword});
  public
    { Public declarations }
    Procedure Analyze(FileName : String);
    Procedure AcceptFiles( var msg : TMessage ); message WM_DROPFILES;
  end;

var
  MSeqForm: TMSeqForm;

implementation

{$R *.DFM}

{---------------------------------------------------------------------------}
procedure TMSeqForm.AcceptFiles( var msg : TMessage );
const
  cnMaxFileNameLen = 255;var  i,  nCount     : integer;
  acFileName : array [0..cnMaxFileNameLen] of char;
begin
  // find out how many files we're accepting
  nCount := DragQueryFile( msg.WParam,$FFFFFFFF,acFileName,cnMaxFileNameLen );
  // query Windows one at a time for the file name
  for i := 0 to nCount-1 do
  begin
    DragQueryFile( msg.WParam, i, acFileName, cnMaxFileNameLen );
    // do your thing with the acFileName
    {MessageBox( Handle, acFileName, '', MB_OK );}
    Analyze(acFileName);
  end;
  // let Windows know that you're done
  DragFinish( msg.WParam );
end;

{---------------------------------------------------------------------------}
Function TMSeqForm.irbit2(var iseed: integer; loib,hiib : integer): SmallInt;
{returns as an integer a random bit, based on the hiib low-significance bits
 in iseed (which is modified for the next call}
begin
  if iseed AND hiib <> 0 then
  begin
    iseed := ((iseed XOR mask) SHL 1) OR 1;
    irbit2 := 1;
  end else
  begin
    iseed := iseed SHL 1;
    irbit2 := 0;
  end;
end;

{---------------------------------------------------------------------------}
procedure TMSeqForm.DoMseq;
var x,t,i,b,hiib,loib : integer{longword};
    xysize : longint;
   s : string;
begin
  hiib := trunc(power(2,POLYPRIMATIVES[morder,POLYPRIMATIVES[morder,0]]-1));
  loib := trunc(power(2,POLYPRIMATIVES[morder,1]-1));
  mask := 0;
  for i := 1 to POLYPRIMATIVES[morder,0]-1 do mask := mask + trunc(power(2,POLYPRIMATIVES[morder,i]-1));

  b := 1;{seed}
  For t := 0 to mlength-1 do
    mseq[t] := irbit2(b,loib,hiib)*2-1;
  xysize := trunc(sqrt(npixels));
  //if npixels is not square rootable then make the display larger
  if sqr(xysize) <> npixels then inc(xysize);
end;

{---------------------------------------------------------------------------}
procedure TMSeqForm.GenerateMSeq;
var xysize : longint;
    p : PByteArray;
    i : integer;
begin
  npixels := round(power(2,npixelpower.value));
  moffset := trunc(power(2,offset.value));
  morder := round(log2(npixels * moffset));
  mlength := trunc(power(2,morder)-1);
  //mlen.caption := '2^'+inttostr(morder)+'-1 ='+inttostr(mlength);
  //time.caption := floattostrf((mlength+1) / (75-1) / 60,ffFixed,6,2) + 'min';
  offset.value := round(log2(mlength/npixels));
  moffset := trunc(power(2,offset.value));
  //per.caption := inttostr(moffset);
  //mseqorder.caption := inttostr(morder);
  //npix.caption := inttostr(npixels);
  mseq := nil;
  Setlength(mseq,mlength);

  DoMseq;
  //make the display the square root of the n of pixels
  xysize := trunc(sqrt(npixels));
  //if npixels is not square rootable then make the display larger
  if sqr(xysize) <> npixels then inc(xysize);
  wid := xysize;
  hei := xysize;

  mseqimg.width := 4*wid;
  mseqimg.height := 4*hei;
  patno := 0;

  mseqbm  := TBitmap.Create;
  mseqbm.width := mseqimg.width;
  mseqbm.height := mseqimg.width;
  mseqbm.PixelFormat := pf8bit;
  mseqimg.picture.assign(mseqbm);
  mseqbm.width := wid;
  mseqbm.height := hei;

  p := mseqbm.ScanLine[0];
  for i := 0 to 255 do
  begin
    mseqbm.canvas.pixels[0,0] := RGB(i,i,i);
    grayvals[i] := p[0];
  end;
  white := grayvals[0];
  black := grayvals[255];
end;

{---------------------------------------------------------------------------}
Function TMSeqForm.Color2Grey(col : TColor) : smallint;
begin
  Color2Grey := round(255-sqrt(-ln(GetRValue(col)/255)*2)*64);
end;

{---------------------------------------------------------------------------}
Function TMSeqForm.Grey2Color (gval : smallint) : TColor;
var gr,gg,gb,g : smallint;
begin
  g  := 255-gval;
  gr := g;
  gg := g-127;
  gb := g-255;

  Grey2Color := RGB(round(255*exp(-sqr(gr/64)/2)),  {Color}
                    round(255*exp(-sqr(gg/64)/2)),
                    round(255*exp(-sqr(gb/64)/2)));
end;

{---------------------------------------------------------------------------}
procedure TMSeqForm.ShowMseq(index,ir : integer);
var  j,b,x,y : integer;
     p : PByteArray;
     c : byte;
begin
  for y := 0 to hei-1 do
  begin
    p := mseqbm.scanline[y];
    For x := 0 to wid-1 do
    begin
      j := y*wid+x;
      b := mseq[(j*moffset+index) mod mlength];
      if ir = 1 then b := -b;
      if b = 1 then p[x] := white else p[x] := black;
    end;
  end;
  stretchblt(mseqimg.canvas.handle,0,0,mseqimg.width,mseqimg.height,mseqbm.canvas.handle,0,0,wid,hei,SRCCOPY);
  mseqimg.refresh;
  p := nil;
end;

{---------------------------------------------------------------------------}
Procedure TMSeqForm.UpdateStimulus(var stim : StimRec; timestamp : LNG; var x,y,len,wid,con,ori : integer);
begin
  //x := round(HalfSize + Stim.Posx * DisplayScale);
  //y := round(HalfSize - Stim.Posy * DisplayScale);
  //len := round((Stim.Len+2047) * DisplayScale);//length of bar in pixels
  //wid := round((Stim.Wid+2047) * DisplayScale);//width of bar in pixels
  con := Stim.Contrast;

  //if Delayed.Checked and (lastx <> NOSTIMULUS) then PlotBar(lastx,lasty,lastlen,lastwid,lastori,lastcon);
  //if plotpositions.checked then PlotPixel(x,y,con);
  //if not Delayed.Checked then exit;
  //PlotBar(x,y,len,wid,ori,con);

  lxpos.caption := FloatToStrF(Stim.Posx/AD2DEG,fffixed,4,2);
  lypos.caption := FloatToStrF(Stim.Posy/AD2DEG,fffixed,4,2);
  llen.caption := FloatToStrF((Stim.Len+2047)/AD2DEG,fffixed,4,2);
  lwid.caption := FloatToStrF((Stim.Wid+2047)/AD2DEG,fffixed,4,2);
  lcon.caption := inttostr(con);
  //lori.caption := inttostr(ori);
  ltime.caption := inttostr(timestamp);
  Application.ProcessMessages;
end;


{---------------------------------------------------------------------------}
Procedure TMSeqForm.Analyze(FileName : String);
const TIMESLICES = 32;//each slice is 1/75th sec, so 75=1 sec, and 35 about 500ms
var
  ReadSurf : TSurfFile;
  c,np,e,pr,nsp,ncp,OrigHeight,OrigWidth,tm : integer;
  m,w,msb,lsb : WORD;
  i,j,x,y,t,index,maxhist,minhist,g,b,modval,nresp : longint;
  col : TColor;
  onresp,offresp : boolean;
  hist : array of array of array of longint;
  ms3d : array of array of array of ShortInt;
  //histindex : array of TPoint;
  //rffield : array of array of longint;
  cenx,ceny,ran,hi : double;
  r,npix,radius,ir,inv,histrange : longint;
  s : string;
  p : pByteArray;
  blen,bwid,con,ori,ms : integer;
  maxh,minh : array of integer;
  range : integer;
  rfbm : TBitmap;

Procedure DisplayRecov;
var x,y,t,xoff,yoff : integer;
    p : PByteArray;
begin
    For t := 0 to TIMESLICES-1 do
    begin
      range := maxh[t]-minh[t];
      For y := 0 to hei-1 do
      begin
        p := rfbm.scanline[y];
        For x := 0 to wid-1 do
        begin
          g := round((hist[x,hei-y-1,t]-minh[t])/range*255);
          col := Grey2Color (g);
          p[x*3]   := GetBValue(col);
          p[x*3+1] := GetGValue(col);
          p[x*3+2] := GetRValue(col);
        end;
      end;
      xoff := (t mod 8)*68;
      yoff := (t div 8)*68;
      RecovAll.Canvas.StretchDraw(rect(xoff,yoff,xoff+64,yoff+64),rfbm);
    end;
    recovall.refresh;
end;

begin
  ReadSurf := TSurfFile.Create;
  if not ReadSurf.ReadEntireSurfFile(FileName,FALSE{do not read the spike waveforms},FALSE{don't average the waveforms}) then //this reads everything
  begin
    ReadSurf.Free;
    ShowMessage('Error Reading '+ FileName);
    Exit;
  end;

  Show;

  MSeqForm.BringToFront;
  StatusBar.SimpleText := 'Filename : '+ Filename;

  GenerateMSeq;

  rfbm  := TBitmap.Create;
  rfbm.width := wid;
  rfbm.height := hei;
  rfbm.PixelFormat := pf24Bit;

  SetLength(hist,wid,hei,TIMESLICES);
  SetLength(ms3d,wid,hei,TIMESLICES);
  SetLength(maxh,TIMESLICES);
  SetLength(minh,TIMESLICES);

  For x := 0 to wid-1 do
    For y := 0 to hei-1 do
      For t := 0 to TIMESLICES-1 do
      begin
        hist[x,y,t] := 0; //this will contain the actual receptive fields at different time slices
        ms3d[x,y,t] := 0; //this will contain the ongoing msequence for forward correlations
      end;
  //showmessage('here6');
  For t := 0 to TIMESLICES-1 do
  begin
    maxh[t] := 1;
    minh[t] := 0;
  end;
  //showmessage('here2');

  mseqval.caption := inttostr(0);
  digval.caption := inttostr(0);
  nspikes.caption := inttostr(0);
  ndig.caption := inttostr(0);

  OrigWidth := MSeqForm.ClientWidth;
  OrigHeight := MSeqForm.ClientHeight;

  //showmessage('here3');

  //tic.open;
  HaltRead := FALSE;
  With ReadSurf do
  begin
    // Now read the data using the event array
    Guage.MinValue := 0;
    Guage.MaxValue := NEvents-1;
    for e := 0 to NEvents-1 do
    begin
      tm := round(Event[e].Time_Stamp * Stimulus.Timediv);
      If tm > Length(Stimulus.Time)-1
        then tm := Length(Stimulus.Time)-1;
      pr := Event[e].probe;
      i := Event[e].Index;
      case Event[e].EventType of
        SURF_PT_REC_UFFTYPE {'N'}: //handle spikes and continuous records
          case Event[e].subtype of
            POLYTRODE  {'S'}:
              begin //spike record found
                time.caption := inttostr(prb[pr].spike[i].time_stamp);
                //prb[p].spike[i].cluster
                nspikes.caption := inttostr(i+1);
                c := prb[pr].spike[i].cluster;

                //Stimulus.Time[tm]
                //if con > 0 then inv := 0 else inv := -1;
                //if DisplayMSeq.Checked then ShowMseq(m,inv);
                For t := 0 to TIMESLICES-1 do
                begin
                  ms := (m-t+TIMESLICES) mod TIMESLICES;
                  For x := 0 to wid-1 do
                    For y := 0 to hei-1 do
                    begin
                      hist[x,y,t] := hist[x,y,t] + ms3d[x,y,ms];
                      if maxh[t] < hist[x,y,t] then maxh[t] := hist[x,y,t];
                      if minh[t] > hist[x,y,t] then minh[t] := hist[x,y,t];
                    end;
                end;
                //if TicSound.Checked then tic.play;
                //if DisplayMSeq.Checked then
                DisplayRecov;
              end;
          end;
        SURF_SV_REC_UFFTYPE {'V'}: //handle single values (including digital signals)
          case Event[e].subtype of
            SURF_DIGITAL {'D'}:
              begin
                //time.caption := inttostr(sval[i].time_stamp);
                w := sval[i].sval;
                //digval.caption := inttostr(w);
                msb := w and $00FF; {get the last byte of this word}
                lsb := w shr 8;      {get the first byte of this word}
                m := msb*256+lsb;
                mseqval.caption := inttostr(m);
                ndig.caption := inttostr(i+1);
                UpdateStimulus(Stimulus.Time[tm],Event[e].Time_Stamp,x,y,blen,bwid,con,ori);
                //StatusBar.Simpletext := inttostr(tm)+','+inttostr(Event[e].Time_Stamp)+inttostr(Stimulus.Time[tm].Contrast);
                if con < 0 then inv := 1 else inv := -1;
                if DisplayMSeq.Checked then ShowMseq(m,inv);

                for y := 0 to hei-1 do
                  For x := 0 to wid-1 do
                  begin
                    j := y*wid+x;
                    b := mseq[(j*moffset+m) mod mlength];
                    if con < 0 then b := -b;
                    ms3d[x,y,m mod TIMESLICES] := b;
                  end;

                //ori.caption := inttostr((msb and $01) shl 8 + lsb); //get the last bit of the msb
                //phase.caption := inttostr(msb shr 1);//get the first 7 bits of the msb
              end;
          end;
        SURF_MSG_REC_UFFTYPE {'M'}://handle surf messages
          begin
            time.caption := inttostr(msg[i].time_stamp);
            StatusBar.SimpleText := Msg[i].Msg;
          end;
      end {case};
      Guage.Progress := e;
      Application.ProcessMessages;
      if HaltRead then break;
      While pause.checked do
      begin
        Application.ProcessMessages;
        if HaltRead then break;
      end;
    end{event loop};
  end;
  //tic.close;

  MSeqForm.ClientWidth := OrigWidth;
  MSeqForm.ClientHeight := OrigHeight;
  Guage.Progress := 0;

  rfbm.Free;
  ReadSurf.CleanUp;
  ReadSurf.Free;
end;


procedure TMSeqForm.StopButtonClick(Sender: TObject);
begin
  HaltRead := TRUE;
end;

procedure TMSeqForm.FormShow(Sender: TObject);
begin
  recovall.canvas.Brush.Color := clLtGray;
  recovall.canvas.FillRect(recovall.canvas.ClipRect);
  mseqimg.canvas.Brush.Color := clLtGray;
  mseqimg.canvas.FillRect(mseqimg.canvas.ClipRect);
end;

procedure TMSeqForm.FormCreate(Sender: TObject);
begin
  DragAcceptFiles( Handle, True );
end;

procedure TMSeqForm.FormActivate(Sender: TObject);
begin
  if ParamCount > 0 then
    Analyze(paramStr(1));
end;

procedure TMSeqForm.TimeSliceSpinChange(Sender: TObject);
begin
  //DisplayRecov;
end;

end.
