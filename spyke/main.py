"""Main spyke window"""

from __future__ import division
from __init__ import __version__

__authors__ = ['Martin Spacek', 'Reza Lotun']

import os
os.environ['ETS_TOOLKIT'] = 'qt4'
from enthought.traits.api import HasTraits, Instance # somehow prevents segfault later in cluster.py

import numpy as np
import pyximport
pyximport.install(setup_args={'include_dirs':[np.get_include()]})

from climbing import climb # .pyx file

from PyQt4 import QtCore, QtGui, uic
SpykeUi, SpykeUiBase = uic.loadUiType('spyke.ui')

import scipy.stats
import os
import sys
import platform
import time
import datetime
import gc
import cPickle
import random

# seems unnecessary: automatically add spyke to path
#spykepath = os.path.split(os.getcwd())[0] # parent dir of cwd
#sys.path.insert(0, spykepath)

import core
from core import toiter, intround, MICRO, ClusterChange
import surf
from sort import Sort, SortWindow, MAINSPLITTERPOS
from plot import SpikePanel, ChartPanel, LFPPanel, CMAP, TRANSWHITEI
from detect import Detector
from extract import Extractor

DEFSPIKETW = -500, 500 # spike window temporal window (us)
DEFCHARTTW = -25000, 25000 # chart window temporal window (us)
DEFLFPTW = -500000, 500000 # lfp window temporal window (us)
SLIDERTRES = 100 # slider temporal resoluion (us), slider is limited to 2**32 ticks

SPIKEWINDOWWIDTHPERCOLUMN = 80
SPIKEWINDOWHEIGHT = 684
CHARTWINDOWSIZE = 900, SPIKEWINDOWHEIGHT
LFPWINDOWSIZE = 250, SPIKEWINDOWHEIGHT
METACITYHACK = 29 # metacity has dockwidget vertical placement issues
PYSHELLSIZE = CHARTWINDOWSIZE[0], CHARTWINDOWSIZE[1]/2
CLUSTERWINDOWSIZE = 535, 535

WINDOWUPDATEORDER = ['Spike', 'LFP', 'Chart'] # chart goes last cuz it's slowest
PYSHELLCFGFNAME = 'pyshell_cfg'

# this will drop us into ipdb on any error, won't work in IPy 0.11?:
QtCore.pyqtRemoveInputHook()
from IPython.Shell import IPShellEmbed
ipshell = IPShellEmbed(banner='Dropping into IPython',
                       exit_msg='Leaving IPython, back to program')
#ipshell() # drops into IPython immediately
#QtCore.pyqtRestoreInputHook()


class SpykeWindow(QtGui.QMainWindow):
    """spyke's main window, uses gui layout generated by QtDesigner"""
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        self.ui = SpykeUi()
        self.ui.setupUi(self) # lay it out
        self.move(0, 0) # top left corner, to make space for data windows

        self.dpos = {} # positions of data windows relative to main spyke window
        self.caption = '' # used for setting title caption
        for d in ('~/data', '/data'):
            try: # use first existing path
                os.chdir(os.path.expanduser(d))
                break
            except: # path doesn't exist
                pass
        self.windows = {} # holds spike, chart, lfp, sort, and pyshell windows
        self.spiketw = DEFSPIKETW # spike window temporal window (us)
        self.charttw = DEFCHARTTW # chart window temporal window (us)
        self.lfptw = DEFLFPTW # lfp window temporal window width (us)
        self.t = None # current time position in recording (us)

        self.hpstream = None
        self.lpstream = None

        self.cchanges = core.Stack() # cluster change stack, for undo/redo
        self.cci = -1 # pointer to cluster change for the next undo (add 1 for next redo)

        for rowi in range(3): # select the first 3 dims in dimlist
            # there really should be an easier way, but .setSelection(QRect, ...) doesn't work?
            #self.ui.dimlist.setCurrentRow(rowi, QtGui.QItemSelectionModel.Select)
            self.ui.dimlist.item(rowi).setSelected(True) # a little nicer
        '''
        # disable most widgets until a .srf or .sort file is opened
        self.EnableSurfWidgets(False)
        self.EnableSortWidgets(False)
        '''
        # TODO: load recent file history
        # for faster testing:

        #srffname = 'ptc15/87 - track 7c spontaneous craziness.srf'
        #self.OpenSurfOrTrackFile(srffname)

        #os.chdir('/data/ptc15/tr7c/87 - track 7c spontaneous craziness')
        #sortfname = '2010-09-09_17.06.14_test.sort'
        #self.OpenSortFile(sortfname)

    @QtCore.pyqtSlot()
    def on_actionNew_triggered(self):
        self.DeleteSort() # don't create a new one until spikes exist

    @QtCore.pyqtSlot()
    def on_actionOpen_triggered(self):
        getOpenFileName = QtGui.QFileDialog.getOpenFileName
        fname = getOpenFileName(self, caption="Open .srf, .track or .sort file",
                                directory=os.getcwd(),
                                filter="Surf, track & sort files (*.srf *.track *.sort);;"
                                       "All files (*.*)")
        fname = str(fname)
        if fname:
            head, tail = os.path.split(fname)
            os.chdir(head) # update cwd
            self.OpenFile(tail)

    @QtCore.pyqtSlot()
    def on_actionSaveSort_triggered(self):
        try:
            self.SaveSortFile(self.sort.sortfname) # save to existing sort fname
        except AttributeError: # sort or sort.sortfname don't exist
            self.on_actionSaveSortAs_triggered()

    @QtCore.pyqtSlot()
    def on_actionSaveSortAs_triggered(self):
        """Save Sort to new .sort file"""
        try:
            defaultFile = self.sort.sortfname
        except AttributeError: # sort hasn't been previously saved
            # generate default fname with hpstream.fname and datetime
            fname = self.hpstream.fname.replace(' ', '_')
            dt = str(datetime.datetime.now()) # get an export timestamp
            dt = dt.split('.')[0] # ditch the us
            dt = dt.replace(' ', '_')
            dt = dt.replace(':', '.')
            defaultFile = fname + '_' + dt
        getSaveFileName = QtGui.QFileDialog.getSaveFileName
        fname = getSaveFileName(self, caption="Save .sort file",
                                directory=os.getcwd(),
                                filter="Sort files (*.sort);;"
                                       "All files (*.*)")
        fname = str(fname)
        if fname:
            base, ext = os.path.splitext(fname)
            if ext != '.sort':
                fname = base + '.sort' # make sure it has .sort extension
            head, tail = os.path.split(fname)
            os.chdir(head) # update cwd
            # make way for new .spike and .wave files
            try: del self.sort.spikefname
            except AttributeError: pass
            try: del self.sort.wavefname
            except AttributeError: pass
            self.SaveSortFile(tail)

    @QtCore.pyqtSlot()
    def on_actionSaveParse_triggered(self):
        self.hpstream.pickle()

    @QtCore.pyqtSlot()
    def on_actionSaveWave_triggered(self):
        """Save waveforms to a .wave file"""
        defaultFile = os.path.splitext(self.sort.sortfname)[0] + '.wave'
        getSaveFileName = QtGui.QFileDialog.getSaveFileName
        fname = getSaveFileName(self, caption="Save .wave file",
                                directory=os.getcwd(),
                                filter="Wave files (*.wave);;"
                                       "All files (*.*)")
        fname = str(fname)
        if fname:
            head, tail = os.path.split(fname)
            os.chdir(head) # update cwd
            self.SaveWaveFile(tail)

    @QtCore.pyqtSlot()
    def on_actionExportSpikes_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export spikes to",
                                    directory=os.getcwd())
        path = str(path)
        if path:
            self.sort.exportspikes(path=path)
            # don't update cwd

    @QtCore.pyqtSlot()
    def on_actionExportDIN_triggered(self):
        srffnameroot = self.sort.get_srffnameroot()
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export DIN to",
                                    directory=os.getcwd())
        path = str(path)
        if path:
            self.sort.exportdin(srffnameroot=srffnameroot, path=path)
            # don't update cwd

    @QtCore.pyqtSlot()
    def on_actionExportTextheader_triggered(self):
        srffnameroot = self.sort.get_srffnameroot()
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export textheader to",
                                    directory=os.getcwd())
        path = str(path)
        if path:
            self.sort.exporttextheader(srffnameroot=srffnameroot, path=path)
            # don't update cwd

    @QtCore.pyqtSlot()
    def on_actionExportAll_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export spikes, DIN and textheader to",
                                    directory=os.getcwd())
        path = str(path)
        if path:
            self.sort.export(path=path)
            # don't update cwd

    @QtCore.pyqtSlot()
    def on_actionExportTsChId_triggered(self):
        srffnameroot = self.sort.get_srffnameroot()
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export tschid to",
                                    directory=os.getcwd())
        path = str(path)
        if path:
            self.sort.exporttschid(srffnameroot=srffnameroot, path=path)
            # don't update cwd

    @QtCore.pyqtSlot()
    def on_actionExportLFP_triggered(self):
        if type(self.hpstream) == core.TrackStream:
            raise RuntimeError("LFP can only be exported from a single .srf file")
        srffnameroot = self.lpstream.srffname.partition('.srf')[0]
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export LFP to",
                                    directory=os.getcwd())
        path = str(path)
        if path:
            self.sort.exportlfp(lpstream=self.lpstream,
                                srffnameroot=srffnameroot, path=path)
            # don't update cwd

    @QtCore.pyqtSlot()
    def on_actionClose_triggered(self):
        # TODO: add confirmation dialog if Sort not saved
        self.CloseSurfOrTrackFile()

    @QtCore.pyqtSlot()
    def on_actionQuit_triggered(self):
        self.on_actionClose_triggered()
        self.close() # call close() before destroy() to avoid segfault
        self.destroy()

    @QtCore.pyqtSlot()
    def on_actionUndo_triggered(self):
        """Undo button click. Undo previous cluster change"""
        try: cc = self.cchanges[self.cci]
        except IndexError: raise RuntimeError('nothing to undo')
        print('undoing: %s' % cc.message)
        self.ApplyClusterChange(cc, direction='back')
        self.cci -= 1 # move pointer one change back on the stack
        print('undo complete')

    @QtCore.pyqtSlot()
    def on_actionRedo_triggered(self):
        """Redo button click. Redo next cluster change"""
        try: cc = self.cchanges[self.cci+1]
        except IndexError: raise RuntimeError('nothing to redo')
        print('redoing: %s' % cc.message)
        self.ApplyClusterChange(cc, direction='forward')
        self.cci += 1 # move pointer one change forward on the stack
        print('redo complete')

    @QtCore.pyqtSlot()
    def on_actionSpikeWindow_triggered(self):
        """Spike window toggle menu/button event"""
        self.ToggleWindow('Spike')

    @QtCore.pyqtSlot()
    def on_actionChartWindow_triggered(self):
        """Chart window toggle menu/button event"""
        self.ToggleWindow('Chart')

    @QtCore.pyqtSlot()
    def on_actionLFPWindow_triggered(self):
        """LFP window toggle menu/button event"""
        self.ToggleWindow('LFP')

    @QtCore.pyqtSlot()
    def on_actionSortWindow_triggered(self):
        """Sort window toggle menu/button event"""
        self.ToggleWindow('Sort')

    @QtCore.pyqtSlot()
    def on_actionClusterWindow_triggered(self):
        """Cluster window toggle menu/button event"""
        self.ToggleWindow('Cluster')

    @QtCore.pyqtSlot()
    def on_actionShell_triggered(self):
        ipshell() # temporary hack

    def OnPyShell(self, evt):
        """PyShell window toggle menu/button event"""
        self.ToggleWindow('PyShell')

    @QtCore.pyqtSlot()
    def on_actionWaveforms_triggered(self):
        """Spike waveforms toggle menu event"""
        self.ToggleWaveforms()

    @QtCore.pyqtSlot()
    def on_actionRasters_triggered(self):
        """Spike rasters toggle menu event"""
        self.ToggleRasters()

    @QtCore.pyqtSlot()
    def on_actionTimeRef_triggered(self):
        """Time reference toggle menu event"""
        self.ToggleRef('TimeRef')

    @QtCore.pyqtSlot()
    def on_actionVoltageRef_triggered(self):
        """Voltage reference toggle menu event"""
        self.ToggleRef('VoltageRef')

    @QtCore.pyqtSlot()
    def on_actionCaret_triggered(self):
        """Caret toggle menu event"""
        self.ToggleRef('Caret')

    def OnSampling(self, evt):
        """Sampling frequency menu choice event"""
        menuitem = self.menubar.FindItemById(evt.GetId())
        sampfreq = int(menuitem.GetLabel().rstrip(' kHz'))
        sampfreq *= 1000 # convert from kHz to Hz
        self.SetSampfreq(sampfreq)

    @QtCore.pyqtSlot()
    def on_actionSampleAndHoldCorrect_triggered(self):
        """Sample & hold menu event"""
        enable = self.ui.actionSampleAndHoldCorrect.isChecked()
        self.SetSHCorrect(enable)
    '''
    def OnMove(self, evt):
        """Move window, and all datawindows as well, like docked windows"""
        for windowtype, window in self.windows.iteritems():
            window.Move(self.GetPosition() + self.dpos[windowtype])
        #evt.Skip() # apparently this isn't needed for a move event,
        # I guess the OS moves the window no matter what you do with the event
    '''
    #def onFilePosLineEdit_textChanged(self, text): # updates immediately
    def on_filePosLineEdit_editingFinished(self): # updates on Enter/loss of focus
        text = str(self.ui.filePosLineEdit.text())
        try:
            t = self.str2t[text]
        except KeyError: # convert to float to allow exp notation shorthand
            t = float(text)
        self.seek(t)

    @QtCore.pyqtSlot()
    def on_actionAboutSpyke_triggered(self):
        text = """
        <h2>spyke %s</h2>
        <p>A tool for neuronal waveform visualization and spike sorting</p>
        <p>Copyright &copy; 2008-2011 Martin Spacek, Reza Lotun<br>
           University of British Columbia</p>
        <p>Python %s, Qt %s, PyQt %s<br>
        %s</p>""" % (__version__, platform.python_version(),
        QtCore.QT_VERSION_STR, QtCore.PYQT_VERSION_STR, platform.platform())
        QtGui.QMessageBox.about(self, "About spyke", text)

    @QtCore.pyqtSlot()
    def on_actionAboutQt_triggered(self):
        QtGui.QMessageBox.aboutQt(self)

    @QtCore.pyqtSlot()
    def on_filePosStartButton_clicked(self):
        self.seek(self.str2t['start'])

    @QtCore.pyqtSlot()
    def on_filePosEndButton_clicked(self):
        self.seek(self.str2t['end'])

    def on_slider_valueChanged(self, slideri):
        self.seek(slideri * SLIDERTRES)

    @QtCore.pyqtSlot()
    def on_detectButton_clicked(self):
        """Detect pane Detect button click"""
        sort = self.CreateNewSort() # create a new Sort
        self.get_detector() # update Sort's current detector with new one from widgets
        if sort.detector.extractparamsondetect:
            self.init_extractor() # init the Extractor
        sort.spikes, sort.wavedata = sort.detector.detect() # struct array of spikes, 3D array
        sort.update_usids()
        sort.sampfreq = sort.stream.sampfreq # lock down sampfreq and shcorrect attribs
        sort.shcorrect = sort.stream.shcorrect
        sort.tres = sort.stream.tres # for convenience

        self.ui.progressBar.setFormat("%d spikes" % sort.nspikes)
        self.EnableSpikeWidgets(True)
        # disable sampling menu, don't want to allow sampfreq or shcorrect changes
        # now that we've had a detection run
        self.ui.menuSampling.setEnabled(False)
        self.ui.actionRasters.setEnabled(True) # enable raster menu, now that spikes exist
        self.ShowRasters() # show spike rasters for open data windows
        sw = self.OpenWindow('Sort') # ensure it's open
        self.EnableSpikeWidgets(True) # now that we (probably) have some spikes

    def init_extractor(self):
        """Initialize Extractor"""
        #XYmethod = self.XY_extract_radio_box.GetStringSelection()
        XYmethod = 'Gaussian fit' # hard code for now, don't really need extract pane
        ext = Extractor(self.sort, XYmethod) # or eventually, self.get_extractor()
        self.sort.extractor = ext
        #self.update_extractor(ext) # eventually, update extractor from multiple Extract pane widgets

    def OnXYExtract(self, evt=None):
        """Extract pane XY Extract button click. Extracts (or re-extracts and
        overwrites) XY parameters from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        #import cProfile
        #cProfile.runctx('self.sort.extractor.extract_all_XY()', globals(), locals())

        self.sort.extractor.extract_all_XY() # adds extracted XY params to sort.spikes
        self.windows['Sort'].uslist.updateAll() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def OnWaveletExtract(self, evt=None):
        """Extract pane wavelet Extract button click. Extracts (or re-extracts and
        overwrites) wavelet coefficients from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        #import cProfile
        #cProfile.runctx('self.sort.extractor.extract_all_XY()', globals(), locals())

        # extract coeffs of selected wavelet type, add coeffs to sort.spikes
        wavelet = self.wavelet_extract_radio_box.GetStringSelection()
        self.sort.extractor.extract_all_wcs(wavelet)
        self.windows['Sort'].uslist.updateAll() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def OnTemporalExtract(self, evt=None):
        """Extract pane temporal Extract button click. Extracts (or re-extracts and
        overwrites) temporal params from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        self.sort.extractor.extract_all_temporal()
        self.windows['Sort'].uslist.updateAll() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def GetClusters(self):
        """Return currently selected clusters"""
        sw = self.windows['Sort']
        cids = [ i.data().toInt()[0] for i in sw.nlist.selectedIndexes() ]
        clusters = [ self.sort.clusters[cid] for cid in cids ]
        return clusters

    def GetCluster(self):
        """Return just one selected cluster"""
        clusters = self.GetClusters()
        nselected = len(clusters)
        if nselected != 1:
            raise RuntimeError("can't figure out which of the %d selected clusters you want"
                               % nselected)
        return clusters[0]

    def GetSpikes(self):
        """Return IDs of currently selected spikes"""
        sw = self.windows['Sort']
        nsrows = sw.nslist.selectedRows()
        srows = sw.uslist.selectedRows()
        sids = []
        try:
            sids.extend(sw.nslist.neuron.sids[nsrows])
        except AttributeError: pass # nslist has neuron=None, with no sids
        sids.extend(self.sort.usids[srows])
        return sids

    def GetSpike(self):
        """Return Id of just one selected spike, from nslist or uslist"""
        sids = self.GetSpikes()
        nselected = len(sids)
        if nselected != 1:
            raise RuntimeError("can't figure out which of the %d selected spike IDs you want"
                               % nselected)
        return sids[0]

    @QtCore.pyqtSlot()
    def on_clusterButton_clicked(self):
        """Cluster pane Cluster button click"""
        s = self.sort
        spikes = s.spikes
        sw = self.OpenWindow('Sort')
        cw = self.OpenWindow('Cluster')

        sw.uslist.clearSelection() # clear uslist selection, since many usids will disappear
        oldclusters = self.GetClusters()
        if oldclusters: # some clusters selected
            clusters = oldclusters
            sids = [] # spikes to run climb() on
            for oldcluster in oldclusters:
                sids.append(oldcluster.neuron.sids)
            sids = np.concatenate(sids) # run climb() on selected spikes
        else: # no clusters selected
            clusters = s.clusters.values() # all clusters
            sids = spikes['id'] # run climb() on all spikes

        # grab dims and data
        items = self.ui.dimlist.selectedItems()
        if len(items) == 0: raise RuntimeError('No cluster dimensions selected')
        dims = [ str(item.text()) for item in items ] # dim names to cluster upon
        plotdims = self.GetClusterPlotDimNames()
        waveclustering = 'wave' in dims or 'peaks' in dims
        if waveclustering: # do maxchan wavefrom clustering
            if len(dims) > 1:
                raise RuntimeError("Can't do high-D clustering of spike maxchan waveforms in tandem with any other spike parameters as dimensions")
            wctype = dims[0] # 'wave' or 'peaks'
            data = self.get_waveclustering_data(sids, wctype=wctype)
            plotdata = s.get_param_matrix(dims=plotdims, scale=True)[sids]
        else: # do spike parameter (non-wavefrom) clustering
            data = s.get_param_matrix(dims=dims, scale=True)[sids]
        data = data.copy() # copy to make it contiguous for climb()

        # grab climb() params and run it
        self.update_sort_from_cluster_pane()
        npoints, ndims = data.shape
        s.sigmasqrtndims = s.sigma * np.sqrt(ndims)
        print('clustering %d points in %d-D space' % (npoints, ndims))
        t0 = time.time()
        results = climb(data, sigma=s.sigmasqrtndims, alpha=s.alpha, rmergex=s.rmergex,
                        rneighx=s.rneighx, nsamples=s.nsamples,
                        calcpointdensities=False, calcscoutdensities=False,
                        minmove=-1.0, maxstill=s.maxstill, maxnnomerges=1000,
                        minpoints=s.minpoints)
        cids, scoutpositions, densities, scoutdensities, sampleis = results
        nids = list(np.unique(cids))
        try: nids.remove(-1)
        except ValueError: pass
        print('climb took %.3f sec' % (time.time()-t0))

        # save some undo/redo stuff
        message = 'climb clusters %r' % [ c.id for c in clusters ]
        cc = ClusterChange(sids, spikes, message)
        cc.save_old(clusters)

        if oldclusters: # some clusters selected
            self.SelectClusters(oldclusters, on=False) # deselect original clusters
            cw.f.scene.disable_render = True # for speed
            for oldcluster in oldclusters:
                self.DelCluster(oldcluster, update=False) # del original clusters
            self.DeColourPoints(sids) # decolour all points belonging to old clusters
        else: # no clusters selected, delete all existing clusters (if any)
            for cluster in s.clusters.values():
                self.DelCluster(cluster, update=False)
            try: cw.glyph
            except AttributeError: self.on_plotButton_clicked()
            self.DeColourAllPoints()
            s.sampleis = sampleis

        # apply the clusters to the cluster plot
        newclusters = []
        t0 = time.time()
        for nid, pos in zip(nids, scoutpositions): # nids are sorted
            ii, = np.where(cids == nid)
            nsids = sids[ii] # sids belonging to this nid
            cluster = self.CreateCluster(update=False)
            newclusters.append(cluster)
            neuron = cluster.neuron
            sw.MoveSpikes2Neuron(nsids, neuron, update=False)
            if len(nsids) == 0:
                raise RuntimeError('WARNING: neuron %d has no spikes for some reason' % neuron.id)
            if waveclustering: # set pos and scale in plotdims using mean and std of points
                for plotdimi, plotdim in enumerate(plotdims):
                    points = plotdata[ii, plotdimi]
                    cluster.pos[plotdim] = points.mean()
                    cluster.scale[plotdim] = points.std() or cluster.scale[plotdim]
            else: # set pos and scale in cluster dims using cluster pos and std of points
                for dimi, dim in enumerate(dims):
                    cluster.pos[dim] = pos[dimi]
                    cluster.scale[dim] = data[ii, dimi].std() or cluster.scale[dim]
            cluster.update_ellipsoid(params=['pos', 'scale'], dims=plotdims)

        # save more undo/redo stuff
        cc.save_new(newclusters)
        self.AddClusterChangeToStack(cc)

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(newclusters)
        #print('applying clusters to plot took %.3f sec' % (time.time()-t0))
        if oldclusters: # select newly created cluster(s)
            self.SelectClusters(newclusters)
        cc.message += ' into %r' % [c.id for c in newclusters]
        print(cc.message)

    def get_waveclustering_data(self, sids, wctype='wave'):
        s = self.sort
        spikes = s.spikes

        # find which chans are common to all selected spikes
        chanss = spikes['chans'][sids]
        nchanss = spikes['nchans'][sids]
        chanslist = [ chans[:nchans] for chans, nchans in zip(chanss, nchanss) ] # list of arrays
        clusterable_chans = core.intersect1d(chanslist) # find intersection

        # decide which is the definitive maxchan for the selected spikes
        maxchans = spikes['chan'][sids]
        # cluster by default on most common maxchan
        maxchan = int(scipy.stats.mode(maxchans)[0][0])
        chans = [maxchan]

        # pop up dialog asking for chans to cluster on
        string = wx.GetTextFromUser('Cluster by %s on which channel(s)?\nChoose from: %r'
                                    % (wctype, list(clusterable_chans)),
                                    'Waveform (%s) clustering' % wctype, str(chans))
        if string == '':
            raise RuntimeError('cancelled') # cancel was pressed
        if string == '[]':
            chans = clusterable_chans
        else:
            chans = np.asarray(eval(string))
            chans.sort()
        for chan in chans:
            if chan not in clusterable_chans:
                raise RuntimeError("chan %d not common to all spikes, pick from %r"
                                   % (chan, list(clusterable_chans)))

        # copy selected chans as string to clipboard for easy user re-pasting next time
        chans_string = wx.TextDataObject(str(list(chans)))
        if wx.TheClipboard.Open():
            wx.TheClipboard.SetData(chans_string)
            wx.TheClipboard.Close()

        print('clustering upon chans = %r' % list(chans))
        nspikes = len(sids)
        nchans = len(chans)
        nt = s.wavedata.shape[2]
        # collect data from 'chans' from all spikes:
        data = np.zeros((nspikes, nchans, nt), dtype=np.float32)
        for sii, sid in enumerate(sids):
            spikechans = chanslist[sii]
            spikechanis = np.searchsorted(spikechans, chans)
            data[sii] = s.wavedata[sid, spikechanis]

        # find mean waveform of selected spikes
        template = data.mean(axis=0)

        if wctype == 'wave':
            # use all data from dt/2 before 1st peak to dt/2 after 2nd peak
            chani, = np.where(chans == maxchan)
            if not chani: # maxchan wasn't included in chans,  find chan with biggest value
                chani = np.unravel_index(template.argmax(), template.shape)[0]
            peaktis = np.asarray([template[chani].argmin(), template[chani].argmax()])
            peaktis.sort() # keep in temporal order
            dt2 = intround((peaktis[1] - peaktis[0]) / 2.0)
            wavetis = np.arange(max(peaktis[0]-dt2, 0), min(peaktis[1]+dt2, nt-1))
            wavetis = list(wavetis[::2]) # take every other point
            # ensure peak points remain in wavetis
            if peaktis[0] not in wavetis:
                wavetis.append(peaktis[0])
            if peaktis[1] not in wavetis:
                wavetis.append(peaktis[1])
            wavetis = np.asarray(wavetis)
            wavetis.sort()
            print('peaktis = %r' % peaktis)
            print('wavetis = %r' % wavetis)
            # consider only data at wavetis
            data = data[:, :, wavetis].copy()
            #slicetis = np.asarray([max(peaktis[0]-dt2, 0), peaktis[1]+dt2+1])
            #print('slicetis = %r' % slicetis)
            # consider only data between slicetis, copy to make it contiguous
            #data = data[:, :, slicetis[0]:slicetis[1]].copy()
        elif wctype == 'peaks':
            # use only data at peaks of template, and before and after each peak
            # useful for faster clustering
            peaktis = np.zeros((nchans, 6), dtype=int)
            for chani in range(nchans):
                t1, t4 = np.sort([template[chani].argmin(), template[chani].argmax()])
                dt3 = intround((t4 - t1)/3.0) # 1/3 the distance between peaks
                t0 = max(t1-dt3, 0)
                t2 = min(t1+dt3, nt-1)
                t3 = max(t4-dt3, 0)
                t5 = min(t4+dt3, nt-1)
                peaktis[chani] = t0, t1, t2, t3, t4, t5
            print('peaktis =')
            print(peaktis)
            # grab each spike's data at these peak times, using fancy indexing
            # see core.rowtake() or util.rowtake_cy() for indexing explanation
            data = data[:, np.arange(nchans)[:, None], peaktis] # shape = nspikes, nchans, 2
        else:
            raise RuntimeError('unknown wctype %r' % wctype)

        data.shape = nspikes, -1 # reshape to 2D, ie flatten across chans

        # normalize by the std of the dim with the biggest std - this allows use of reasonable
        # value of sigma (~0.15), similar to param clustering, and independent of what the
        # amplifier gain was during recording
        norm = data.std(axis=0).max()
        data /= norm
        print('normalized waveform data by %f' % norm)
        return data

    def SelectClusters(self, clusters, on=True):
        """Select/deselect clusters"""
        clusters = toiter(clusters)
        all_nids = sorted(self.sort.neurons)
        sel_nids = [ cluster.id for cluster in clusters ]
        rows = np.searchsorted(all_nids, sel_nids)
        nlist = self.windows['Sort'].nlist
        nlist.selectRows(rows, on)
        print('set rows %r to %r' % (rows, on))

    def CreateCluster(self, update=True, id=None):
        """Create a new cluster, add it to the GUI, return it"""
        neuron = self.sort.create_neuron(id)
        sw = self.windows['Sort']
        if update:
            sw.nlist.updateAll()
        from cluster import Cluster # can't delay this any longer
        cluster = Cluster(neuron)
        self.sort.clusters[cluster.id] = cluster
        neuron.cluster = cluster
        cw = self.OpenWindow('Cluster')
        try: cw.glyph # glyph already plotted?
        except AttributeError: self.on_plotButton_clicked() # create glyph on first open
        self.AddCluster2GUI(cluster, update=update)
        return cluster

    def AddCluster2GUI(self, cluster, update=True):
        """Add cluster to GUI"""
        sw = self.windows['Sort']
        cw = self.OpenWindow('Cluster')
        dims = self.GetClusterPlotDimNames()
        cw.add_ellipsoid(cluster, dims, update=update)
        if update:
            raise RuntimeError('this code block should maybe be removed?')
            sw.nlist.updateAll()
            sw.nlist.DeSelectAll()
            sw.nlist.Select(len(self.sort.clusters) - 1) # select newly created item

    def DelCluster(self, cluster, update=True):
        """Delete a cluster from the GUI, and delete the cluster
        and its neuron from the Sort. Think you need to call
        mlab_source.update() afterwards"""
        sw = self.windows['Sort']
        cw = self.windows['Cluster']
        cw.f.scene.disable_render = True # for speed
        cluster.ellipsoid.remove() # from pipeline
        cluster.ellipsoid = None
        if update:
            self.DeColourPoints(cluster.neuron.sids) # decolour before neuron loses its sids
        sw.RemoveNeuron(cluster.neuron, update=update)
        if update:
            sw.nlist.updateAll()
            cw.f.scene.disable_render = False

    def OnRenumberClusters(self):
        """Renumber clusters consecutively from 0, ordered by y position, on "#" button click.
        Sorting by y position makes user inspection of clusters more orderly, makes the presence
        of duplicate clusters more obvious, and allows for maximal spatial separation between
        clusters of the same colour, reducing colour conflicts"""
        s = self.sort
        spikes = s.spikes

        # deselect current selections
        selclusters = self.GetClusters()
        oldselcids = [ cluster.id for cluster in selclusters ]
        self.SelectClusters(selclusters, on=False)

        # get lists of unique old cids and new cids
        olducids = sorted(s.clusters) # make sure they're in order
        # this is a bit confusing: find indices that would sort olducids by y pos, but then
        # what you really want is to find the y pos *rank* of each uoldcid, so you need to
        # take argsort again:
        newucids = np.asarray([ s.clusters[cid].pos['y0'] for cid in olducids ]).argsort().argsort()
        cw = self.windows['Cluster']
        cw.f.scene.disable_render = True # turn rendering off for speed
        oldclusters = s.clusters.copy()
        oldneurons = s.neurons.copy()
        for oldcid, newcid in zip(olducids, newucids):
            if oldcid == newcid:
                continue # no need to waste time removing and recreating this cluster
            # change all occurences of oldcid to newcid
            cluster = oldclusters[oldcid]
            cluster.id = newcid # this indirectly updates neuron.id
            # update cluster and neuron dicts
            s.clusters[newcid] = cluster
            s.neurons[newcid] = cluster.neuron
            sids = cluster.neuron.sids
            spikes['nid'][sids] = newcid
            # TODO: can't figure out how to change scalar value of existing ellipsoid (for
            # mouse hover tooltip), just delete it and make a new one. This is very innefficient
            cluster.ellipsoid.remove()
            dims = self.GetClusterPlotDimNames()
            cw.add_ellipsoid(cluster, dims=dims, update=False) # this overwrites cluster.ellipsoid
        # remove any orphaned cluster ids
        for oldcid in olducids:
            if oldcid not in newucids:
                del s.clusters[oldcid]
                del s.neurons[oldcid]

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(s.clusters.values())
        # reselect the previously selected (but now renumbered) clusters - helps user keep track
        newselcids = newucids[np.searchsorted(olducids, oldselcids)]
        self.SelectClusters([s.clusters[cid] for cid in newselcids])
        # all cluster changes in stack are no longer applicable, reset cchanges
        del self.cchanges[:]
        self.cci = -1
        print('renumbering complete')
    '''
    def OnCListSelect(self, evt=None):
        """Cluster list box item selection. Update cluster param widgets
        given current dims"""
        # TODO: this method isn't triggered when clicking in empty space to deselect all items
        #print('in OnCListSelect()')
        selectedRows = self.clist.selectedRows()
        if len(selectedRows) == 1:
            cluster = self.GetCluster()
            self.EnablePosOriScaleWidgets(True)
            self.UpdateParamWidgets(cluster)
        else:
            self.EnablePosOriScaleWidgets(False)
        # mirror selection changes to nlist
        sw = self.windows['Sort']
        all_nids = sorted(self.sort.neurons)
        nids = set(np.asarray(all_nids)[selectedRows])
        remove_nids = list(sw.nlist.lastSelectedIDs.difference(nids))
        add_nids = list(nids.difference(sw.nlist.lastSelectedIDs))
        deselect_rows = np.searchsorted(all_nids, remove_nids)
        select_rows = np.searchsorted(all_nids, add_nids)
        nlist = sw.nlist
        [ nlist.Select(row, on=False) for row in deselect_rows ]
        [ nlist.Select(row, on=True) for row in select_rows ]
    '''
    def OnDim(self, evt=None):
        """Update cluster widgets based on current cluster and dims,
        and replot the data in the (potentially) new projection, while
        maintaining the colour of each point"""
        cw = self.windows['Cluster']
        scalars = cw.glyph.mlab_source.scalars # save scalars
        self.on_plotButton_clicked() # replot
        cw.glyph.mlab_source.scalars = scalars # restore scalars
        cw.glyph.mlab_source.update() # make scalar changes visible
        try:
            cluster = self.GetCluster()
            self.UpdateParamWidgets(cluster)
        except RuntimeError:
            # no cluster currently selected, like when changing dim before
            # any clusters have been created
            pass

    def OnFocusCurrentCluster(self):
        """Focus button press in cluster_pane. Move focus to location
        of currently selected (single) cluster"""
        cluster = self.GetCluster()
        cw = self.windows['Cluster']
        dims = self.GetClusterPlotDimNames()
        fp = [ cluster.pos[dim] for dim in dims ]
        cw.f.scene.camera.focal_point = fp
        cw.f.render() # update the scene, see SpykeMayaviScene.OnKeyDown()
        #cw.Refresh() # this also seems to work: repaint the window

    def OnFocusCurrentSpike(self):
        """Focus button press in sort_pane. Move focus to location
        of currently selected (single) spike"""
        sid = self.GetSpike()
        cw = self.windows['Cluster']
        dims = self.GetClusterPlotDimNames()
        fp = self.sort.get_param_matrix(dims=dims)[sid]
        cw.f.scene.camera.focal_point = fp
        cw.f.render() # update the scene, see SpykeMayaviScene.OnKeyDown()
        #cw.Refresh() # this also seems to work: repaint the window

    def MoveCurrentCluster2Focus(self):
        """Sets the position of the currently selected cluster to
        the point in 3D where the scene's camera is currently focused"""
        cluster = self.GetCluster()
        cw = self.windows['Cluster']
        fp = cw.f.scene.camera.focal_point
        dims = self.GetClusterPlotDimNames()
        for dim, val in zip(dims, fp):
            cluster.pos[dim] = val
        cluster.update_ellipsoid('pos', dims=dims)
        self.UpdateParamWidgets(cluster)

    @QtCore.pyqtSlot()
    def on_plotButton_clicked(self):
        """Cluster pane plot button click"""
        dims = self.GetClusterPlotDimNames()
        cw = self.OpenWindow('Cluster') # in case it isn't already open
        X = self.sort.get_param_matrix(dims=dims)
        #X = self.sort.get_component_matrix(dims=dims, weighting='pca')
        if len(X) == 0:
            return # nothing to plot
        cw.glyph = cw.plot(X)
        # update all ellipsoids
        cw.f.scene.disable_render = True # turn rendering off for speed
        clusters = self.sort.clusters.values()
        for cluster in clusters:
            cluster.update_ellipsoid(dims=dims)
        #self.UpdateClustersGUI()

    def OnCutCluster(self, evt=None):
        """Cut (cluster) button press in cluster_pane. Don't need the evt"""
        cluster = self.GetCluster()
        self.CutClusters(cluster)

    def OnCutAllClusters(self, evt=None):
        """Cut all (cluster) button press in cluster_pane. Don't need the evt"""
        self.CutClusters(self.sort.clusters.values())

    def CutClusters(self, clusters):
        """Apply the cluster params to the spikes. Cut the spikes and
        update the plot"""
        sw = self.windows['Sort']
        for cluster in toiter(clusters):
            neuron = cluster.neuron
            # reset scalar values for cluster's existing points
            # TODO: decolour only those points that are being removed
            self.DeColourPoints(neuron.sids)
            # remove any existing spikes from neuron and restore them to spike listctrl:
            sw.MoveSpikes2List(neuron, neuron.sids)
            sids = self.sort.cut_cluster(cluster)
            sw.MoveSpikes2Neuron(sids, neuron)
        # TODO: colour only those points that have been added
        self.ColourPoints(clusters)

    def UpdateClustersGUI(self):
        """Update lots of stuff after modifying clusters,
        here as a separate method for speed, only call when really needed"""
        s = self.sort
        sw = self.windows['Sort']
        cw = self.windows['Cluster']
        cw.f.scene.disable_render = False # turn rendering back on
        sw.nlist.updateAll()
        s.update_usids()
        sw.uslist.updateAll()

    def ColourPoints(self, clusters):
        """Colour the points that fall within each cluster (as specified
        by cluster.neuron.sids) the same colour as the cluster itself"""
        clusters = toiter(clusters)
        cw = self.windows['Cluster']
        for cluster in clusters:
            neuron = cluster.neuron
            cw.glyph.mlab_source.scalars[neuron.sids] = neuron.id % len(CMAP)
        t0 = time.time()
        cw.glyph.mlab_source.update() # make the trait update, only call it once to save time
        #print('glyph.mlab_source.update() call took %.3f sec' % ((time.time()-t0)))

    def DeColourPoints(self, sids):
        """Restore spike point colour in cluster plot at spike indices to unclustered WHITE.
        Don't forget to call cw.glyph.mlab_source.update() after calling this"""
        cw = self.windows['Cluster']
        cw.glyph.mlab_source.scalars[sids] = np.tile(TRANSWHITEI, len(sids))

    def DeColourAllPoints(self):
        """Restore all spike points in cluster plot to unclustered WHITE.
        Don't forget to call cw.glyph.mlab_source.update() after calling this"""
        cw = self.windows['Cluster']
        cw.glyph.mlab_source.scalars = np.tile(TRANSWHITEI, self.sort.nspikes)

    def GetClusterPlotDimNames(self):
        """Return 3-tuple of strings of cluster dimension names, in (x, y, z) order"""
        x = str(self.ui.xDimComboBox.currentText())
        y = str(self.ui.yDimComboBox.currentText())
        z = str(self.ui.zDimComboBox.currentText())
        return x, y, z

    def UpdateParamWidgets(self, cluster):
        """Update 3x3 grid of cluster param widgets from values in cluster"""
        x, y, z = self.GetClusterPlotDimNames() # tuple of dim names, in (x, y, z) order
        self.xpos.SetValue(str(cluster.pos[x]))
        self.ypos.SetValue(str(cluster.pos[y]))
        self.zpos.SetValue(str(cluster.pos[z]))
        if (y, z) in cluster.ori[x]: self.xori.SetValue(str(cluster.ori[x][(y, z)]))
        elif (z, y) in cluster.ori[x]: self.xori.SetValue(str(-cluster.ori[x][(z, y)]))
        else: self.xori.SetValue(str(0))
        if (z, x) in cluster.ori[y]: self.yori.SetValue(str(cluster.ori[y][(z, x)]))
        elif (x, z) in cluster.ori[y]: self.yori.SetValue(str(-cluster.ori[y][(x, z)]))
        else: self.yori.SetValue(str(0))
        if (x, y) in cluster.ori[z]: self.zori.SetValue(str(cluster.ori[z][(x, y)]))
        elif (y, x) in cluster.ori[z]: self.zori.SetValue(str(-cluster.ori[z][(y, x)]))
        else: self.zori.SetValue(str(0))
        self.xscale.SetValue(str(cluster.scale[x]))
        self.yscale.SetValue(str(cluster.scale[y]))
        self.zscale.SetValue(str(cluster.scale[z]))
    '''
    """Update parameters for currently selected cluster, and associated ellipsoid"""
    def OnXPos(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.pos[x] = val
        cluster.update_ellipsoid('pos', dims=(x, y, z))

    def OnYPos(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.pos[y] = val
        cluster.update_ellipsoid('pos', dims=(x, y, z))

    def OnZPos(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.pos[z] = val
        cluster.update_ellipsoid('pos', dims=(x, y, z))

    def OnXOri(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        if (z, y) in cluster.ori[x]: # reversed axes already used as a key
            cluster.ori[x][(z, y)] = -val # reverse the ori
        else:
            cluster.ori[x][(y, z)] = val # add or overwrite non-reversed axes entry
        cluster.update_ellipsoid('ori', dims=(x, y, z))

    def OnYOri(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        if (x, z) in cluster.ori[y]:
            cluster.ori[y][(x, z)] = -val
        else:
            cluster.ori[y][(z, x)] = val
        cluster.update_ellipsoid('ori', dims=(x, y, z))

    def OnZOri(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        if (y, x) in cluster.ori[z]:
            cluster.ori[z][(y, x)] = -val
        else:
            cluster.ori[z][(x, y)] = val
        cluster.update_ellipsoid('ori', dims=(x, y, z))

    def OnXScale(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.scale[x] = val
        cluster.update_ellipsoid('scale', dims=(x, y, z))

    def OnYScale(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.scale[y] = val
        cluster.update_ellipsoid('scale', dims=(x, y, z))

    def OnZScale(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.scale[z] = val
        cluster.update_ellipsoid('scale', dims=(x, y, z))
    '''
    def OnKeyDown(self, evt):
        """Handle key presses
        TODO: might be able to clean this up by having a handler for wx.EVT_NAVIGATION_KEY
        """
        key = evt.GetKeyCode()
        #print 'key: %r' % key
        in_widget = evt.GetEventObject().ClassName in ['wxComboBox', 'wxSpinCtrl', 'wxSlider']
        in_file_pos_combo_box = evt.GetEventObject() == self.file_pos_combo_box
        if not evt.ControlDown():
            if key == wx.WXK_LEFT and not in_widget or key == wx.WXK_DOWN and in_file_pos_combo_box:
                    self.seek(self.t - self.hpstream.tres)
            elif key == wx.WXK_RIGHT and not in_widget or key == wx.WXK_UP and in_file_pos_combo_box:
                    self.seek(self.t + self.hpstream.tres)
            elif key == wx.WXK_PRIOR: # PGUP
                self.seek(self.t - (self.spiketw[1]-self.spiketw[0])) # go back 1 spike window width
            elif key == wx.WXK_NEXT: # PGDN
                self.seek(self.t + (self.spiketw[1]-self.spiketw[0])) # go forward 1 spike window width
        else: # CTRL is down
            if key == wx.WXK_PRIOR: # PGUP
                self.seek(self.t - (self.charttw[1]-self.charttw[0])) # go back 1 chart window width
            elif key == wx.WXK_NEXT: # PGDN
                self.seek(self.t + (self.charttw[1]-self.charttw[0])) # go forward 1 chart window width
        # when key event comes from file_pos_combo_box, reserve down/up for seeking through file
        if in_widget and not in_file_pos_combo_box or in_file_pos_combo_box and key not in [wx.WXK_DOWN, wx.WXK_UP]:
            evt.Skip() # pass event on to OS to handle cursor movement

    def AddClusterChangeToStack(self, cc):
        """Adds cc to the cluster change stack, removing any potential redo changes"""
        self.cci += 1
        del self.cchanges[self.cci::] # remove any existing redo cluster changes
        self.cchanges.append(cc) # add to stack
        # TODO: check if stack has gotten too long, if so, remove some from the start
        # and update self.cci appropriately

    def ApplyClusterChange(self, cc, direction):
        """Apply cluster change described in cc, in either the forward or backward direction,
        to the current set of clusters"""
        s = self.sort
        spikes = s.spikes
        sw = self.OpenWindow('Sort')
        cw = self.OpenWindow('Cluster')
        sids = cc.sids

        # reverse meaning of 'new' and 'old' if direction == 'forward', ie if redoing
        if direction == 'back':
            #newnids = cc.newnids # not needed
            oldnids = cc.oldnids
            newunids = cc.newunids
            oldunids = cc.oldunids
            positions = cc.oldpositions
            scales = cc.oldscales
        else: # direction == 'forward'
            #newnids = cc.oldnids # not needed
            oldnids = cc.newnids
            newunids = cc.oldunids
            oldunids = cc.newunids
            positions = cc.newpositions
            scales = cc.newscales

        # delete newly added clusters
        newclusters = [ s.clusters[nid] for nid in newunids ]
        self.SelectClusters(newclusters, on=False) # deselect new clusters
        # temporarily deselect any bystander clusters to get around fact that
        # selections are row-based in Qt, not value-based, which means selection
        # changes happen without a selectionChanged event when the rowcount changes
        bystanders = self.GetClusters()
        self.SelectClusters(bystanders, on=False)
        cw.f.scene.disable_render = True # for speed
        for newcluster in newclusters:
            self.DelCluster(newcluster, update=False) # del new clusters
        self.DeColourPoints(sids) # decolour all points belonging to new clusters

        # restore relevant spike fields
        spikes['nid'][sids] = oldnids

        # restore the old clusters
        oldclusters = []
        plotdims = self.GetClusterPlotDimNames()
        t0 = time.time()
        # NOTE: oldunids are not necessarily sorted
        for nid, pos, scale in zip(oldunids, positions, scales):
            nsids = sids[oldnids == nid] # sids belonging to this nid
            cluster = self.CreateCluster(update=False, id=nid)
            oldclusters.append(cluster)
            neuron = cluster.neuron
            sw.MoveSpikes2Neuron(nsids, neuron, update=False)
            cluster.pos = pos
            cluster.scale = scale
            cluster.update_ellipsoid(params=['pos', 'scale'], dims=plotdims)

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(oldclusters)
        #print('applying clusters to plot took %.3f sec' % (time.time()-t0))
        # select newly recreated oldclusters
        self.SelectClusters(oldclusters)
        # restore bystander selections
        self.SelectClusters(bystanders)
        print('oldclusters: %r' % [c.id for c in oldclusters])
        print('newclusters: %r' % [c.id for c in newclusters])
        print('bystanders: %r' % [c.id for c in bystanders])


    def OpenFile(self, fname):
        """Open a .srf, .sort or .wave file"""
        ext = os.path.splitext(fname)[1]
        if ext in ['.srf', '.track']:
            self.OpenSurfOrTrackFile(fname)
        elif ext == '.sort':
            self.OpenSortFile(fname)
        else:
            critical = QtGui.QMessageBox.critical
            critical(self, "Error", "%s is not a .srf, .track or .sort file" % fname)

    def OpenSurfOrTrackFile(self, fname):
        """Open a .srf or .track file, and update display accordingly"""
        if self.hpstream != None:
            self.CloseSurfOrTrackFile() # in case a .srf or .track file and windows are already open
        ext = os.path.splitext(fname)[1]
        if ext == '.srf':
            srff = surf.File(fname)
            srff.parse() # TODO: parsing progress dialog
            self.hpstream = srff.hpstream # highpass record (spike) stream
            self.lpstream = srff.lpstream # lowpassmultichan record (LFP) stream
        else: # ext == '.track'
            srffs = []
            with open(fname, 'r') as trackfile:
                for line in trackfile: # one srf filename per line
                    if line.startswith('#'): # it's a comment line
                        continue # skip it
                    srffname = line.rstrip('\n')
                    srff = surf.File(srffname)
                    srff.parse()
                    srffs.append(srff) # build up list of open and parsed surf File objects
            self.hpstream = core.TrackStream(srffs, fname,  kind='highpass')
            self.lpstream = core.TrackStream(srffs, fname, kind='lowpass')

        self.caption = fname # update
        self.setWindowTitle(self.caption) # update the caption
        self.ui.__dict__['action%dkHz' % (self.hpstream.sampfreq / 1000)].setChecked(True)
        self.ui.actionSampleAndHoldCorrect.setChecked(self.hpstream.shcorrect)

        self.set_chans_enabled(self.hpstream.chans, enable=True)
        tww = self.spiketw[1]-self.spiketw[0] # window width
        self.t = intround(self.hpstream.t0 + tww/2) # set current timepoint (us)

        self.SPIKEWINDOWWIDTH = self.hpstream.probe.ncols * SPIKEWINDOWWIDTHPERCOLUMN
        self.OpenWindow('Spike')

        self.str2t = {'start': self.hpstream.t0,
                      'now': self.t, # FIXME: this won't track self.t automatically
                      'end': self.hpstream.t1}
        self.range = (self.hpstream.t0, self.hpstream.t1) # us
        self.ui.filePosLineEdit.setText(str(self.t))
        self.ui.filePosStartButton.setText(str(self.hpstream.t0))
        self.ui.filePosEndButton.setText(str(self.hpstream.t1))
        # set all slider values in multiples of SLIDERTRES
        self.ui.slider.setRange(self.range[0] // SLIDERTRES,
                             self.range[1] // SLIDERTRES) # no need to round
        self.ui.slider.setValue(self.t // SLIDERTRES)
        self.ui.slider.setSingleStep(1)
        self.ui.slider.setPageStep((self.spiketw[1]-self.spiketw[0]) // SLIDERTRES)

        self.EnableSurfWidgets(True)

    def CreateNewSort(self):
        """Create a new Sort, bind it to self, and return it"""
        self.DeleteSort()
        self.sort = Sort(detector=None, # detector is assigned in on_detectButton_clicked
                         stream=self.hpstream)
        self.EnableSortWidgets(True)
        return self.sort

    def DeleteSort(self):
        """Delete any existing Sort"""
        try:
            # TODO: if Save button is enabled, check if Sort is saved,
            # if not, prompt to save
            print('deleting existing Sort and entries in list controls')
            clusters = self.sort.clusters # need it below
            #self.sort.spikes.resize(0, recheck=False) # doesn't work, doesn't own memory
            del self.sort
        except AttributeError:
            clusters = {}
        if 'Sort' in self.windows:
            sw = self.windows['Sort']
            sw.nlist.reset()
            sw.nslist.reset()
            sw.uslist.reset()
            sw.panel.removeAllItems()
        if 'Cluster' in self.windows:
            cw = self.windows['Cluster']
            cw.f.scene.disable_render = True # for speed
            for cluster in clusters.values():
                cluster.ellipsoid.remove() # from pipeline
                # no need to del cluster.ellipsoid, since all clusters are deleted when sort is deleted
            try:
                cw.glyph.remove() # from pipeline
                del cw.glyph # cluster window hangs around, so del its glyph
            except AttributeError: pass
            cw.f.scene.disable_render = False
        del self.cchanges[:]
        self.cci = -1
        self.ui.progressBar.setFormat('0 spikes')
        # make sure self.sort and especially self.sort.spikes is really gone
        # TODO: check if this is necessary once everything works with new streamlined
        # (no objects) spikes struct array
        gc.collect()

    def get_chans_enabled(self):
        return np.asarray([ chan for (chan, enable) in self._chans_enabled.iteritems() if enable ], dtype=np.uint8)

    def set_chans_enabled(self, chans, enable=None):
        """Updates which chans are enabled in ._chans_enabled dict and in the
        plot panels, and in the highpass stream. If enable is set, chans specifies
        which chans should have their enable flag overwritten. Otherwise,
        chans specifies all the chans we want enabled.
        The code for the 2nd case is quite elaborate, such that the visibility
        state of any given plot in all plotpanels isn't needlessly toggled,
        which slows things down and causes flicker, I think"""

        # inits and checks
        try:
            allchans = self.hpstream.chans # not sure if this needs to be copy()'d or not
        except AttributeError: # no hpstream yet
            allchans = []
        if chans == None: # None means all chans
            chans = allchans
        chans = toiter(chans) # need not be contiguous
        try:
            self._chans_enabled
        except AttributeError:
            self._chans_enabled = {} #dict(zip(allchans, [ True for chan in allchans ]))

        # overwrite enable flag of chans...
        if enable != None:
            for chan in chans:
                self._chans_enabled[chan] = enable
            for windowtype in WINDOWUPDATEORDER:
                try:
                    self.windows[windowtype].panel.enable_chans(chans, enable=enable)
                except KeyError: # windowtype hasn't been opened yet
                    pass
        # ...or, leave only chans enabled
        else:
            enabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==True ]
            disabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==False ]
            notchans = set(allchans).difference(chans) # chans we don't want enabled
            # find the difference between currently enabled chans and the chans we want enabled
            chans2disable = set(enabledchans).difference(chans)
            # find the difference between currently disabled chans and the chans we want disabled
            chans2enable = set(disabledchans).difference(notchans)
            for chan in chans2enable:
                self._chans_enabled[chan] = True
            for chan in chans2disable:
                self._chans_enabled[chan] = False
            # now change the actual plots in the plotpanels
            for windowtype in WINDOWUPDATEORDER:
                try:
                    self.windows[windowtype].panel.enable_chans(chans2enable, enable=True)
                    self.windows[windowtype].panel.enable_chans(chans2disable, enable=False)
                except KeyError: # windowtype hasn't been opened yet
                    pass

        # update stream, might trigger change of stream type
        if self.hpstream != None:
            self.hpstream.chans = self.chans_enabled

    chans_enabled = property(get_chans_enabled, set_chans_enabled)

    def CloseSurfOrTrackFile(self):
        """Destroy data and sort windows, clean up, close streams,
        and metaphorically, .sort file too"""
        # need to specifically get a list of keys, not an iterator,
        # since self.windows dict changes size during iteration
        for windowtype in self.windows.keys():
            if windowtype != 'PyShell': # leave pyshell window alone
                self.CloseWindow(windowtype) # deletes from dict
        for stream in [self.hpstream, self.lpstream]:
            if stream: stream.close()
        self.hpstream = None
        self.lpstream = None
        self.chans_enabled = []
        self.t = None
        self.spiketw = DEFSPIKETW # reset
        self.charttw = DEFCHARTTW
        self.lfptw = DEFLFPTW
        self.ShowRasters(False) # reset
        self.setWindowTitle('spyke') # update caption
        self.EnableSurfWidgets(False)
        self.caption = ''
        self.CloseSortFile()

    def CloseSortFile(self):
        self.DeleteSort()
        self.EnableSortWidgets(False)

    def OpenSortFile(self, fname):
        """Open a Sort from a .sort file, try and open a .wave file
        with the same name, restore the stream"""
        self.DeleteSort() # delete any existing Sort
        print('opening sort file %r' % fname)
        t0 = time.time()
        f = open(fname, 'rb')
        sort = cPickle.load(f)
        print('done opening sort file, took %.3f sec' % (time.time()-t0))
        print('sort file was %d bytes long' % f.tell())
        f.close()
        self.sort = sort
        sortProbeType = type(sort.probe)
        if self.hpstream != None:
            streamProbeType = type(self.hpstream.probe)
            if sortProbeType != streamProbeType:
                self.CreateNewSort() # overwrite the failed Sort
                raise RuntimeError(".sort file's probe type %r doesn't match .srf file's probe type %r"
                                   % (sortProbeType, streamProbeType))

        self.OpenSpikeFile(sort.spikefname)

        if self.hpstream != None:
            sort.stream = self.hpstream # restore missing stream object to Sort
        self.SetSampfreq(sort.sampfreq)
        self.SetSHCorrect(sort.shcorrect)
        self.ShowRasters(True) # turn rasters on and update rasters menu item now that we have a sort
        self.ui.menuSampling.setEnabled(False) # disable sampling menu
        self.ui.progressBar.setFormat("%d spikes" % sort.nspikes)
        self.EnableSpikeWidgets(True)

        self.SPIKEWINDOWWIDTH = sort.probe.ncols * SPIKEWINDOWWIDTHPERCOLUMN
        sw = self.OpenWindow('Sort') # ensure it's open
        # restore unsorted spike listview
        sw.uslist.updateAll()

        # do this here first in case no clusters exist and hence self.AddClusters2GUI
        # is never called, yet you want spikes to be plotted in the cluster window:
        cw = self.OpenWindow('Cluster')
        try: cw.glyph # glyph already plotted?
        except AttributeError: self.on_plotButton_clicked() # create glyph on first open
        # try and reset camera view and roll to where it was last saved
        try: cw.view, cw.roll = sort.view, sort.roll
        except AttributeError: pass
        self.RestoreClusters2GUI()

        self.setWindowTitle(self.caption + ' | ' + self.sort.sortfname)
        self.update_gui_from_sort()
        self.EnableSortWidgets(True)

    def OpenSpikeFile(self, fname):
        sort = self.sort
        print('loading spike file %r' % fname)
        t0 = time.time()
        f = open(fname, 'rb')
        spikes = np.load(f)
        print('done opening spike file, took %.3f sec' % (time.time()-t0))
        print('spike file was %d bytes long' % f.tell())
        f.close()
        sort.spikes = spikes
        # when loading a spike file, make sure the nid field is overwritten
        # in the spikes array. The nids in sort.neurons are always the definitive ones
        for neuron in sort.neurons.values():
            spikes['nid'][neuron.sids] = neuron.id
        sort.update_usids()
        # try loading .wave file of the same name
        wavefname = os.path.splitext(fname)[0] + '.wave'
        sort.wavedata = self.OpenWaveFile(wavefname)

    def OpenWaveFile(self, fname):
        """Open a .wave file and return wavedata array"""
        sort = self.sort
        print('opening wave file %r' % fname)
        t0 = time.time()
        try: f = open(fname, 'rb')
        except IOError:
            print("can't find file %r" % fname)
            return
        try:
            del sort.wavedata
            #gc.collect() # ensure memory is freed up to prepare for new wavedata, necessary?
        except AttributeError: pass
        wavedata = np.load(f)
        print('done opening wave file, took %.3f sec' % (time.time()-t0))
        print('wave file was %d bytes long' % f.tell())
        f.close()
        if len(wavedata) != sort.nspikes:
            critical = QtGui.QMessageBox.critical
            critical(self, "Error",
                     ".wave file has a different number of spikes from the current Sort")
            raise RuntimeError
        return wavedata

    def RestoreClusters2GUI(self):
        """Stuff that needs to be done to synch the GUI with newly imported clusters"""
        # restore neuron clusters and the neuron listctrl
        for cluster in self.sort.clusters.values():
            self.AddCluster2GUI(cluster, update=False)
        self.UpdateClustersGUI()
        try:
            self.sort.spikes
            self.ColourPoints(self.sort.clusters.values()) # colour points for all clusters in one shot
        except AttributeError: pass # no spikes
        self.OpenWindow('Sort')
    '''
    def ImportNeurons(self, fname):
        print('opening sort file %r to import neurons' % fname)
        t0 = time.time()
        f = open(fname, 'rb')
        sort = cPickle.load(f)
        print('done opening sort file, took %.3f sec' % (time.time()-t0))
        print('sort was %d bytes long' % f.tell())
        f.close()
        if len(sort.neurons) == 0:
            raise RuntimeError('sort in file %r has no neurons to import' % fname)
        # delete any existing clusters from GUI
        for cluster in self.sort.clusters.values():
            self.DelCluster(cluster, update=False)
        self.UpdateClustersGUI()
        # reset all plotted spike points to white
        cw = self.OpenWindow('Cluster')
        try: # decolour any and all spikes
            cw.glyph # spikes glyph already plotted?
            self.DeColourAllPoints()
            self.windows['Cluster'].glyph.mlab_source.update()
        except AttributeError: pass # no spikes glyph to decolour
        for neuron in sort.neurons.values():
            neuron.sids = np.array([], dtype=int) # clear spike indices of all imported neurons
            neuron.sort = self.sort # overwrite the sort neurons came from with current sort
        self.sort.neurons = sort.neurons
        self.sort.clusters = sort.clusters
        # TODO: import auto clustering output arrays too!
        self.RestoreClusters2GUI()
    '''
    def SaveSortFile(self, fname):
        """Save sort to a .sort file"""
        s = self.sort
        try: s.spikes
        except AttributeError: raise RuntimeError("Sort has no spikes to save")
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.sort'
        try: s.spikefname
        except AttributeError: # corresponding .spike filename hasn't been gemerated yet
            s.spikefname = os.path.splitext(fname)[0] + '.spike'
        self.SaveSpikeFile(s.spikefname) # always (re)save .spike when saving .sort
        print('saving sort file %r' % fname)
        t0 = time.time()
        try:
            cw = self.windows['Cluster']
            s.view, s.roll = cw.view, cw.roll # save camera view
        except KeyError: pass # cw hasn't been opened yet, no camera view to save
        s.sortfname = fname # bind it now that it's about to be saved
        f = open(fname, 'wb')
        cPickle.dump(s, f, protocol=-1) # pickle with most efficient protocol
        f.close()
        print('done saving sort file, took %.3f sec' % (time.time()-t0))
        self.setWindowTitle(self.caption + ' | ' + s.sortfname)

    def SaveSpikeFile(self, fname):
        """Save spikes to a .spike file"""
        s = self.sort
        try: s.spikes
        except AttributeError: raise RuntimeError("Sort has no spikes to save")
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.spike'
        try: s.wavefname
        except AttributeError: # corresponding .wave filename hasn't been generated yet
            wavefname = os.path.splitext(fname)[0] + '.wave'
            self.SaveWaveFile(wavefname) # only (re)save .wave if missing s.wavefname attrib
        print('saving spike file %r' % fname)
        t0 = time.time()
        f = open(fname, 'wb')
        np.save(f, s.spikes)
        f.close()
        print('done saving spike file, took %.3f sec' % (time.time()-t0))
        s.spikefname = fname # used to indicate that the spikes have been saved

    def SaveWaveFile(self, fname):
        """Save waveform data to a .wave file"""
        s = self.sort
        try: s.wavedata
        except AttributeError: return # no wavedata to save
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.wave'
        print('saving wave file %r' % fname)
        t0 = time.time()
        f = open(fname, 'wb')
        np.save(f, s.wavedata)
        f.close()
        print('done saving wave file, took %.3f sec' % (time.time()-t0))
        s.wavefname = fname

    def OpenWindow(self, windowtype):
        """Create and bind a window, show it, plot its data if applicable"""
        new = windowtype not in self.windows
        if new:
            if windowtype == 'Spike':
                x = self.pos().x()
                y = self.pos().y() + self.size().height() + METACITYHACK
                window = SpikeWindow(parent=self, tw=self.spiketw, pos=(x, y),
                                     size=(self.SPIKEWINDOWWIDTH, SPIKEWINDOWHEIGHT))
            elif windowtype == 'Chart':
                x = self.pos().x() + self.SPIKEWINDOWWIDTH
                y = self.pos().y() + self.size().height() + METACITYHACK
                window = ChartWindow(parent=self, tw=self.charttw, cw=self.spiketw,
                                     pos=(x, y), size=CHARTWINDOWSIZE)
            elif windowtype == 'LFP':
                x = self.pos().x() + self.SPIKEWINDOWWIDTH + CHARTWINDOWSIZE[0]
                y = self.pos().y() + self.size().height() + METACITYHACK
                window = LFPWindow(parent=self, tw=self.lfptw, cw=self.charttw,
                                   pos=(x, y), size=LFPWINDOWSIZE)
            elif windowtype == 'Sort':
                x = self.pos().x() + self.size().width()
                y = self.pos().y()
                window = SortWindow(parent=self, pos=(x, y))
            elif windowtype == 'Cluster':
                x = self.pos().x() + self.SPIKEWINDOWWIDTH
                y = self.pos().y() + self.size().height() + METACITYHACK
                from cluster import ClusterWindow # can't delay this any longer
                window = ClusterWindow(parent=self, pos=(x, y), size=CLUSTERWINDOWSIZE)
            self.windows[windowtype] = window
            self.dpos[windowtype] = window.pos() - self.pos()
        self.ShowWindow(windowtype) # just show it
        if new: # do stuff that only works after first show
            if windowtype != 'Cluster':
                window.panel.draw_refs() # prevent plot artifacts
            if windowtype == 'Sort':
                window.mainsplitter.moveSplitter(MAINSPLITTERPOS, 1)
        return self.windows[windowtype] # 'window' isn't necessarily in local namespace

    def ShowWindow(self, windowtype, enable=True):
        """Show/hide a window, force menu and toolbar states to correspond"""
        window = self.windows[windowtype]
        if enable:
            window.show()
        else:
            window.hide()
        self.ui.__dict__['action%sWindow' % windowtype].setChecked(enable)
        if enable and isinstance(window, DataWindow):
            # update the newly shown data window's data, in case self.t changed since
            # it was last visible
            self.plot(windowtype)

    def HideWindow(self, windowtype):
        self.ShowWindow(windowtype, False)

    def ToggleWindow(self, windowtype):
        """Toggle visibility of a data window"""
        try:
            window = self.windows[windowtype]
            self.ShowWindow(windowtype, not window.isVisible()) # toggle it
        except KeyError: # window hasn't been opened yet
            self.OpenWindow(windowtype)

    def CloseWindow(self, windowtype):
        """Hide window, remove it from windows dict, destroy it"""
        self.HideWindow(windowtype)
        window = self.windows.pop(windowtype)
        window.destroy()

    def ToggleWaveforms(self):
        raise NotImplementedError

    def ToggleRasters(self):
        """Toggle visibility of rasters"""
        enable = self.ui.actionRasters.isChecked()
        self.ShowRasters(enable)

    def ShowRasters(self, enable=True):
        """Show/hide rasters for all applicable windows. Force menu states to correspond"""
        self.ui.actionRasters.setChecked(enable)
        for windowtype, window in self.windows.iteritems():
            if windowtype in ['Spike', 'Chart', 'LFP']:
                window.panel.show_rasters(enable=enable)
                self.plot(windowtype)

    def ToggleRef(self, ref):
        """Toggle visibility of TimeRef, VoltageRef, or the Caret"""
        enable = self.ui.__dict__['action%s' % ref].isChecked()
        self.ShowRef(ref, enable)

    def ShowRef(self, ref, enable=True):
        """Show/hide a TimeRef, VoltageRef, or the Caret. Force menu states to correspond"""
        self.ui.__dict__['action%s' % ref].setChecked(enable)
        for windowtype, window in self.windows.items():
            if windowtype in ['Spike', 'Chart', 'LFP']:
                window.panel.show_ref(ref, enable=enable)
            elif windowtype == 'Sort':
                window.spikesortpanel.show_ref(ref, enable=enable)
                #window.chartsortpanel.show_ref(ref, enable=enable)

    def SetSampfreq(self, sampfreq):
        """Set highpass stream sampling frequency, update widgets"""
        if self.hpstream != None:
            self.hpstream.sampfreq = sampfreq
            # since slider is in multiples of SLIDERTRES, doesn't need to be updated
            self.plot()
        self.ui.__dict__['action%dkHz' % (sampfreq / 1000)].setChecked(True)

    def SetSHCorrect(self, enable):
        """Set highpass stream sample & hold correct flag, update widgets"""
        if self.hpstream != None:
            self.hpstream.shcorrect = enable
        self.ui.actionSampleAndHoldCorrect.setChecked(enable)
        self.plot()

    def EnableSurfWidgets(self, enable):
        """Enable/disable all widgets that require an open .srf file"""
        return # do nothing, at least for now
        '''
        self.menubar.Enable(wx.ID_NEW, enable)
        self.menubar.Enable(wx.ID_SPIKEWIN, enable)
        self.menubar.Enable(wx.ID_CHARTWIN, enable)
        self.menubar.Enable(wx.ID_LFPWIN, enable)
        self.menubar.Enable(wx.ID_TREF, enable)
        self.menubar.Enable(wx.ID_VREF, enable)
        self.menubar.Enable(wx.ID_CARET, enable)
        self.menubar.Enable(wx.ID_SAMPLING, enable)
        self.menubar.Enable(wx.ID_WAVEFORMS, enable)
        self.toolbar.EnableTool(wx.ID_NEW, enable)
        self.toolbar.EnableTool(wx.ID_SPIKEWIN, enable)
        self.toolbar.EnableTool(wx.ID_CHARTWIN, enable)
        self.toolbar.EnableTool(wx.ID_LFPWIN, enable)
        self.file_pos_control_panel.Show(enable)
        self.notebook.Show(enable)
        self.detect_button.Enable(enable)
        self.file_min_label.Show(enable)
        self.file_max_label.Show(enable)
        '''
    def EnableSortWidgets(self, enable):
        """Enable/disable all widgets that require an "open" .sort file"""
        '''
        self.menubar.Enable(wx.ID_SORTWIN, enable)
        self.toolbar.EnableTool(wx.ID_SORTWIN, enable)
        self.menubar.Enable(wx.ID_CLUSTERWIN, enable)
        self.toolbar.EnableTool(wx.ID_CLUSTERWIN, enable)
        self.menubar.Enable(wx.ID_SAVE, enable)
        self.toolbar.EnableTool(wx.ID_SAVE, enable)
        self.menubar.Enable(wx.ID_RASTERS, enable)
        '''
        self.EnableSpikeWidgets(enable)

    def EnableSpikeWidgets(self, enable):
        """Enable/disable all widgets that require the current Sort to have spikes"""
        return # do nothing for now
        '''
        try:
            if len(self.sort.spikes) == 0: enable = False # no spikes
        except AttributeError: enable = False # self.sort doesn't exist yet
        self.extract_pane.Enable(enable)
        try: self.sort.extractor
        except AttributeError: enable = False # no params extracted, or .sort doesn't exist
        self.cluster_pane.Enable(enable)
        try:
            if len(self.sort.clusters) == 0: enable = False # no clusters exist yet
        except AttributeError: enable = False
        self.cluster_params_pane.Enable(enable)
        try:
            if len(self.sort.neurons) == 0: enable = False # no neurons
        except AttributeError: enable = False # self.sort doesn't exist yet
        self.validate_pane.Enable(enable)
        '''
    def EnablePosOriScaleWidgets(self, enable):
        """Enable/disable the pos, ori, and scale textctrl widgets for controlling
        and displaying cluster params. Use this instead of self.cluster_pane.Enable()
        to allow the dims ComboBoxes to remain enabled for plotting purposes"""
        widgets = [self.xpos, self.ypos, self.zpos,
                   self.xori, self.yori, self.zori,
                   self.xscale, self.yscale, self.zscale]
        for widget in widgets:
            widget.Enable(enable)

    def get_detector(self):
        """Create and bind Detector object, update sort from gui"""
        self.sort.detector = Detector(sort=self.sort)
        self.update_sort_from_gui()

    def update_sort_from_gui(self):
        self.update_sort_from_detector_pane()
        self.update_sort_from_cluster_pane()

    def update_sort_from_detector_pane(self):
        ui = self.ui
        det = self.sort.detector
        det.chans = self.chans_enabled
        if ui.globalFixedRadioButton.isChecked():
            threshmethod = 'GlobalFixed'
        elif ui.channelFixedRadioButton.isChecked():
            threshmethod = 'ChanFixed'
        elif ui.dynamicRadioButton.isChecked():
            threshmethod = 'Dynamic'
        else:
            raise ValueError
        det.threshmethod = threshmethod
        det.fixedthreshuV = ui.globalFixedSpinBox.value()
        det.noisemult = ui.dynamicNoiseXSpinBox.value()
        det.noisemethod = str(ui.noiseMethodComboBox.currentText())
        det.ppthreshmult = ui.vppThreshXSpinBox.value()
        det.dt = ui.phaseDTSpinBox.value()
        det.trange = self.get_detectortrange()
        det.blocksize = int(float(ui.blockSizeLineEdit.text())) # allow exp notation
        det.lockr = ui.lockRSpinBox.value()
        det.inclr = ui.inclRSpinBox.value()

    def update_sort_from_cluster_pane(self):
        ui = self.ui
        s = self.sort
        s.sigma = ui.sigmaSpinBox.value()
        s.rmergex = ui.rmergeXSpinBox.value()
        s.rneighx = ui.rneighXSpinBox.value()
        s.alpha = ui.alphaSpinBox.value()
        s.nsamples = ui.nsamplesSpinBox.value()
        s.maxstill = ui.maxstillSpinBox.value()
        s.minpoints = ui.minpointsSpinBox.value()

    def update_gui_from_sort(self):
        ui = self.ui
        s = self.sort
        det = s.detector
        self.chans_enabled = det.chans
        # update detector pane
        meth2widget = {'GlobalFixed': ui.globalFixedRadioButton,
                       'ChanFixed': ui.channelFixedRadioButton,
                       'Dynamic': ui.dynamicRadioButton}
        meth2widget[det.threshmethod].setChecked(True)
        ui.globalFixedSpinBox.setValue(det.fixedthreshuV)
        ui.dynamicNoiseXSpinBox.setValue(det.noisemult)
        ui.noiseMethodComboBox.setCurrentIndex(ui.noiseMethodComboBox.findText(det.noisemethod))
        ui.vppThreshXSpinBox.setValue(det.ppthreshmult)
        ui.phaseDTSpinBox.setValue(det.dt)
        ui.rangeStartLineEdit.setText(str(det.trange[0]))
        ui.rangeEndLineEdit.setText(str(det.trange[1]))
        ui.blockSizeLineEdit.setText(str(det.blocksize))
        ui.lockRSpinBox.setValue(det.lockr)
        ui.inclRSpinBox.setValue(det.inclr)
        # update cluster pane
        ui.sigmaSpinBox.setValue(s.sigma)
        ui.rmergeXSpinBox.setValue(s.rmergex)
        ui.rneighXSpinBox.setValue(s.rneighx)
        ui.alphaSpinBox.setValue(s.alpha)
        ui.nsamplesSpinBox.setValue(s.nsamples)
        ui.maxstillSpinBox.setValue(s.maxstill)
        ui.minpointsSpinBox.setValue(s.minpoints)

    def get_detectortrange(self):
        """Get detector time range from combo boxes, and convert
        start, now, and end to appropriate vals"""
        t0 = str(self.ui.rangeStartLineEdit.text())
        t1 = str(self.ui.rangeEndLineEdit.text())
        try:
            t0 = self.str2t[t0]
        except KeyError:
            t0 = int(float(t0)) # convert to float to allow exp notation shorthand
        try:
            t1 = self.str2t[t1]
        except KeyError:
            t1 = int(float(t1))
        return t0, t1

    def seek(self, offset=0):
        """Seek to position in surf file. offset is time in us"""
        oldt = self.t
        self.t = intround(offset / self.hpstream.tres) * self.hpstream.tres # round to nearest (possibly interpolated) sample
        self.t = min(max(self.t, self.range[0]), self.range[1]) # constrain to within .range
        self.str2t['now'] = self.t # update
        # only plot if t has actually changed, though this doesn't seem to improve
        # performance, maybe mpl is already doing something like this?
        if self.t != oldt: # update controls first so they don't lag
            self.ui.filePosLineEdit.setText(str(self.t))
            self.ui.slider.setValue(self.t // SLIDERTRES)
            self.plot()
    '''
    def step(self, direction):
        """Step one timepoint left or right"""
        self.seek(self.t + direction*self.hpstream.tres)

    def page(self, direction):
        """Page left or right"""
        self.seek(self.t + direction*self.hpstream.tres)
    '''
    def tell(self):
        """Return current position in surf file"""
        return self.t

    def plot(self, windowtypes=None):
        """Update the contents of all the data windows, or just specific ones.
        Center each data window on self.t"""
        if windowtypes == None: # update all visible windows
            windowtypes = self.windows.keys()
        else: # update only specific windows, if visible
            windowtypes = toiter(windowtypes)
        windowtypes = [ windowtype for windowtype in WINDOWUPDATEORDER if windowtype in windowtypes ] # reorder
        windows = [ self.windows[windowtype] for windowtype in windowtypes ] # get windows in order
        for windowtype, window in zip(windowtypes, windows):
            if window.isVisible(): # for performance, only update if window is shown
                if windowtype == 'Spike':
                    wave = self.hpstream[self.t+self.spiketw[0] : self.t+self.spiketw[1]]
                elif windowtype == 'Chart':
                    wave = self.hpstream[self.t+self.charttw[0] : self.t+self.charttw[1]]
                elif windowtype == 'LFP':
                    wave = self.lpstream[self.t+self.lfptw[0] : self.t+self.lfptw[1]]
                window.panel.plot(wave, tref=self.t) # plot it


class DataWindow(QtGui.QDockWidget):
    """Base data window to hold a custom spyke panel widget"""
    def setupUi(self, pos, size):
        self.setWidget(self.panel)
        #self.parent().addDockWidget(QtCore.Qt.RightDockWidgetArea, self)
        self.setFloating(True)
        self.move(*pos)
        self.resize(*size)

    def resizeEvent(self, event):
        """Redraws refs and resaves panel background after resizing the window"""
        QtGui.QDockWidget.resizeEvent(self, event)
        self.panel.draw_refs()

    def closeEvent(self, event):
        # remove 'Window' from class name
        windowtype = type(self).__name__.replace('Window', '')
        self.parent().HideWindow(windowtype)


class SpikeWindow(DataWindow):
    """Window to hold the custom spike panel widget"""
    def __init__(self, parent=None, tw=None, cw=None, pos=None, size=None):
        DataWindow.__init__(self, parent)
        self.panel = SpikePanel(self, tw=tw, cw=cw)
        self.setupUi(pos, size)
        self.setWindowTitle("Spike Window")


class ChartWindow(DataWindow):
    """Window to hold the custom chart panel widget"""
    def __init__(self, parent=None, tw=None, cw=None, pos=None, size=None):
        DataWindow.__init__(self, parent)
        self.panel = ChartPanel(self, tw=tw, cw=cw)
        self.setupUi(pos, size)
        self.setWindowTitle("Chart Window")


class LFPWindow(DataWindow):
    """Window to hold the custom LFP panel widget"""
    def __init__(self, parent=None, tw=None, cw=None, pos=None, size=None):
        DataWindow.__init__(self, parent)
        self.panel = LFPPanel(self, tw=tw, cw=cw)
        self.setupUi(pos, size)
        self.setWindowTitle("LFP Window")


if __name__ == '__main__':
    app = QtGui.QApplication(sys.argv)
    spykewindow = SpykeWindow()
    spykewindow.show()
    try:
        from IPython import appstart_qt4
        appstart_qt4(app)
    except ImportError:
        sys.exit(app.exec_())
