"""Main spyke window"""

from __future__ import division

__authors__ = ['Martin Spacek', 'Reza Lotun']

import numpy as np
import pyximport
pyximport.install(setup_args={'include_dirs':[np.get_include()]})

from climbing import climb # .pyx file

import scipy.stats
import wx
import wx.html
import wx.py
import os
import sys
import time
import datetime
import gc
import cPickle
import random

spykepath = os.path.split(os.getcwd())[0] # parent dir of cwd
sys.path.insert(0, spykepath)

import spyke
from spyke import core, surf, detect, extract
from spyke.sort import Sort
from spyke.core import toiter, intround, MICRO
from spyke.plot import ChartPanel, LFPPanel, SpikePanel, CMAP, TRANSWHITEI
from spyke.sort import SortFrame
import wxglade_gui

DEFSPIKETW = -500, 500 # spike frame temporal window (us)
DEFCHARTTW = -25000, 25000 # chart frame temporal window (us)
DEFLFPTW = -500000, 500000 # lfp frame temporal window (us)

SPIKEFRAMEWIDTHPERCOLUMN = 80
SPIKEFRAMEHEIGHT = 700
CHARTFRAMESIZE = 900, SPIKEFRAMEHEIGHT
LFPFRAMESIZE = 250, SPIKEFRAMEHEIGHT
PYSHELLSIZE = CHARTFRAMESIZE[0], CHARTFRAMESIZE[1]/2
CLUSTERFRAMESIZE = 535, 535

FRAMEUPDATEORDER = ['spike', 'lfp', 'chart'] # chart goes last cuz it's slowest
PYSHELLCFGFNAME = 'pyshell_cfg'


class SpykeFrame(wxglade_gui.SpykeFrame):
    """spyke's main frame, inherits gui layout code auto-generated by wxGlade"""

    FRAMETYPE2ID = {'spike': wx.ID_SPIKEWIN,
                    'chart': wx.ID_CHARTWIN,
                    'lfp': wx.ID_LFPWIN,
                    'sort': wx.ID_SORTWIN,
                    'cluster': wx.ID_CLUSTERWIN,
                    'pyshell': wx.ID_PYSHELL}
    REFTYPE2ID = {'tref': wx.ID_TREF,
                  'vref': wx.ID_VREF,
                  'caret': wx.ID_CARET}
    SAMPFREQ2ID = {25000: wx.ID_25,
                   50000: wx.ID_50,
                   100000: wx.ID_100}

    def __init__(self, *args, **kwargs):
        wxglade_gui.SpykeFrame.__init__(self, *args, **kwargs)
        self.SetPosition(wx.Point(x=0, y=0)) # upper left corner
        self.dpos = {} # positions of data frames relative to main spyke frame
        self.srff = None # Surf File object
        self.srffname = '' # used for setting title caption
        for d in ('/data', '/media/WinXP/data'):
            try: # use first existing path
                os.chdir(os.path.abspath(d))
                break
            except: # path doesn't exist
                pass
        self.frames = {} # holds spike, chart, lfp, sort, and pyshell frames
        self.spiketw = DEFSPIKETW # spike frame temporal window (us)
        self.charttw = DEFCHARTTW # chart frame temporal window (us)
        self.lfptw = DEFLFPTW # lfp frame temporal window width (us)
        self.t = None # current time position in recording (us)

        self.hpstream = None
        self.lpstream = None

        #self.Bind(wx.EVT_MOVE, self.OnMove)
        self.Bind(wx.EVT_CLOSE, self.OnExit)

        self.slider.Bind(wx.EVT_SLIDER, self.OnSlider)

        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)

        self.set_detect_pane_defaults()

        self.file_pos_combo_box_units_label.SetLabel(MICRO+'s') # can't seem to set mu symbol from within wxGlade
        self.fixedthreshuV_units_label.SetLabel(MICRO+'V')
        self.dt_units_label.SetLabel(MICRO+'s')
        self.range_units_label.SetLabel(MICRO+'s')
        self.blocksize_units_label.SetLabel(MICRO+'s')
        self.lockout_units_label.SetLabel(MICRO+'m')
        self.include_units_label.SetLabel(MICRO+'m')

        # disable most widgets until a .srf or .sort file is opened
        self.EnableSurfWidgets(False)
        self.EnableSortWidgets(False)

        # TODO: load recent file history and add it to menu (see wxGlade code that uses wx.FileHistory)

        # for faster testing:
        '''
        os.chdir('/data/ptc15')
        srffname = '87 - track 7c spontaneous craziness.srf'
        self.OpenSurfFile(srffname)
        os.chdir('/data/ptc15/tr7c/87 - track 7c spontaneous craziness')
        sortfname = '2010-09-09_17.06.14_test.sort'
        self.OpenSortFile(sortfname)
        '''
    def set_detect_pane_defaults(self):
        """Set detect pane widget initial values"""
        self.METH2RADIOBTN = {'GlobalFixed': self.globalfixedthresh_radio_btn,
                              'ChanFixed': self.chanfixedthresh_radio_btn,
                              'Dynamic': self.dynamicthresh_radio_btn}
        self.METH2RADIOBTN[detect.Detector.DEFTHRESHMETHOD].SetValue(True) # enable the appropriate radio button
        self.fixedthreshuV_spin_ctrl.SetValue(detect.Detector.DEFFIXEDTHRESHUV)
        self.noisemult_text_ctrl.SetValue(str(detect.Detector.DEFNOISEMULT))
        self.noise_method_choice.SetStringSelection(detect.Detector.DEFNOISEMETHOD)
        self.ppthreshmult_text_ctrl.SetValue(str(detect.Detector.DEFPPTHRESHMULT))
        self.dt_spin_ctrl.SetValue(detect.Detector.DEFDT)
        self.nspikes_spin_ctrl.SetValue(detect.Detector.DEFMAXNSPIKES)

        # TODO: this is just temporary, for faster testing
        #self.range_start_combo_box.SetValue('0')
        #self.range_end_combo_box.SetValue('30e6')

        self.blocksize_combo_box.SetValue(str(detect.Detector.DEFBLOCKSIZE))
        self.lockr_spin_ctrl.SetValue(detect.Detector.DEFLOCKR)
        self.inclr_spin_ctrl.SetValue(detect.Detector.DEFINCLR)
        self.random_sample_checkbox.SetValue(detect.Detector.DEFRANDOMSAMPLE)

    def set_cluster_pane_defaults(self):
        s = self.sort
        self.sigma_text_ctrl.SetValue(str(s.sigma))
        self.rmergex_text_ctrl.SetValue(str(s.rmergex))
        self.alpha_text_ctrl.SetValue(str(s.alpha))
        self.nsamples_spin_ctrl.SetValue(s.nsamples)
        self.maxstill_spin_ctrl.SetValue(s.maxstill)
        self.minpoints_spin_ctrl.SetValue(s.minpoints)
        #self.density_thresh_text_ctrl.SetValue(str(s.density_thresh))

    def OnNew(self, evt):
        self.CreateNewSort()

    def OnOpen(self, evt):
        dlg = wx.FileDialog(self, message="Open .srf, .sort or .wave file",
                            defaultDir=os.getcwd(), defaultFile='',
                            #wildcard="All files (*.*)|*.*|Surf files (*.srf)|*.srf|Sort files (*.sort)|*.sort|Wave files (*.wave)|*.wave",
                            wildcard="Surf & sort files (*.srf, *.sort)|*.srf;*.sort|All files (*.*)|*.*",
                            style=wx.OPEN)
        if dlg.ShowModal() == wx.ID_OK:
            fname = dlg.GetPath()
            head, tail = os.path.split(fname)
            os.chdir(head) # update cwd
            self.OpenFile(tail)
        dlg.Destroy()

    def OnSave(self, evt):
        if not hasattr(self.sort, 'sortfname'):
            self.OnSaveAs(evt)
        else:
            self.SaveSortFile(self.sort.sortfname) # save to existing sort fname

    def OnSaveAs(self, evt):
        """Save Sort to new .sort file"""
        dlg = wx.FileDialog(self, message="Save sort as",
                            defaultDir=os.getcwd(), defaultFile='',
                            wildcard="Sort files (*.sort)|*.sort|All files (*.*)|*.*",
                            style=wx.SAVE | wx.OVERWRITE_PROMPT)
        if dlg.ShowModal() == wx.ID_OK:
            fname = dlg.GetPath()
            head, tail = os.path.split(fname)
            # prepend datetime to tail:
            dt = str(datetime.datetime.now()) # get an export timestamp
            dt = dt.split('.')[0] # ditch the us
            dt = dt.replace(' ', '_')
            dt = dt.replace(':', '.')
            tail = dt + '_' + tail
            os.chdir(head) # update cwd
            # make way for new .spike and .wave files
            try: del self.sort.spikefname
            except AttributeError: pass
            try: del self.sort.wavefname
            except AttributeError: pass
            self.SaveSortFile(tail)
        dlg.Destroy()

    def OnSaveWave(self, evt):
        """Save waveforms to a .wave file"""
        defaultFile = os.path.splitext(self.sortfname)[0] + '.wave'
        dlg = wx.FileDialog(self, message="Save waveforms as",
                            defaultDir=os.getcwd(), defaultFile=defaultFile,
                            wildcard="Sort files (*.wave)|*.wave|All files (*.*)|*.*",
                            style=wx.SAVE | wx.OVERWRITE_PROMPT)
        if dlg.ShowModal() == wx.ID_OK:
            fname = dlg.GetPath()
            head, tail = os.path.split(fname)
            os.chdir(head) # update cwd
            self.SaveWaveFile(tail)
        dlg.Destroy()

    def OnSaveParse(self, evt):
        self.srff.pickle()

    def OnSaveResample(self, evt):
        self.hpstream.save_resampled()

    def OnImportNeurons(self, evt):
        dlg = wx.FileDialog(self, message="Import neurons from .sort file",
                            defaultDir=os.getcwd(), defaultFile='',
                            wildcard="Sort files (*.sort)|*.sort",
                            style=wx.OPEN)
        if dlg.ShowModal() == wx.ID_OK:
            fname = dlg.GetPath()
            # don't update cwd
            self.ImportNeurons(fname)
        dlg.Destroy()

    def OnExportSpikes(self, evt):
        dlg = wx.DirDialog(self, message="Export spikes to",
                           defaultPath=os.getcwd())
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.sort.exportspikes(path=path)
            # don't update cwd

    def OnExportDIN(self, evt):
        srffnameroot = self.sort.get_srffnameroot()
        dlg = wx.DirDialog(self, message="Export DIN to",
                           defaultPath=os.getcwd())
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.sort.exportdin(srffnameroot=srffnameroot, path=path)
            # don't update cwd

    def OnExportTextheader(self, evt):
        srffnameroot = self.sort.get_srffnameroot()
        dlg = wx.DirDialog(self, message="Export textheader to",
                           defaultPath=os.getcwd())
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.sort.exporttextheader(srffnameroot=srffnameroot, path=path)
            # don't update cwd

    def OnExportAll(self, evt):
        dlg = wx.DirDialog(self, message="Export spikes, DIN and textheader to",
                           defaultPath=os.getcwd())
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.sort.export(path=path)
            # don't update cwd

    def OnClose(self, evt):
        # TODO: add confirmation dialog if Sort not saved
        self.CloseSurfFile()

    def OnExit(self, evt):
        # TODO: add confirmation dialog if Sort not saved
        self.CloseSurfFile()
        self.Destroy()

    def OnAbout(self, evt):
        dlg = SpykeAbout(self)
        dlg.ShowModal()
        dlg.Destroy()

    def OnSpike(self, evt):
        """Spike window toggle menu/button event"""
        self.ToggleFrame('spike')

    def OnChart(self, evt):
        """Chart window toggle menu/button event"""
        self.ToggleFrame('chart')

    def OnLFP(self, evt):
        """LFP window toggle menu/button event"""
        self.ToggleFrame('lfp')

    def OnSort(self, evt):
        """Sort window toggle menu/button event"""
        self.ToggleFrame('sort')

    def OnCluster(self, evt):
        """Cluster window toggle menu/button event"""
        self.ToggleFrame('cluster')

    def OnPyShell(self, evt):
        """PyShell window toggle menu/button event"""
        self.ToggleFrame('pyshell')

    def OnWaveforms(self, evt):
        """Spike waveforms toggle menu event"""
        self.ToggleWaveforms()

    def OnRasters(self, evt):
        """Spike rasters toggle menu event"""
        self.ToggleRasters()

    def OnTref(self, evt):
        """Time reference toggle menu event"""
        self.ToggleRef('tref')

    def OnVref(self, evt):
        """Voltage reference toggle menu event"""
        self.ToggleRef('vref')

    def OnCaret(self, evt):
        """Caret toggle menu event"""
        self.ToggleRef('caret')

    def OnSampling(self, evt):
        """Sampling frequency menu choice event"""
        menuitem = self.menubar.FindItemById(evt.GetId())
        sampfreq = int(menuitem.GetLabel().rstrip(' kHz'))
        sampfreq *= 1000 # convert from kHz to Hz
        self.SetSampfreq(sampfreq)

    def OnSHCorrect(self, evt):
        """Sample & hold menu event"""
        enable = self.menubar.IsChecked(wx.ID_SHCORRECT) # maybe not safe, but seems to work
        self.SetSHCorrect(enable)
    '''
    def OnMove(self, evt):
        """Move frame, and all dataframes as well, like docked windows"""
        for frametype, frame in self.frames.iteritems():
            frame.Move(self.GetPosition() + self.dpos[frametype])
        #evt.Skip() # apparently this isn't needed for a move event,
        # I guess the OS moves the frame no matter what you do with the event
    '''
    def OnFilePosComboBox(self, evt):
        """Change file position using combo box control,
        convert start, now, and end to appropriate vals"""
        """
        TODO: I set a value manually, but the OS overrides the value
        after this handler finishes handling the event. Eg, I want 'start'
        to be replaced with the actual self.t0 timestamp, which it is, but is then
        immediately replaced back to 'start' by the OS. Don't know how to
        prevent its propagation to the OS. ComboBoxEvent is a COMMAND event
        """
        t = self.file_pos_combo_box.GetValue()
        try:
            t = self.str2t[t]
        except KeyError:
            # convert to float first so you can use exp notation as shorthand
            t = float(t)
        self.seek(t)

    def OnSlider(self, evt):
        """Strange: keyboard press or page on mouse click when slider in focus generates
        two slider events, and hence two plot events - mouse drag only generates one slider event"""
        nt = self.slider.GetValue()
        self.seek(nt * self.hpstream.tres)
        #print time.time(), 'OnSlider()'
        #evt.Skip() # doesn't seem to be necessary

    def OnDetect(self, evt):
        """Detect pane Detect button click"""
        sort = self.sort
        sort.detector = self.get_detector() # update Sort's current detector with new one from widgets
        if sort.detector.extractparamsondetect:
            self.init_extractor() # init the Extractor
        sort.spikes, sort.wavedata = sort.detector.detect() # struct array of spikes, 3D array
        sort.update_usids()
        sort.sampfreq = sort.stream.sampfreq # lock down sampfreq and shcorrect attribs
        sort.shcorrect = sort.stream.shcorrect
        sort.tres = sort.stream.tres # for convenience

        # every time a new detection is run, need to clear sort, spike
        # and wave fnames. Want to (re)ask user for sort fname, and that will
        # in turn require regenerating the spike and wave fnames
        try: del sort.sortfname
        except AttributeError: pass
        try: del sort.spikefname
        except AttributeError: pass
        try: del sort.wavefname
        except AttributeError: pass

        self.total_nspikes_label.SetLabel(str(sort.nspikes))
        self.EnableSpikeWidgets(True)
        # disable sampling menu, don't want to allow sampfreq or shcorrect changes
        # now that we've had a detection run
        self.menubar.Enable(wx.ID_SAMPLING, False)
        self.menubar.Enable(wx.ID_RASTERS, True) # enable raster menu, now that spikes exist
        self.ShowRasters() # show spike rasters for open data windows
        sf = self.OpenFrame('sort') # ensure it's open
        self.EnableSpikeWidgets(True) # now that we (probably) have some spikes
        # refresh spike virtual listctrl
        sf.slist.SetItemCount(len(sort.usids))
        sf.slist.RefreshItems()
        #self.OpenFrame('pyshell') # for testing

    def init_extractor(self):
        """Initialize Extractor"""
        XYmethod = self.XY_extract_radio_box.GetStringSelection()
        ext = extract.Extractor(self.sort, XYmethod) # or eventually, self.get_extractor()
        self.sort.extractor = ext
        #self.update_extractor(ext) # eventually, update extractor from multiple Extract pane widgets

    def OnXYExtract(self, evt=None):
        """Extract pane XY Extract button click. Extracts (or re-extracts and
        overwrites) XY parameters from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        #import cProfile
        #cProfile.runctx('self.sort.extractor.extract_all_XY()', globals(), locals())

        self.sort.extractor.extract_all_XY() # adds extracted XY params to sort.spikes
        self.frames['sort'].slist.RefreshItems() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def OnWaveletExtract(self, evt=None):
        """Extract pane wavelet Extract button click. Extracts (or re-extracts and
        overwrites) wavelet coefficients from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        #import cProfile
        #cProfile.runctx('self.sort.extractor.extract_all_XY()', globals(), locals())

        # extract coeffs of selected wavelet type, add coeffs to sort.spikes
        wavelet = self.wavelet_extract_radio_box.GetStringSelection()
        self.sort.extractor.extract_all_wcs(wavelet)
        self.frames['sort'].slist.RefreshItems() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def OnTemporalExtract(self, evt=None):
        """Extract pane temporal Extract button click. Extracts (or re-extracts and
        overwrites) temporal params from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        self.sort.extractor.extract_all_temporal()
        self.frames['sort'].slist.RefreshItems() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def GetClusters(self):
        """Return currently selected clusters"""
        rows = self.clist.getSelection()
        cids = np.asarray(sorted(self.sort.clusters))[rows]
        clusters = [ self.sort.clusters[cid] for cid in cids ]
        return clusters

    def GetCluster(self):
        """Return just one selected cluster"""
        clusters = self.GetClusters()
        nselected = len(clusters)
        if nselected != 1:
            raise RuntimeError("can't figure out which of the %d selected clusters you want"
                               % nselected)
        return clusters[0]

    def GetSpikes(self):
        """Return IDs of currently selected spikes"""
        sf = self.frames['sort']
        nsrows = sf.nslist.getSelection()
        srows = sf.slist.getSelection()
        sids = []
        try:
            sids.extend(sf.nslist.neuron.sids[nsrows])
        except AttributeError: pass # nslist has neuron=None, with no sids
        sids.extend(self.sort.usids[srows])
        return sids

    def GetSpike(self):
        """Return Id of just one selected spike, from nslist or slist"""
        sids = self.GetSpikes()
        nselected = len(sids)
        if nselected != 1:
            raise RuntimeError("can't figure out which of the %d selected spike IDs you want"
                               % nselected)
        return sids[0]

    def SelectClusters(self, clusters, on=True):
        """Select/deselect clusters"""
        clusters = toiter(clusters)
        all_nids = sorted(self.sort.neurons)
        sel_nids = [ cluster.id for cluster in clusters ]
        rows = np.searchsorted(all_nids, sel_nids)
        [ self.clist.Select(row, on=on) for row in rows ]

    def OnAddCluster(self, evt=None, update=True, id=None):
        """Cluster pane Add button click"""
        neuron = self.sort.create_neuron(id)
        sf = self.frames['sort']
        if update:
            sf.nlist.SetItemCount(len(self.sort.neurons))
            sf.nlist.RefreshItems()
        from cluster import Cluster # can't delay this any longer
        cluster = Cluster(neuron)
        self.sort.clusters[cluster.id] = cluster
        neuron.cluster = cluster
        cf = self.OpenFrame('cluster')
        try: cf.glyph # glyph already plotted?
        except AttributeError: self.OnClusterPlot() # create glyph on first open
        self.AddCluster(cluster, update=update)
        return cluster

    def AddCluster(self, cluster, update=True):
        """Add cluster to GUI"""
        cf = self.OpenFrame('cluster')
        dims = self.GetClusterPlotDimNames()
        cf.add_ellipsoid(cluster, dims, update=update)
        if update:
            self.clist.SetItemCount(len(self.sort.clusters))
            self.clist.RefreshItems()
            self.clist.DeSelectAll()
            self.clist.Select(len(self.sort.clusters) - 1) # select newly created item
        self.cluster_params_pane.Enable(True)

    def OnDelCluster(self, evt=None):
        """Cluster pane Del button click"""
        clusters = self.GetClusters()
        sids = []
        s = self.sort
        spikes = s.spikes
        sids = []
        for cluster in clusters:
            sids.append(cluster.neuron.sids)
        sids = np.concatenate(sids)

        # save stuff for undo
        self.clusterstate = spyke.cluster.ClusterState()
        cs = self.clusterstate
        cs.sids = sids
        cs.oldnids = spikes['nid'][sids]
        cs.oldunids = [ cluster.id for cluster in clusters ]
        cs.positions = [ cluster.pos.copy() for cluster in clusters ]
        cs.scales = [ cluster.scale.copy() for cluster in clusters ]
        cs.newunids = [] # no new ones added

        # deselect them all
        self.SelectClusters(clusters, on=False)
        for cluster in clusters:
            self.DelCluster(cluster, update=False)
        self.DeColourPoints(sids) # decolour appropriate points
        self.UpdateClustersGUI()
        self.frames['cluster'].glyph.mlab_source.update()
        if len(self.sort.clusters) == 0:
            self.cluster_params_pane.Enable(False)
        else:
            self.SelectClusters(s.clusters[max(s.clusters)]) # select last one

    def DelCluster(self, cluster, update=True):
        """Delete a cluster from the GUI, and delete the cluster
        and its neuron from the Sort. Think you need to call
        mlab_source.update() afterwards"""
        sf = self.frames['sort']
        cf = self.frames['cluster']
        cf.f.scene.disable_render = True # for speed
        cluster.ellipsoid.remove() # from pipeline
        cluster.ellipsoid = None
        if update:
            self.DeColourPoints(cluster.neuron.sids) # decolour before neuron loses its sids
        sf.RemoveNeuron(cluster.neuron, update=update)
        if update:
            self.clist.SetItemCount(len(self.sort.clusters))
            self.clist.RefreshItems()
            cf.f.scene.disable_render = False

    def OnRenumberClusters(self, evt=None):
        """Renumber clusters consecutively from 0, ordered by y position, on "#" button click.
        Sorting by y position makes user inspection of clusters more orderly, makes the presence
        of duplicate clusters more obvious, and allows for maximal spatial separation between
        clusters of the same colour, reducing colour conflicts"""

        # deselect current selections
        selclusters = self.GetClusters()
        oldselcids = [ cluster.id for cluster in selclusters ]
        self.SelectClusters(selclusters, on=False)

        s = self.sort
        spikes = s.spikes
        # get lists of unique old cids and new cids
        olducids = sorted(s.clusters) # make sure they're in order
        # this is a bit confusing: find indices that would sort olducids by y pos, but then
        # what you really want is to find the y pos *rank* of each uoldcid, so you need to
        # take argsort again:
        newucids = np.asarray([ s.clusters[cid].pos['y0'] for cid in olducids ]).argsort().argsort()
        cf = self.frames['cluster']
        cf.f.scene.disable_render = True # turn rendering off for speed
        oldclusters = s.clusters.copy()
        oldneurons = s.neurons.copy()
        s.clusters = {} # clear 'em
        s.neurons = {}
        for oldcid, newcid in zip(olducids, newucids):
            # change all occurences of oldcid to newcid
            cluster = oldclusters[oldcid]
            cluster.id = newcid # this indirectly updates neuron.id
            # update cluster and neuron dicts
            s.clusters[newcid] = cluster
            s.neurons[newcid] = cluster.neuron
            sids = cluster.neuron.sids
            spikes['nid'][sids] = newcid
            # TODO: can't figure out how to change scalar value of existing ellipsoid (for
            # mouse hover tooltip), just delete it and make a new one. This is very innefficient
            cluster.ellipsoid.remove()
            dims = self.GetClusterPlotDimNames()
            cf.add_ellipsoid(cluster, dims=dims, update=False) # this overwrites cluster.ellipsoid

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(s.clusters.values())
        # reselect the previously selected (but now renumbered) clusters - helps user keep track
        newselcids = newucids[np.searchsorted(olducids, oldselcids)]
        self.SelectClusters([s.clusters[cid] for cid in newselcids])
        try: del self.clusterstate # last cluster state no longer applicable
        except AttributeError: pass

    def OnCListSelect(self, evt=None):
        """Cluster list box item selection. Update cluster param widgets
        given current dims"""
        # TODO: this method isn't triggered when clicking in empty space to deselect all items
        #print('in OnCListSelect()')
        selectedRows = self.clist.getSelection()
        if len(selectedRows) == 1:
            cluster = self.GetCluster()
            self.EnablePosOriScaleWidgets(True)
            self.UpdateParamWidgets(cluster)
        else:
            self.EnablePosOriScaleWidgets(False)
        # mirror selection changes to nlist
        sf = self.frames['sort']
        all_nids = sorted(self.sort.neurons)
        nids = set(np.asarray(all_nids)[selectedRows])
        remove_nids = list(sf.nlist.lastSelectedIDs.difference(nids))
        add_nids = list(nids.difference(sf.nlist.lastSelectedIDs))
        deselect_rows = np.searchsorted(all_nids, remove_nids)
        select_rows = np.searchsorted(all_nids, add_nids)
        nlist = sf.nlist
        [ nlist.Select(row, on=False) for row in deselect_rows ]
        [ nlist.Select(row, on=True) for row in select_rows ]

    def OnDim(self, evt=None):
        """Update cluster widgets based on current cluster and dims,
        and replot the data in the (potentially) new projection, while
        maintaining the colour of each point"""
        cf = self.frames['cluster']
        scalars = cf.glyph.mlab_source.scalars # save scalars
        self.OnClusterPlot() # replot
        cf.glyph.mlab_source.scalars = scalars # restore scalars
        cf.glyph.mlab_source.update() # make scalar changes visible
        try:
            cluster = self.GetCluster()
            self.UpdateParamWidgets(cluster)
        except RuntimeError:
            # no cluster currently selected, like when changing dim before
            # any clusters have been created
            pass

    def OnFocusCurrentCluster(self, evt=None):
        """Focus button press in cluster_pane. Move focus to location
        of currently selected (single) cluster"""
        cluster = self.GetCluster()
        cf = self.frames['cluster']
        dims = self.GetClusterPlotDimNames()
        fp = [ cluster.pos[dim] for dim in dims ]
        cf.f.scene.camera.focal_point = fp
        cf.f.render() # update the scene, see SpykeMayaviScene.OnKeyDown()
        #cf.Refresh() # this also seems to work: repaint the frame

    def OnFocusCurrentSpike(self, evt=None):
        """Focus button press in sort_pane. Move focus to location
        of currently selected (single) spike"""
        sid = self.GetSpike()
        cf = self.frames['cluster']
        dims = self.GetClusterPlotDimNames()
        fp = self.sort.get_param_matrix(dims=dims)[sid]
        cf.f.scene.camera.focal_point = fp
        cf.f.render() # update the scene, see SpykeMayaviScene.OnKeyDown()
        #cf.Refresh() # this also seems to work: repaint the frame

    def MoveCurrentCluster2Focus(self):
        """Sets the position of the currently selected cluster to
        the point in 3D where the scene's camera is currently focused"""
        cluster = self.GetCluster()
        cf = self.frames['cluster']
        fp = cf.f.scene.camera.focal_point
        dims = self.GetClusterPlotDimNames()
        for dim, val in zip(dims, fp):
            cluster.pos[dim] = val
        cluster.update_ellipsoid('pos', dims=dims)
        self.UpdateParamWidgets(cluster)

    def OnClusterPlot(self, evt=None):
        """Plot button press in cluster_pane. Don't need the evt"""
        dims = self.GetClusterPlotDimNames()
        cf = self.OpenFrame('cluster') # in case it isn't already open
        X = self.sort.get_param_matrix(dims=dims)
        #X = self.sort.get_component_matrix(dims=dims, weighting='pca')
        if len(X) == 0:
            return # nothing to plot
        cf.glyph = cf.plot(X)
        # update all ellipsoids
        cf.f.scene.disable_render = True # turn rendering off for speed
        clusters = self.sort.clusters.values()
        for cluster in clusters:
            cluster.update_ellipsoid(dims=dims)
        self.UpdateClustersGUI()
        self.cluster_params_pane.Enable(True)

    def OnCutCluster(self, evt=None):
        """Cut (cluster) button press in cluster_pane. Don't need the evt"""
        cluster = self.GetCluster()
        self.CutClusters(cluster)

    def OnCutAllClusters(self, evt=None):
        """Cut all (cluster) button press in cluster_pane. Don't need the evt"""
        self.CutClusters(self.sort.clusters.values())

    def CutClusters(self, clusters):
        """Apply the cluster params to the spikes. Cut the spikes and
        update the plot"""
        sf = self.frames['sort']
        for cluster in toiter(clusters):
            neuron = cluster.neuron
            # reset scalar values for cluster's existing points
            # TODO: decolour only those points that are being removed
            self.DeColourPoints(neuron.sids)
            # remove any existing spikes from neuron and restore them to spike listctrl:
            sf.MoveSpikes2List(neuron, neuron.sids)
            sids = self.sort.cut_cluster(cluster)
            sf.MoveSpikes2Neuron(sids, neuron)
        # TODO: colour only those points that have been added
        self.ColourPoints(clusters)

    def UpdateClustersGUI(self):
        """Update lots of stuff after modifying clusters,
        here as a separate method for speed, only call when really needed"""
        s = self.sort
        sf = self.frames['sort']
        cf = self.frames['cluster']
        cf.f.scene.disable_render = False # turn rendering back on
        self.clist.SetItemCount(len(s.clusters))
        self.clist.RefreshItems()
        #self.clist.DeSelectAll() # not sure why this was here
        sf.nlist.SetItemCount(len(s.neurons))
        sf.nlist.RefreshItems()
        s.update_usids()
        sf.slist.SetItemCount(len(s.usids))
        sf.slist.RefreshItems() # refresh the list

    def ColourPoints(self, clusters):
        """Colour the points that fall within each cluster (as specified
        by cluster.neuron.sids) the same colour as the cluster itself"""
        clusters = toiter(clusters)
        cf = self.frames['cluster']
        for cluster in clusters:
            neuron = cluster.neuron
            cf.glyph.mlab_source.scalars[neuron.sids] = neuron.id % len(CMAP)
        t0 = time.time()
        cf.glyph.mlab_source.update() # make the trait update, only call it once to save time
        print('glyph.mlab_source.update() call took %.3f sec' % ((time.time()-t0)))

    def DeColourPoints(self, sids):
        """Restore spike point colour in cluster plot at spike indices to unclustered WHITE.
        Don't forget to call cf.glyph.mlab_source.update() after calling this"""
        cf = self.frames['cluster']
        cf.glyph.mlab_source.scalars[sids] = np.tile(TRANSWHITEI, len(sids))

    def DeColourAllPoints(self):
        """Restore all spike points in cluster plot to unclustered WHITE.
        Don't forget to call cf.glyph.mlab_source.update() after calling this"""
        cf = self.frames['cluster']
        cf.glyph.mlab_source.scalars = np.tile(TRANSWHITEI, self.sort.nspikes)

    def GetClusterPlotDimNames(self):
        """Return 3-tuple of strings of cluster dimension names, in (x, y, z) order"""
        x = self.xdim.GetStringSelection()
        y = self.ydim.GetStringSelection()
        z = self.zdim.GetStringSelection()
        return x, y, z

    def UpdateParamWidgets(self, cluster):
        """Update 3x3 grid of cluster param widgets from values in cluster"""
        x, y, z = self.GetClusterPlotDimNames() # tuple of dim names, in (x, y, z) order
        self.xpos.SetValue(str(cluster.pos[x]))
        self.ypos.SetValue(str(cluster.pos[y]))
        self.zpos.SetValue(str(cluster.pos[z]))
        if (y, z) in cluster.ori[x]: self.xori.SetValue(str(cluster.ori[x][(y, z)]))
        elif (z, y) in cluster.ori[x]: self.xori.SetValue(str(-cluster.ori[x][(z, y)]))
        else: self.xori.SetValue(str(0))
        if (z, x) in cluster.ori[y]: self.yori.SetValue(str(cluster.ori[y][(z, x)]))
        elif (x, z) in cluster.ori[y]: self.yori.SetValue(str(-cluster.ori[y][(x, z)]))
        else: self.yori.SetValue(str(0))
        if (x, y) in cluster.ori[z]: self.zori.SetValue(str(cluster.ori[z][(x, y)]))
        elif (y, x) in cluster.ori[z]: self.zori.SetValue(str(-cluster.ori[z][(y, x)]))
        else: self.zori.SetValue(str(0))
        self.xscale.SetValue(str(cluster.scale[x]))
        self.yscale.SetValue(str(cluster.scale[y]))
        self.zscale.SetValue(str(cluster.scale[z]))

    """Update parameters for currently selected cluster, and associated ellipsoid"""
    def OnXPos(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.pos[x] = val
        cluster.update_ellipsoid('pos', dims=(x, y, z))

    def OnYPos(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.pos[y] = val
        cluster.update_ellipsoid('pos', dims=(x, y, z))

    def OnZPos(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.pos[z] = val
        cluster.update_ellipsoid('pos', dims=(x, y, z))

    def OnXOri(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        if (z, y) in cluster.ori[x]: # reversed axes already used as a key
            cluster.ori[x][(z, y)] = -val # reverse the ori
        else:
            cluster.ori[x][(y, z)] = val # add or overwrite non-reversed axes entry
        cluster.update_ellipsoid('ori', dims=(x, y, z))

    def OnYOri(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        if (x, z) in cluster.ori[y]:
            cluster.ori[y][(x, z)] = -val
        else:
            cluster.ori[y][(z, x)] = val
        cluster.update_ellipsoid('ori', dims=(x, y, z))

    def OnZOri(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        if (y, x) in cluster.ori[z]:
            cluster.ori[z][(y, x)] = -val
        else:
            cluster.ori[z][(x, y)] = val
        cluster.update_ellipsoid('ori', dims=(x, y, z))

    def OnXScale(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.scale[x] = val
        cluster.update_ellipsoid('scale', dims=(x, y, z))

    def OnYScale(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.scale[y] = val
        cluster.update_ellipsoid('scale', dims=(x, y, z))

    def OnZScale(self, evt):
        cluster = self.GetCluster()
        x, y, z = self.GetClusterPlotDimNames()
        val = float(evt.GetString())
        cluster.scale[z] = val
        cluster.update_ellipsoid('scale', dims=(x, y, z))

    def OnKeyDown(self, evt):
        """Handle key presses
        TODO: might be able to clean this up by having a handler for wx.EVT_NAVIGATION_KEY
        """
        key = evt.GetKeyCode()
        #print 'key: %r' % key
        in_widget = evt.GetEventObject().ClassName in ['wxComboBox', 'wxSpinCtrl', 'wxSlider']
        in_file_pos_combo_box = evt.GetEventObject() == self.file_pos_combo_box
        if not evt.ControlDown():
            if key == wx.WXK_LEFT and not in_widget or key == wx.WXK_DOWN and in_file_pos_combo_box:
                    self.seek(self.t - self.hpstream.tres)
            elif key == wx.WXK_RIGHT and not in_widget or key == wx.WXK_UP and in_file_pos_combo_box:
                    self.seek(self.t + self.hpstream.tres)
            elif key == wx.WXK_PRIOR: # PGUP
                self.seek(self.t - (self.spiketw[1]-self.spiketw[0])) # go back 1 spike frame temporal window width
            elif key == wx.WXK_NEXT: # PGDN
                self.seek(self.t + (self.spiketw[1]-self.spiketw[0])) # go forward 1 spike frame temporal window width
            elif key == wx.WXK_F2: # search for previous spike
                self.findspike(which='previous')
            elif key == wx.WXK_F3: # search for next spike
                self.findspike(which='next')
        else: # CTRL is down
            if key == wx.WXK_PRIOR: # PGUP
                self.seek(self.t - (self.charttw[1]-self.charttw[0])) # go back 1 chart frame temporal window width
            elif key == wx.WXK_NEXT: # PGDN
                self.seek(self.t + (self.charttw[1]-self.charttw[0])) # go forward 1 chart frame temporal window width
        # when key event comes from file_pos_combo_box, reserve down/up for seeking through file
        if in_widget and not in_file_pos_combo_box or in_file_pos_combo_box and key not in [wx.WXK_DOWN, wx.WXK_UP]:
            evt.Skip() # pass event on to OS to handle cursor movement

    def OnMerge(self, evt=None):
        """Cluster pane merge button (^) click. For simple merging of clusters, easier to
        use than running climb() on selected clusters using a really big sigma to force
        them to all merge"""
        s = self.sort
        spikes = s.spikes
        sf = self.OpenFrame('sort')
        cf = self.OpenFrame('cluster')
        clusters = self.GetClusters()
        sids = [] # spikes to merge
        for cluster in clusters:
            sids.append(cluster.neuron.sids)
        sids = np.concatenate(sids)

        # save undo stuff
        self.clusterstate = spyke.cluster.ClusterState() # overwrite any previous one
        cs = self.clusterstate
        cs.sids = sids
        cs.oldnids = spikes['nid'][sids]
        cs.oldunids = [ cluster.id for cluster in clusters ]
        cs.positions = [ cluster.pos.copy() for cluster in clusters ]
        cs.scales = [ cluster.scale.copy() for cluster in clusters ]

        # delete original clusters
        self.SelectClusters(clusters, on=False) # deselect original clusters
        cf.f.scene.disable_render = True # for speed
        for cluster in clusters:
            self.DelCluster(cluster, update=False) # del original clusters
        self.DeColourPoints(sids) # decolour all points belonging to old clusters

        # create new cluster
        t0 = time.time()
        newnid = min([ nid for nid in cs.oldunids ]) # merge into lowest cluster
        newcluster = self.OnAddCluster(update=False, id=newnid)
        neuron = newcluster.neuron
        sf.MoveSpikes2Neuron(sids, neuron, update=False)
        plotdims = self.GetClusterPlotDimNames()
        plotdata = s.get_param_matrix(dims=plotdims, scale=True)[sids]
        for plotdimi, plotdim in enumerate(plotdims):
            points = plotdata[:, plotdimi]
            newcluster.pos[plotdim] = points.mean()
            newcluster.scale[plotdim] = points.std() or newcluster.scale[plotdim]
        newcluster.update_ellipsoid(params=['pos', 'scale'], dims=plotdims)

        # save for undo
        cs.newunids = [newnid]

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(newcluster)
        print('applying clusters to plot took %.3f sec' % (time.time()-t0))
        # select newly created cluster
        self.SelectClusters(newcluster, on=True)
        print('merged clusters %r into cluster %d' % (cs.oldunids, newnid))

    def OnClimb(self, evt=None):
        """Cluster pane Climb button click"""
        s = self.sort
        spikes = s.spikes
        sf = self.OpenFrame('sort')
        cf = self.OpenFrame('cluster')

        oldclusters = self.GetClusters()
        if oldclusters: # some clusters selected
            clusters = oldclusters
            sids = [] # spikes to run climb() on
            for oldcluster in oldclusters:
                sids.append(oldcluster.neuron.sids)
            sids = np.concatenate(sids) # run climb() on selected spikes
        else: # no clusters selected
            clusters = s.clusters.values() # all clusters
            sids = spikes['id'] # run climb() on all spikes

        # grab dims and data
        dimselis = self.dimlist.getSelection()
        dims = [ self.dimlist.dims[dimi] for dimi in dimselis ] # dim names to cluster upon
        if len(dims) == 0: raise RuntimeError('No cluster dimensions selected')
        plotdims = self.GetClusterPlotDimNames()
        waveclustering = 'wave' in dims or 'peaks' in dims
        if waveclustering: # do maxchan wavefrom clustering
            if len(dims) > 1:
                raise RuntimeError("Can't do high-D clustering of spike maxchan waveforms in tandem with any other spike parameters as dimensions")
            wctype = dims[0] # 'wave' or 'peaks'
            data = self.get_waveclustering_data(sids, wctype=wctype)
            plotdata = s.get_param_matrix(dims=plotdims, scale=True)[sids]
        else: # do spike parameter (non-wavefrom) clustering
            data = s.get_param_matrix(dims=dims, scale=True)[sids]
        data = data.copy() # copy to make it contiguous for climb()

        # grab climb() params and run it
        self.update_sort_from_cluster_pane()
        npoints, ndims = data.shape
        s.sigmasqrtndims = s.sigma * np.sqrt(ndims)
        print('clustering %d points in %d-D space' % (npoints, ndims))
        t0 = time.time()
        results = climb(data, sigma=s.sigmasqrtndims, alpha=s.alpha, rmergex=s.rmergex,
                        rneighx=s.rneighx, nsamples=s.nsamples,
                        calcpointdensities=False, calcscoutdensities=False,
                        minmove=-1.0, maxstill=s.maxstill, maxnnomerges=1000,
                        minpoints=s.minpoints)
        cids, scoutpositions, densities, scoutdensities, sampleis = results
        nids = list(np.unique(cids))
        try: nids.remove(-1)
        except ValueError: pass
        print('climb took %.3f sec' % (time.time()-t0))

        # save undo stuff, this is done as late as possible to delay overwriting any
        # previous cluster state for as long as possible
        self.clusterstate = spyke.cluster.ClusterState() # overwrite any previous one
        cs = self.clusterstate
        cs.sids = sids
        cs.oldnids = spikes['nid'][sids]
        cs.oldunids = [ cluster.id for cluster in clusters ]
        cs.positions = [ cluster.pos.copy() for cluster in clusters ]
        cs.scales = [ cluster.scale.copy() for cluster in clusters ]

        if oldclusters: # some clusters selected
            self.SelectClusters(oldclusters, on=False) # deselect original clusters
            cf.f.scene.disable_render = True # for speed
            for oldcluster in oldclusters:
                self.DelCluster(oldcluster, update=False) # del original clusters
            self.DeColourPoints(sids) # decolour all points belonging to old clusters
        else: # no clusters selected, delete all existing clusters (if any)
            for cluster in s.clusters.values():
                self.DelCluster(cluster, update=False)
            try: cf.glyph
            except AttributeError: self.OnClusterPlot()
            self.DeColourAllPoints()
            s.sampleis = sampleis

        # apply the clusters to the cluster plot
        newclusters = []
        t0 = time.time()
        for nid, pos in zip(nids, scoutpositions): # nids are sorted
            ii, = np.where(cids == nid)
            nsids = sids[ii] # sids belonging to this nid
            cluster = self.OnAddCluster(update=False)
            newclusters.append(cluster)
            neuron = cluster.neuron
            sf.MoveSpikes2Neuron(nsids, neuron, update=False)
            if len(nsids) == 0:
                raise RuntimeError('WARNING: neuron %d has no spikes for some reason' % neuron.id)
            if waveclustering: # set pos and scale in plotdims using mean and std of points
                for plotdimi, plotdim in enumerate(plotdims):
                    points = plotdata[ii, plotdimi]
                    cluster.pos[plotdim] = points.mean()
                    cluster.scale[plotdim] = points.std() or cluster.scale[plotdim]
            else: # set pos and scale in cluster dims using cluster pos and std of points
                for dimi, dim in enumerate(dims):
                    cluster.pos[dim] = pos[dimi]
                    cluster.scale[dim] = data[ii, dimi].std() or cluster.scale[dim]
            cluster.update_ellipsoid(params=['pos', 'scale'], dims=plotdims)

        # save more undo stuff
        cs.newunids = [ newcluster.id for newcluster in newclusters ]

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(newclusters)
        print('applying clusters to plot took %.3f sec' % (time.time()-t0))

        if oldclusters: # select newly created cluster(s)
            self.SelectClusters(newclusters, on=True)

    def get_waveclustering_data(self, sids, wctype='wave'):
        s = self.sort
        spikes = s.spikes

        # find which chans are common to all selected spikes
        chanss = spikes['chans'][sids]
        nchanss = spikes['nchans'][sids]
        chanslist = [ chans[:nchans] for chans, nchans in zip(chanss, nchanss) ] # list of arrays
        clusterable_chans = core.intersect1d(chanslist) # find intersection

        # decide which is the definitive maxchan for the selected spikes
        maxchans = spikes['chan'][sids]
        # cluster by default on most common maxchan
        maxchan = int(scipy.stats.mode(maxchans)[0][0])
        chans = [maxchan]

        # pop up dialog asking for chans to cluster on
        string = wx.GetTextFromUser('Cluster by %s on which channel(s)?\nChoose from: %r'
                                    % (wctype, list(clusterable_chans)),
                                    'Waveform (%s) clustering' % wctype, str(chans))
        if string == '':
            raise RuntimeError('cancelled') # cancel was pressed
        if string == '[]':
            chans = clusterable_chans
        else:
            chans = np.asarray(eval(string))
            chans.sort()
        for chan in chans:
            if chan not in clusterable_chans:
                raise RuntimeError("chan %d not common to all spikes, pick from %r"
                                   % (chan, list(clusterable_chans)))

        # copy selected chans as string to clipboard for easy user re-pasting next time
        chans_string = wx.TextDataObject(str(list(chans)))
        if wx.TheClipboard.Open():
            wx.TheClipboard.SetData(chans_string)
            wx.TheClipboard.Close()

        print('clustering upon chans = %r' % list(chans))
        nspikes = len(sids)
        nchans = len(chans)
        nt = s.wavedata.shape[2]
        # collect data from 'chans' from all spikes:
        data = np.zeros((nspikes, nchans, nt), dtype=np.float32)
        for sii, sid in enumerate(sids):
            spikechans = chanslist[sii]
            spikechanis = np.searchsorted(spikechans, chans)
            data[sii] = s.wavedata[sid, spikechanis]

        # find mean waveform of selected spikes
        template = data.mean(axis=0)

        if wctype == 'wave':
            # use all data from dt/2 before 1st peak to dt/2 after 2nd peak
            chani, = np.where(chans == maxchan)
            if not chani: # maxchan wasn't included in chans,  find chan with biggest value
                chani = np.unravel_index(template.argmax(), template.shape)[0]
            peaktis = np.asarray([template[chani].argmin(), template[chani].argmax()])
            peaktis.sort() # keep in temporal order
            dt2 = intround((peaktis[1] - peaktis[0]) / 2.0)
            wavetis = np.arange(max(peaktis[0]-dt2, 0), min(peaktis[1]+dt2, nt-1))
            wavetis = list(wavetis[::2]) # take every other point
            # ensure peak points remain in wavetis
            if peaktis[0] not in wavetis:
                wavetis.append(peaktis[0])
            if peaktis[1] not in wavetis:
                wavetis.append(peaktis[1])
            wavetis = np.asarray(wavetis)
            wavetis.sort()
            print('peaktis = %r' % peaktis)
            print('wavetis = %r' % wavetis)
            # consider only data at wavetis
            data = data[:, :, wavetis].copy()
            #slicetis = np.asarray([max(peaktis[0]-dt2, 0), peaktis[1]+dt2+1])
            #print('slicetis = %r' % slicetis)
            # consider only data between slicetis, copy to make it contiguous
            #data = data[:, :, slicetis[0]:slicetis[1]].copy()
        elif wctype == 'peaks':
            # use only data at peaks of template, and before and after each peak
            # useful for faster clustering
            peaktis = np.zeros((nchans, 6), dtype=int)
            for chani in range(nchans):
                t1, t4 = np.sort([template[chani].argmin(), template[chani].argmax()])
                dt3 = intround((t4 - t1)/3.0) # 1/3 the distance between peaks
                t0 = max(t1-dt3, 0)
                t2 = min(t1+dt3, nt-1)
                t3 = max(t4-dt3, 0)
                t5 = min(t4+dt3, nt-1)
                peaktis[chani] = t0, t1, t2, t3, t4, t5
            print('peaktis =')
            print(peaktis)
            # grab each spike's data at these peak times, using fancy indexing
            # see core.rowtake() or util.rowtake_cy() for indexing explanation
            data = data[:, np.arange(nchans)[:, None], peaktis] # shape = nspikes, nchans, 2
        else:
            raise RuntimeError('unknown wctype %r' % wctype)

        data.shape = nspikes, -1 # reshape to 2D, ie flatten across chans

        # normalize by the std of the dim with the biggest std - this allows use of reasonable
        # value of sigma (~0.15), similar to param clustering, and independent of what the
        # amplifier gain was during recording
        norm = data.std(axis=0).max()
        data /= norm
        print('normalized waveform data by %f' % norm)
        return data

    def OnUndo(self, evt=None):
        """Cluster pane Undo button click. Undo previous climb"""
        s = self.sort
        spikes = s.spikes
        sf = self.OpenFrame('sort')
        cf = self.OpenFrame('cluster')
        try: cs = self.clusterstate
        except AttributeError: raise RuntimeError('nothing to undo')
        sids = cs.sids

        # delete newly added clusters
        newclusters = [ s.clusters[nid] for nid in cs.newunids ]
        self.SelectClusters(newclusters, on=False) # deselect new clusters
        cf.f.scene.disable_render = True # for speed
        for newcluster in newclusters:
            self.DelCluster(newcluster, update=False) # del new clusters
        self.DeColourPoints(sids) # decolour all points belonging to new clusters

        # restore relevant spike fields
        spikes['nid'][sids] = cs.oldnids

        # restore the old clusters
        oldclusters = []
        plotdims = self.GetClusterPlotDimNames()
        t0 = time.time()
        # NOTE: oldunids are not necessarily sorted
        for nid, pos, scale in zip(cs.oldunids, cs.positions, cs.scales):
            nsids = sids[cs.oldnids == nid] # sids belonging to this nid
            cluster = self.OnAddCluster(update=False, id=nid)
            oldclusters.append(cluster)
            neuron = cluster.neuron
            sf.MoveSpikes2Neuron(nsids, neuron, update=False)
            cluster.pos = pos
            cluster.scale = scale
            cluster.update_ellipsoid(params=['pos', 'scale'], dims=plotdims)

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(oldclusters)
        print('applying clusters to plot took %.3f sec' % (time.time()-t0))
        # select newly recreated oldclusters
        self.SelectClusters(oldclusters, on=True)
        del self.clusterstate # last cluster state no longer applicable
        print('undo complete')

    def update_sort_from_cluster_pane(self):
        s = self.sort
        s.sigma = float(self.sigma_text_ctrl.GetValue())
        s.rmergex = float(self.rmergex_text_ctrl.GetValue())
        s.alpha = float(self.alpha_text_ctrl.GetValue())
        s.nsamples = self.nsamples_spin_ctrl.GetValue()
        s.maxstill = self.maxstill_spin_ctrl.GetValue()
        s.minpoints = self.minpoints_spin_ctrl.GetValue()
        #s.density_thresh = float(self.density_thresh_text_ctrl.GetValue())

    def OpenFile(self, fname):
        """Open a .srf, .sort or .wave file"""
        ext = os.path.splitext(fname)[1]
        if ext == '.srf':
            self.OpenSurfFile(fname)
        elif ext == '.sort':
            self.OpenSortFile(fname)
        elif ext == '.wave':
            self.sort.wavedata = self.OpenWaveFile(fname)
        else:
            wx.MessageBox("%s is not a .srf, .sort or .wave file" % fname,
                          caption="Error", style=wx.OK|wx.ICON_EXCLAMATION)

    def OpenSurfFile(self, fname):
        """Open a .srf file, and update display accordingly"""
        if self.srff != None:
            self.CloseSurfFile() # in case a .srf file and frames are already open
        self.srff = surf.File(fname)
        # TODO: parsing progress dialog
        self.srff.parse()
        self.srffname = self.srff.fname # update
        self.SetTitle(self.srffname) # update the caption

        self.hpstream = self.srff.hpstream # highpass record (spike) stream
        self.lpstream = self.srff.lpstream # lowpassmultichan record (LFP) stream
        self.set_chans_enabled(self.hpstream.chans, enable=True)
        tww = self.spiketw[1]-self.spiketw[0] # window width
        self.t = int(round(self.hpstream.t0 + tww/2)) # set current time position in recording (us)

        self.CreateNewSort() # create a new Sort
        self.menubar.Enable(wx.ID_RASTERS, False) # disable until spikes exist

        self.SPIKEFRAMEWIDTH = self.hpstream.probe.ncols * SPIKEFRAMEWIDTHPERCOLUMN
        self.OpenFrame('spike')
        #self.OpenFrame('chart')
        #self.OpenFrame('lfp')
        #self.OpenFrame('sort')
        #self.OpenFrame('pyshell')
        # these happen in callAfterFrameInit:
        #self.ShowRef('tref')
        #self.ShowRef('vref')
        #self.ShowRef('caret')

        # self has focus, but isn't in foreground after opening data frames
        #self.Raise() # doesn't seem to bring self to foreground
        #wx.GetApp().SetTopWindow(self) # neither does this

        self.str2t = {'start': self.hpstream.t0,
                      'now': self.t, # FIXME: this won't track self.t automatically
                      'end': self.hpstream.tend}

        self.range = (self.hpstream.t0, self.hpstream.tend) # us
        self.file_pos_combo_box.SetValue(str(self.t))
        self.file_min_label.SetLabel(str(self.hpstream.t0))
        self.file_max_label.SetLabel(str(self.hpstream.tend))
        # set all slider values in number of interploated timepoints
        tres = self.hpstream.tres
        self.slider.SetRange(self.range[0] // tres,
                            (self.range[1]-self.range[0]) // tres) # shouldn't need to round
        self.slider.SetValue(self.t // tres)
        self.slider.SetLineSize(1)
        self.slider.SetPageSize((self.spiketw[1]-self.spiketw[0]) // tres)

        self.SetSampfreq(spyke.core.DEFHIGHPASSSAMPFREQ)
        self.SetSHCorrect(spyke.core.DEFHIGHPASSSHCORRECT)

        self.EnableSurfWidgets(True)

    def CreateNewSort(self):
        """Create a new Sort and bind it to self"""
        self.DeleteSort()
        self.sort = Sort(detector=None, # detector is assigned in OnDetect
                         stream=self.hpstream)
        self.EnableSortWidgets(True)

    def DeleteSort(self):
        """Delete any existing Sort"""
        try:
            # TODO: if Save button is enabled, check if Sort is saved,
            # if not, prompt to save
            print('deleting existing Sort and entries in list controls')
            clusters = self.sort.clusters # need it below
            #self.sort.spikes.resize(0, recheck=False) # doesn't work, doesn't own memory
            del self.sort
        except AttributeError:
            pass
        if 'sort' in self.frames:
            sf = self.frames['sort']
            sf.nlist.DeleteAllItems()
            sf.nslist.DeleteAllItems()
            sf.slist.DeleteAllItems()
            sf.nlist.lastSelectedIDs = set()
            sf.nslist.lastSelectedIDs = set()
            sf.slist.lastSelectedIDs = set()
            sf.spikesortpanel.removeAllItems()
            #sf.chartsortpanel.removeAllItems()
        if 'cluster' in self.frames:
            cf = self.frames['cluster']
            cf.f.scene.disable_render = True # for speed
            for cluster in clusters.values():
                cluster.ellipsoid.remove() # from pipeline
                # no need to del cluster.ellipsoid, since all clusters are deleted when sort is deleted
            try:
                cf.glyph.remove() # from pipeline
                del cf.glyph # cluster frame hangs around, so del its glyph
            except AttributeError: pass
            cf.f.scene.disable_render = False
        self.clist.SetItemCount(0)
        self.clist.RefreshItems()
        self.total_nspikes_label.SetLabel(str(0))
        # make sure self.sort and especially self.sort.spikes is really gone
        # TODO: check if this is necessary once everything works with new streamlined
        # (no objects) spikes struct array
        gc.collect()

    def get_chans_enabled(self):
        return np.asarray([ chan for (chan, enable) in self._chans_enabled.iteritems() if enable ], dtype=np.uint8)

    def set_chans_enabled(self, chans, enable=None):
        """Updates which chans are enabled in ._chans_enabled dict and in the
        plot panels, and in the highpass stream. If enable is set, chans specifies
        which chans should have their enable flag overwritten. Otherwise,
        chans specifies all the chans we want enabled.
        The code for the 2nd case is quite elaborate, such that the visibility
        state of any given plot in all plotpanels isn't needlessly toggled,
        which slows things down and causes flicker, I think"""

        # inits and checks
        try:
            allchans = self.hpstream.chans # not sure if this needs to be copy()'d or not
        except AttributeError: # no hpstream yet
            allchans = []
        if chans == None: # None means all chans
            chans = allchans
        chans = toiter(chans) # need not be contiguous
        try:
            self._chans_enabled
        except AttributeError:
            self._chans_enabled = {} #dict(zip(allchans, [ True for chan in allchans ]))

        # overwrite enable flag of chans...
        if enable != None:
            for chan in chans:
                self._chans_enabled[chan] = enable
            for frametype in FRAMEUPDATEORDER:
                try:
                    self.frames[frametype].panel.enable_chans(chans, enable=enable)
                except KeyError: # frametype hasn't been opened yet
                    pass
        # ...or, leave only chans enabled
        else:
            enabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==True ]
            disabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==False ]
            notchans = set(allchans).difference(chans) # chans we don't want enabled
            # find the difference between currently enabled chans and the chans we want enabled
            chans2disable = set(enabledchans).difference(chans)
            # find the difference between currently disabled chans and the chans we want disabled
            chans2enable = set(disabledchans).difference(notchans)
            for chan in chans2enable:
                self._chans_enabled[chan] = True
            for chan in chans2disable:
                self._chans_enabled[chan] = False
            # now change the actual plots in the plotpanels
            for frametype in FRAMEUPDATEORDER:
                try:
                    self.frames[frametype].panel.enable_chans(chans2enable, enable=True)
                    self.frames[frametype].panel.enable_chans(chans2disable, enable=False)
                except KeyError: # frametype hasn't been opened yet
                    pass

        # update stream, might trigger change of stream type
        if self.hpstream != None:
            self.hpstream.chans = self.chans_enabled

    chans_enabled = property(get_chans_enabled, set_chans_enabled)

    def CloseSurfFile(self):
        """Destroy data and sort frames, clean up, close .srf file,
        and metaphorically, .sort file too"""
        # need to specifically get a list of keys, not an iterator,
        # since self.frames dict changes size during iteration
        for frametype in self.frames.keys():
            if frametype != 'pyshell': # leave pyshell frame alone
                self.CloseFrame(frametype) # deletes from dict
        for obj in [self.srff, self.hpstream, self.lpstream]:
            if obj: obj.close()
        self.hpstream = None
        self.lpstream = None
        self.chans_enabled = []
        self.t = None
        self.spiketw = DEFSPIKETW # reset
        self.charttw = DEFCHARTTW
        self.lfptw = DEFLFPTW
        self.ShowRasters(False) # reset
        self.SetTitle('spyke') # update caption
        self.EnableSurfWidgets(False)
        self.srff = None
        self.srffname = ''
        self.CloseSortFile()

    def CloseSortFile(self):
        self.DeleteSort()
        self.EnableSortWidgets(False)

    def OpenSortFile(self, fname):
        """Open a Sort from a .sort file, try and open a .wave file
        with the same name, restore the stream"""
        self.DeleteSort() # delete any existing Sort
        print('opening sort file %r' % fname)
        t0 = time.time()
        f = open(fname, 'rb')
        sort = cPickle.load(f)
        print('done opening sort file, took %.3f sec' % (time.time()-t0))
        print('sort file was %d bytes long' % f.tell())
        f.close()
        self.sort = sort
        sortProbeType = type(sort.probe)
        if self.hpstream != None:
            streamProbeType = type(self.hpstream.probe)
            if sortProbeType != streamProbeType:
                self.CreateNewSort() # overwrite the failed Sort
                raise RuntimeError(".sort file's probe type %r doesn't match .srf file's probe type %r"
                                   % (sortProbeType, streamProbeType))

        self.OpenSpikeFile(sort.spikefname)

        if self.hpstream != None:
            sort.stream = self.hpstream # restore missing stream object to Sort
        self.SetSampfreq(sort.sampfreq)
        self.SetSHCorrect(sort.shcorrect)
        self.ShowRasters(True) # turn rasters on and update rasters menu item now that we have a sort
        self.menubar.Enable(wx.ID_SAMPLING, False) # disable sampling menu
        if self.srff == None: # no .srf file is open
            self.notebook.Show(True) # lets us do stuff with the Sort
        self.total_nspikes_label.SetLabel(str(sort.nspikes))
        self.EnableSpikeWidgets(True)

        self.SPIKEFRAMEWIDTH = sort.probe.ncols * SPIKEFRAMEWIDTHPERCOLUMN
        sf = self.OpenFrame('sort') # ensure it's open
        # restore unsorted spike virtual listctrl
        sf.slist.SetItemCount(len(sort.usids))
        sf.slist.RefreshItems()

        # do this here first in case no clusters exist and hence self.AddCluster
        # is never called, yet you want spikes to be plotted in the cluster frame:
        cf = self.OpenFrame('cluster')
        try: cf.glyph # glyph already plotted?
        except AttributeError: self.OnClusterPlot() # create glyph on first open
        # try and reset camera view and roll to where it was last saved
        try: cf.view, cf.roll = sort.view, sort.roll
        except AttributeError: pass
        self.RestoreClusters2GUI()

        self.SetTitle(self.srffname + ' | ' + self.sort.sortfname)
        if sort.detector != None:
            self.update_from_detector(sort.detector)
        self.EnableSortWidgets(True)

    def OpenSpikeFile(self, fname):
        sort = self.sort
        print('loading spike file %r' % fname)
        t0 = time.time()
        f = open(fname, 'rb')
        spikes = np.load(f)
        print('done opening spike file, took %.3f sec' % (time.time()-t0))
        print('spike file was %d bytes long' % f.tell())
        f.close()
        sort.spikes = spikes
        # when loading a spike file, make sure the nid field is overwritten
        # in the spikes array. The nids in sort.neurons are always the definitive ones
        for neuron in sort.neurons.values():
            spikes['nid'][neuron.sids] = neuron.id
        sort.update_usids()
        # try loading .wave file of the same name
        wavefname = os.path.splitext(fname)[0] + '.wave'
        sort.wavedata = self.OpenWaveFile(wavefname)

    def OpenWaveFile(self, fname):
        """Open a .wave file and return wavedata array"""
        sort = self.sort
        print('opening wave file %r' % fname)
        t0 = time.time()
        try: f = open(fname, 'rb')
        except IOError:
            print("can't find file %r" % fname)
            return
        try:
            del sort.wavedata
            #gc.collect() # ensure memory is freed up to prepare for new wavedata, necessary?
        except AttributeError: pass
        wavedata = np.load(f)
        print('done opening wave file, took %.3f sec' % (time.time()-t0))
        print('wave file was %d bytes long' % f.tell())
        f.close()
        if len(wavedata) != sort.nspikes:
            wx.MessageBox('.wave file has a different number of spikes from the current Sort',
                          caption="Beware", style=wx.OK|wx.ICON_EXCLAMATION)
            raise RuntimeError
        return wavedata

    def RestoreClusters2GUI(self):
        """Stuff that needs to be done to synch the GUI with newly imported clusters"""
        # restore neuron clusters and the neuron listctrl
        for cluster in self.sort.clusters.values():
            self.AddCluster(cluster, update=False)
        self.UpdateClustersGUI()
        try:
            self.sort.spikes
            self.ColourPoints(self.sort.clusters.values()) # colour points for all clusters in one shot
        except AttributeError: pass # no spikes
        self.OpenFrame('sort')
        self.notebook.SetSelection(2) # switch to the cluster pane

    def ImportNeurons(self, fname):
        print('opening sort file %r to import neurons' % fname)
        t0 = time.time()
        f = open(fname, 'rb')
        sort = cPickle.load(f)
        print('done opening sort file, took %.3f sec' % (time.time()-t0))
        print('sort was %d bytes long' % f.tell())
        f.close()
        if len(sort.neurons) == 0:
            raise RuntimeError('sort in file %r has no neurons to import' % fname)
        # delete any existing clusters from GUI
        for cluster in self.sort.clusters.values():
            self.DelCluster(cluster, update=False)
        self.UpdateClustersGUI()
        # reset all plotted spike points to white
        cf = self.OpenFrame('cluster')
        try: # decolour any and all spikes
            cf.glyph # spikes glyph already plotted?
            self.DeColourAllPoints()
            self.frames['cluster'].glyph.mlab_source.update()
        except AttributeError: pass # no spikes glyph to decolour
        for neuron in sort.neurons.values():
            neuron.sids = np.array([], dtype=int) # clear spike indices of all imported neurons
            neuron.sort = self.sort # overwrite the sort neurons came from with current sort
        self.sort.neurons = sort.neurons
        self.sort.clusters = sort.clusters
        # TODO: import auto clustering output arrays too!
        self.RestoreClusters2GUI()

    def SaveSortFile(self, fname):
        """Save sort to a .sort file"""
        s = self.sort
        try: s.spikes
        except AttributeError: raise RuntimeError("Sort has no spikes to save")
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.sort'
        try: s.spikefname
        except AttributeError: # corresponding .spike filename hasn't been gemerated yet
            s.spikefname = os.path.splitext(fname)[0] + '.spike'
        self.SaveSpikeFile(s.spikefname) # always (re)save .spike when saving .sort
        #if not os.path.exists(s.spikefname): # corresponding .spike file was saved, but isn't there any more
        #    self.SaveSpikeFile(s.spikefname)
        print('saving sort file %r' % fname)
        t0 = time.time()
        f = open(fname, 'wb')
        try:
            cf = self.frames['cluster']
            # save camera view
            s.view, s.roll = cf.view, cf.roll
        except KeyError: pass # cf hasn't been opened yet, no camera view to save
        s.sortfname = fname # bind it now that it's about to be saved
        cPickle.dump(s, f, protocol=-1) # pickle with most efficient protocol
        f.close()
        print('done saving sort file, took %.3f sec' % (time.time()-t0))
        self.SetTitle(self.srffname + ' | ' + s.sortfname)

    def SaveSpikeFile(self, fname):
        """Save spikes to a .spike file"""
        s = self.sort
        try: s.spikes
        except AttributeError: raise RuntimeError("Sort has no spikes to save")
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.spike'
        try: s.wavefname
        except AttributeError: # corresponding .wave filename hasn't been generated yet
            wavefname = os.path.splitext(fname)[0] + '.wave'
            self.SaveWaveFile(wavefname) # only (re)save .wave if missing s.wavefname attrib
        #if not os.path.exists(s.wavefname): # corresponding .wave file is missing
        #    self.SaveWaveFile(s.wavefname)
        '''
        if os.path.exists(fname):
            dlg = wx.MessageDialog(self, "Spike file %r already exists. Overwrite?" % fname,
                                   "Overwrite .spike file?", wx.YES_NO | wx.ICON_QUESTION)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_NO:
                return
        '''
        print('saving spike file %r' % fname)
        t0 = time.time()
        f = open(fname, 'wb')
        np.save(f, s.spikes)
        f.close()
        print('done saving spike file, took %.3f sec' % (time.time()-t0))
        s.spikefname = fname # used to indicate that the spikes have been saved

    def SaveWaveFile(self, fname):
        """Save waveform data to a .wave file"""
        s = self.sort
        try: s.wavedata
        except AttributeError: return # no wavedata to save
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.wave'
        if os.path.exists(fname):
            dlg = wx.MessageDialog(self, "Wave file %r already exists. Overwrite?" % fname,
                                   "Overwrite .wave file?", wx.YES_NO | wx.ICON_QUESTION)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_NO:
                return
        print('saving wave file %r' % fname)
        t0 = time.time()
        f = open(fname, 'wb')
        np.save(f, s.wavedata)
        f.close()
        print('done saving wave file, took %.3f sec' % (time.time()-t0))
        s.wavefname = fname

    def OpenFrame(self, frametype):
        """Create and bind a frame, show it, plot its data if applicable"""
        if frametype not in self.frames: # check it doesn't already exist
            if frametype == 'spike':
                x = self.GetPosition()[0]
                y = self.GetPosition()[1] + self.GetSize()[1]
                frame = SpikeFrame(parent=self, stream=self.hpstream,
                                   tw=self.spiketw,
                                   pos=wx.Point(x, y), size=(self.SPIKEFRAMEWIDTH, SPIKEFRAMEHEIGHT))
                frame.panel.callAfterFrameInit() # post frame creation tasks for panel
            elif frametype == 'chart':
                x = self.GetPosition()[0] + self.SPIKEFRAMEWIDTH
                y = self.GetPosition()[1] + self.GetSize()[1]
                frame = ChartFrame(parent=self, stream=self.hpstream,
                                   tw=self.charttw, cw=self.spiketw,
                                   pos=wx.Point(x, y), size=CHARTFRAMESIZE)
                frame.panel.callAfterFrameInit() # post frame creation tasks for panel
            elif frametype == 'lfp':
                x = self.GetPosition()[0] + self.SPIKEFRAMEWIDTH + CHARTFRAMESIZE[0]
                y = self.GetPosition()[1] + self.GetSize()[1]
                frame = LFPFrame(parent=self, stream=self.lpstream,
                                 tw=self.lfptw, cw=self.charttw,
                                 pos=wx.Point(x, y), size=LFPFRAMESIZE)
                frame.panel.callAfterFrameInit() # post frame creation tasks for panel
            elif frametype == 'sort':
                x = self.GetPosition()[0] + self.GetSize()[0]
                y = self.GetPosition()[1]
                frame = SortFrame(parent=self, pos=wx.Point(x, y))
                for panel in [frame.spikesortpanel]:#, frame.chartsortpanel]:
                    panel.callAfterFrameInit(self.sort.probe) # post frame creation tasks for panel
            elif frametype == 'cluster':
                x = self.GetPosition()[0] + self.SPIKEFRAMEWIDTH
                y = self.GetPosition()[1] + self.GetSize()[1]
                from spyke.cluster import ClusterFrame # can't delay this any longer
                frame = ClusterFrame(parent=self, pos=wx.Point(x, y), size=CLUSTERFRAMESIZE)
            elif frametype == 'pyshell':
                try:
                    ncols = self.hpstream.probe.ncols
                except AttributeError:
                    ncols = 2 # assume 2 columns
                x = self.GetPosition()[0] + ncols*SPIKEFRAMEWIDTHPERCOLUMN
                y = self.GetPosition()[1] + self.GetSize()[1] + SPIKEFRAMEHEIGHT - PYSHELLSIZE[1]
                frame = PyShellFrame(parent=self, pos=wx.Point(x, y), size=PYSHELLSIZE)
            self.frames[frametype] = frame
            self.dpos[frametype] = frame.GetPosition() - self.GetPosition()
        self.ShowFrame(frametype)
        return self.frames[frametype] # 'frame' isn't necessarily in local namespace

    def ShowFrame(self, frametype, enable=True):
        """Show/hide a frame, force menu and toolbar states to correspond"""
        self.frames[frametype].Show(enable)
        id = self.FRAMETYPE2ID[frametype]
        self.menubar.Check(id, enable)
        self.toolbar.ToggleTool(id, enable)
        if enable and frametype not in ['sort', 'cluster', 'pyshell']:
            self.plot(frametype) # update only the newly shown data frame's data, in case self.t changed since it was last visible

    def HideFrame(self, frametype):
        self.ShowFrame(frametype, False)

    def ToggleFrame(self, frametype):
        """Toggle visibility of a data frame"""
        try:
            frame = self.frames[frametype]
            self.ShowFrame(frametype, not frame.IsShown()) # toggle it
        except KeyError: # frame hasn't been opened yet
            self.OpenFrame(frametype)

    def CloseFrame(self, frametype):
        """Hide frame, remove it from frames dict, destroy it"""
        self.HideFrame(frametype)
        frame = self.frames.pop(frametype)
        frame.Destroy()

    def ToggleWaveforms(self):
        raise NotImplementedError

    def ToggleRasters(self):
        """Toggle visibility of rasters"""
        enable = self.menubar.IsChecked(wx.ID_RASTERS) # maybe not safe, but seems to work
        self.ShowRasters(enable)

    def ShowRasters(self, enable=True):
        """Show/hide rasters for all applicable frames. Force menu states to correspond"""
        self.menubar.Check(wx.ID_RASTERS, enable)
        for frametype, frame in self.frames.iteritems():
            if frametype in ['spike', 'chart', 'lfp']:
                frame.panel.show_rasters(enable=enable)
                self.plot(frametype)

    def ToggleRef(self, ref):
        """Toggle visibility of tref, vref, or the caret"""
        enable = self.menubar.IsChecked(self.REFTYPE2ID[ref]) # maybe not safe, but seems to work
        self.ShowRef(ref, enable)

    def ShowRef(self, ref, enable=True):
        """Show/hide a tref, vref, or the caret. Force menu states to correspond"""
        self.menubar.Check(self.REFTYPE2ID[ref], enable)
        for frametype, frame in self.frames.iteritems():
            if frametype in ['spike', 'chart', 'lfp']:
                frame.panel.show_ref(ref, enable=enable)
            elif frametype == 'sort':
                frame.spikesortpanel.show_ref(ref, enable=enable)
                #frame.chartsortpanel.show_ref(ref, enable=enable)

    def SetSampfreq(self, sampfreq):
        """Set highpass stream sampling frequency, update widgets"""
        if self.hpstream != None:
            self.hpstream.sampfreq = sampfreq
            tres = self.hpstream.tres
            self.slider.SetRange(self.range[0] // tres,
                                (self.range[1]-self.range[0]) // tres) # shouldn't need to round
            self.slider.SetValue(self.t // tres)
            #self.slider.SetLineSize(1) # doesn't change
            self.slider.SetPageSize((self.spiketw[1]-self.spiketw[0]) // tres)
            self.plot()
        self.menubar.Check(self.SAMPFREQ2ID[sampfreq], True)

    def SetSHCorrect(self, enable):
        """Set highpass stream sample & hold correct flag, update widgets"""
        if self.hpstream != None:
            self.hpstream.shcorrect = enable
        self.menubar.Check(wx.ID_SHCORRECT, enable)
        self.plot()

    def EnableSurfWidgets(self, enable):
        """Enable/disable all widgets that require an open .srf file"""
        self.menubar.Enable(wx.ID_NEW, enable)
        self.menubar.Enable(wx.ID_SPIKEWIN, enable)
        self.menubar.Enable(wx.ID_CHARTWIN, enable)
        self.menubar.Enable(wx.ID_LFPWIN, enable)
        self.menubar.Enable(wx.ID_TREF, enable)
        self.menubar.Enable(wx.ID_VREF, enable)
        self.menubar.Enable(wx.ID_CARET, enable)
        self.menubar.Enable(wx.ID_SAMPLING, enable)
        self.menubar.Enable(wx.ID_WAVEFORMS, enable)
        self.toolbar.EnableTool(wx.ID_NEW, enable)
        self.toolbar.EnableTool(wx.ID_SPIKEWIN, enable)
        self.toolbar.EnableTool(wx.ID_CHARTWIN, enable)
        self.toolbar.EnableTool(wx.ID_LFPWIN, enable)
        self.file_pos_control_panel.Show(enable)
        self.notebook.Show(enable)
        self.detect_button.Enable(enable)
        self.file_min_label.Show(enable)
        self.file_max_label.Show(enable)

    def EnableSortWidgets(self, enable):
        """Enable/disable all widgets that require an "open" .sort file"""
        self.menubar.Enable(wx.ID_SORTWIN, enable)
        self.toolbar.EnableTool(wx.ID_SORTWIN, enable)
        self.menubar.Enable(wx.ID_CLUSTERWIN, enable)
        self.toolbar.EnableTool(wx.ID_CLUSTERWIN, enable)
        self.menubar.Enable(wx.ID_SAVE, enable)
        self.toolbar.EnableTool(wx.ID_SAVE, enable)
        self.menubar.Enable(wx.ID_RASTERS, enable)
        self.EnableSpikeWidgets(enable)

    def EnableSpikeWidgets(self, enable):
        """Enable/disable all widgets that require the current Sort to have spikes"""
        try:
            if len(self.sort.spikes) == 0: enable = False # no spikes
        except AttributeError: enable = False # self.sort doesn't exist yet
        self.extract_pane.Enable(enable)
        try: self.sort.extractor
        except AttributeError: enable = False # no params extracted, or .sort doesn't exist
        self.cluster_pane.Enable(enable)
        if enable: self.set_cluster_pane_defaults()
        try:
            if len(self.sort.clusters) == 0: enable = False # no clusters exist yet
        except AttributeError: enable = False
        self.cluster_params_pane.Enable(enable)
        try:
            if len(self.sort.neurons) == 0: enable = False # no neurons
        except AttributeError: enable = False # self.sort doesn't exist yet
        self.validate_pane.Enable(enable)

    def EnablePosOriScaleWidgets(self, enable):
        """Enable/disable the pos, ori, and scale textctrl widgets for controlling
        and displaying cluster params. Use this instead of self.cluster_pane.Enable()
        to allow the dims ComboBoxes to remain enabled for plotting purposes"""
        widgets = [self.xpos, self.ypos, self.zpos,
                   self.xori, self.yori, self.zori,
                   self.xscale, self.yscale, self.zscale]
        for widget in widgets:
            widget.Enable(enable)

    def get_detector(self):
        """Create a Detector object based on widget values"""
        det = detect.Detector(sort=self.sort)
        self.update_detector(det)
        return det

    def update_detector(self, det):
        """Update detector from detect pane widget values"""
        det.chans = self.chans_enabled
        if self.globalfixedthresh_radio_btn.GetValue():
            threshmethod = 'GlobalFixed'
        elif self.chanfixedthresh_radio_btn.GetValue():
            threshmethod = 'ChanFixed'
        elif self.dynamicthresh_radio_btn.GetValue():
            threshmethod = 'Dynamic'
        else:
            raise ValueError
        det.threshmethod = threshmethod
        det.fixedthreshuV = self.fixedthreshuV_spin_ctrl.GetValue()
        det.noisemult = float(self.noisemult_text_ctrl.GetValue())
        det.noisemethod = self.noise_method_choice.GetStringSelection()
        #det.noisewindow = self.noisewindow_spin_ctrl # not in the gui yet
        det.ppthreshmult = float(self.ppthreshmult_text_ctrl.GetValue())
        det.dt = self.dt_spin_ctrl.GetValue()
        det.trange = self.get_detectortrange()
        det.maxnspikes = self.nspikes_spin_ctrl.GetValue() or sys.maxint # if 0, use unlimited
        det.blocksize = int(self.blocksize_combo_box.GetValue())
        det.lockr = self.lockr_spin_ctrl.GetValue()
        det.inclr = self.inclr_spin_ctrl.GetValue()
        det.randomsample = self.random_sample_checkbox.GetValue()

    def update_from_detector(self, det):
        """Update self from detector attribs"""
        self.set_detectorthresh(det)
        self.chans_enabled = det.chans
        self.fixedthreshuV_spin_ctrl.SetValue(det.fixedthreshuV)
        self.noisemult_text_ctrl.SetValue(str(det.noisemult))
        #self.noisewindow_spin_ctrl.SetValue(det.noisewindow) # not in the gui yet
        self.range_start_combo_box.SetValue(str(det.trange[0]))
        self.range_end_combo_box.SetValue(str(det.trange[1]))
        if det.maxnspikes == sys.maxint:
            self.nspikes_spin_ctrl.SetValue(0) # represent unlimited with 0
        else:
            self.nspikes_spin_ctrl.SetValue(det.maxnspikes)
        self.blocksize_combo_box.SetValue(str(det.blocksize))
        self.lockr_spin_ctrl.SetValue(det.lockr)
        self.inclr_spin_ctrl.SetValue(det.inclr)
        self.random_sample_checkbox.SetValue(det.randomsample)

    def set_detectorthresh(self, det):
        """Update threshmethod radio buttons to match current Detector"""
        self.METH2RADIOBTN[det.threshmethod].SetValue(True) # enable the appropriate radio button

    def get_detectortrange(self):
        """Get detector time range from combo boxes, and convert
        start, now, and end to appropriate vals"""
        tstart = self.range_start_combo_box.GetValue()
        tend = self.range_end_combo_box.GetValue()
        try:
            tstart = self.str2t[tstart]
        except KeyError:
            tstart = int(float(tstart)) # convert to float first so you can use exp notation as shorthand
        try:
            tend = self.str2t[tend]
        except KeyError:
            tend = int(float(tend))
        return tstart, tend

    def findspike(self, which='next'):
        """Find next or previous spike, depending on direction"""
        det = self.sort.detector
        self.update_detector(det)
        det.maxnspikes = 1 # override whatever was in nspikes spin edit
        det.blocksize = 50000 # smaller blocksize, since we're only looking for 1 spike
        det.randomsample = False # ensure random sampling is turned off
        if which == 'next':
            det.trange = (self.t+1, self.hpstream.tend)
        elif which == 'previous':
            det.trange = (self.t-1, self.hpstream.t0)
        else:
            raise ValueError, which
        spikes, wavedata = det.detect() # don't bother saving it, don't update total_nspikes_label
        wx.SafeYield(win=self, onlyIfNeeded=True) # allow controls to update
        try: # if a spike was found
            spike = spikes[0]
            self.seek(spike['t']) # seek to it
            print('%r' % spike)
        except IndexError: # if not, do nothing
            pass

    def seek(self, offset=0):
        """Seek to position in surf file. offset is time in us"""
        self.oldt = self.t
        self.t = offset
        self.t = int(round(self.t / self.hpstream.tres)) * self.hpstream.tres # round to nearest (possibly interpolated) sample
        self.t = min(max(self.t, self.range[0]), self.range[1]) # constrain to within .range
        self.str2t['now'] = self.t # update
        # only plot if t has actually changed, though this doesn't seem to improve
        # performance, maybe mpl is already doing something like this?
        if self.t != self.oldt:
            # update controls first so they don't lag
            self.file_pos_combo_box.SetValue(str(self.t)) # update file combo box
            self.slider.SetValue(self.t // self.hpstream.tres) # update slider
            wx.SafeYield(win=self, onlyIfNeeded=True) # allow controls to update
            self.plot()
    '''
    def step(self, direction):
        """Step one timepoint left or right"""
        self.seek(self.t + direction*self.hpstream.tres)

    def page(self, direction):
        """Page left or right"""
        self.seek(self.t + direction*self.hpstream.tres)
    '''
    def tell(self):
        """Return current position in surf file"""
        return self.t

    def plot(self, frametypes=None):
        """Update the contents of all the data frames, or just specific ones.
        Center each data frame on self.t"""
        if frametypes == None: # update all visible frames
            frametypes = self.frames.keys()
        else: # update only specific frames, if visible
            frametypes = toiter(frametypes)
        frametypes = [ frametype for frametype in FRAMEUPDATEORDER if frametype in frametypes ] # reorder
        frames = [ self.frames[frametype] for frametype in frametypes ] # get frames in order
        for frametype, frame in zip(frametypes, frames):
            if frame.IsShown(): # for performance, only update if frame is shown
                if frametype == 'spike':
                    wave = self.hpstream[self.t+self.spiketw[0] : self.t+self.spiketw[1]]
                elif frametype == 'chart':
                    wave = self.hpstream[self.t+self.charttw[0] : self.t+self.charttw[1]]
                elif frametype == 'lfp':
                    wave = self.lpstream[self.t+self.lfptw[0] : self.t+self.lfptw[1]]
                frame.panel.plot(wave, tref=self.t) # plot it


class DataFrame(wx.MiniFrame):
    """Base data frame to hold a custom spyke panel widget.
    Copied and modified from auto-generated wxglade_gui.py code"""

    # no actual maximize button, but allows caption double-click to maximize
    # need SYSTEM_MENU to make close box appear in a TOOL_WINDOW, at least on win32
    STYLE = wx.CAPTION|wx.CLOSE_BOX|wx.MAXIMIZE_BOX|wx.SYSTEM_MENU|wx.RESIZE_BORDER|wx.FRAME_TOOL_WINDOW

    def __init__(self, *args, **kwds):
        kwds["style"] = self.STYLE
        wx.MiniFrame.__init__(self, *args, **kwds)

        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def set_properties(self):
        self.SetTitle("data window")
        self.SetSize((160, 24))

    def do_layout(self):
        dataframe_sizer = wx.BoxSizer(wx.HORIZONTAL)
        dataframe_sizer.Add(self.panel, 1, wx.EXPAND, 0)
        self.SetSizer(dataframe_sizer)
        self.Layout()

    def OnSize(self, evt):
        """Re-save reflines_background after resizing the frame"""
        # resize doesn't actually happen until after this handler exits,
        # so we have to CallAfter
        wx.CallAfter(self.DrawRefs)
        evt.Skip()

    def OnClose(self, evt):
        frametype = type(self).__name__.lower().replace('frame', '') # remove 'Frame' from class name
        self.Parent.HideFrame(frametype)

    def DrawRefs(self):
        """Redraws refs and resaves panel background"""
        self.panel.draw_refs()


class SpikeFrame(DataFrame):
    """Frame to hold the custom spike panel widget"""
    def __init__(self, parent=None, stream=None, tw=None, cw=None, *args, **kwds):
        DataFrame.__init__(self, parent, *args, **kwds)
        self.panel = SpikePanel(self, -1, stream=stream, tw=tw, cw=cw)

        self.set_properties()
        self.do_layout()

    def set_properties(self):
        self.SetTitle("spike window")


class ChartFrame(DataFrame):
    """Frame to hold the custom chart panel widget"""
    def __init__(self, parent=None, stream=None, tw=None, cw=None, *args, **kwds):
        DataFrame.__init__(self, parent, *args, **kwds)
        self.panel = ChartPanel(self, -1, stream=stream, tw=tw, cw=cw)

        self.set_properties()
        self.do_layout()

    def set_properties(self):
        self.SetTitle("chart window")


class LFPFrame(DataFrame):
    """Frame to hold the custom LFP panel widget"""
    def __init__(self, parent=None, stream=None, tw=None, cw=None, *args, **kwds):
        DataFrame.__init__(self, parent, *args, **kwds)
        self.panel = LFPPanel(self, -1, stream=stream, tw=tw, cw=cw)

        self.set_properties()
        self.do_layout()

    def set_properties(self):
        self.SetTitle("LFP window")


class PyShellFrame(wx.MiniFrame,
                   wx.py.shell.ShellFrame,
                   wx.py.frame.Frame,
                   wx.py.frame.ShellFrameMixin):
    """PyShell frame"""
    STYLE = wx.CAPTION|wx.CLOSE_BOX|wx.MAXIMIZE_BOX|wx.SYSTEM_MENU|wx.RESIZE_BORDER|wx.FRAME_TOOL_WINDOW

    def __init__(self, *args, **kwargs):
        """TODO: get my startup script to actually run on startup"""
        self.config = wx.FileConfig(localFilename=PYSHELLCFGFNAME) # get config fom file
        self.config.SetRecordDefaults(True)
        startupScript = 'pyshell_startup.py'
        title = 'spyke PyShell'
        kwargs['style'] = self.STYLE
        kwargs['title'] = title

        wx.MiniFrame.__init__(self, *args, **kwargs)
        wx.py.frame.ShellFrameMixin.__init__(self, config=self.config, dataDir=os.path.dirname(PYSHELLCFGFNAME))
        del kwargs['parent']
        del kwargs['title']
        self.shell = wx.py.shell.Shell(parent=self, id=-1, introText='',
                                       locals=None, InterpClass=None,
                                       startupScript=startupScript, # doesn't seem to work
                                       execStartupScript=True,
                                       *args, **kwargs)
        # Override the shell so that status messages go to the status bar.
        self.shell.setStatusText = self.SetStatusText

        self.shell.SetFocus()
        self.LoadSettings()

        self.CreateStatusBar()
        wx.py.frame.Frame._Frame__createMenus(self) # stupid __ name mangling, see Python docs

        self.iconized = False
        self.findDlg = None
        self.findData = wx.FindReplaceData()
        self.findData.SetFlags(wx.FR_DOWN)

        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_ICONIZE, self.OnIconize) # maybe this should be commented out?

        #self.shell.run('from __future__ import division')
        #self.shell.run('import numpy as np')
        #self.shell.runfile(startupScript)
        #self.shell.run('from '+startupScript+' import *')
        self.shell.run('self = app.spykeframe')
        #self.shell.run("sf = self.frames['sort']") # convenience
        #self.shell.run("cf = self.frames['cluster']") # convenience
        self.shell.run('s = self.sort') # convenience

    def OnClose(self, evt):
        frametype = self.__class__.__name__.lower().replace('frame', '') # remove 'Frame' from class name
        self.Parent.HideFrame(frametype)


class SpykeAbout(wx.Dialog):
    text = '''
        <html>
        <body bgcolor="#D4D0C8">
        <center><table bgcolor="#000000" width="100%" cellspacing="0"
        cellpadding="0" border="0">
        <tr>
            <td align="center"><h1><font color="#00FF00">spyke</font></h1></td>
        </tr>
        </table>
        </center>
        <p><b>spyke</b> is a tool for neuronal waveform visualization and spike sorting.
        </p>

        <p>Copyright &copy; 2008-2010 Martin Spacek, Reza Lotun<br>
           University of British Columbia</p>
        </body>
        </html>'''

    def __init__(self, parent):
        wx.Dialog.__init__(self, parent, -1, 'About spyke', size=(350, 260))

        html = wx.html.HtmlWindow(self)
        html.SetPage(self.text)
        button = wx.Button(self, wx.ID_OK, "OK")

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(html, 1, wx.EXPAND|wx.ALL, 5)
        sizer.Add(button, 0, wx.ALIGN_CENTER|wx.ALL, 5)

        self.SetSizer(sizer)
        self.Layout()


class SpykeApp(wx.App):
    def OnInit(self, splash=False):
        if splash:
            bmp = wx.Image("res/splash.png").ConvertToBitmap()
            wx.SplashScreen(bmp, wx.SPLASH_CENTRE_ON_SCREEN | wx.SPLASH_TIMEOUT, 1000, None, -1)
            wx.Yield()
        self.spykeframe = SpykeFrame(None)
        self.spykeframe.Show()
        self.SetTopWindow(self.spykeframe)

        # key presses aren't CommandEvents, and don't propagate up the window hierarchy, but
        # if left unhandled, are tested one final time here in the wx.App. Catch unhandled keypresses
        # here and call appropriate methods in the main spyke frame
        #self.Bind(wx.EVT_KEY_DOWN, self.spykeframe.OnKeyDown)

        return True


if __name__ == '__main__':
    app = SpykeApp(redirect=False) # output to stderr and stdout
    app.MainLoop()
