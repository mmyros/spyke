"""Main spyke window"""

from __future__ import division
from __init__ import __version__

__authors__ = ['Martin Spacek', 'Reza Lotun']

import numpy as np
import pyximport
pyximport.install()
from climbing import climb # .pyx file

from IPython import embed
from IPython.core import ultratb
from IPython.frontend.terminal.ipapp import load_default_config

from PyQt4 import QtCore, QtGui, uic
from PyQt4.QtCore import Qt
SpykeUi, SpykeUiBase = uic.loadUiType('spyke.ui')

import scipy.stats
import os
import sys
import platform
import time
import datetime
import gc
import cPickle
import random
from copy import copy

# seems unnecessary: automatically add spyke to path
#spykepath = os.path.split(os.getcwd())[0] # parent dir of cwd
#sys.path.insert(0, spykepath)

import core
from core import toiter, tocontig, intround, MICRO, ClusterChange, SpykeToolWindow
import surf
from sort import Sort, SortWindow, MAINSPLITTERPOS, MEANWAVESAMPLESIZE
from plot import SpikePanel, ChartPanel, LFPPanel, CMAP, GREYRGB
from detect import Detector
from extract import Extractor

DEFSPIKETW = -500, 500 # spike window temporal window (us)
DEFCHARTTW = -25000, 25000 # chart window temporal window (us)
DEFLFPTW = -500000, 500000 # lfp window temporal window (us)
SLIDERTRES = 100 # slider temporal resoluion (us), slider is limited to 2**32 ticks

SPIKEWINDOWWIDTHPERCOLUMN = 80
SPIKEWINDOWHEIGHT = 655
CHARTWINDOWSIZE = 900, SPIKEWINDOWHEIGHT
LFPWINDOWSIZE = 250, SPIKEWINDOWHEIGHT
METACITYHACK = 29 # metacity has vertical placement issues
SHELLSIZE = CHARTWINDOWSIZE[0], CHARTWINDOWSIZE[1]/2
CLUSTERWINDOWSIZE = 879, 687

WINDOWUPDATEORDER = ['Spike', 'LFP', 'Chart'] # chart goes last cuz it's slowest


class SpykeWindow(QtGui.QMainWindow):
    """spyke's main window, uses gui layout generated by QtDesigner"""
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        self.ui = SpykeUi()
        self.ui.setupUi(self) # lay it out
        self.move(0, 0) # top left corner, to make space for data windows

        self.dpos = {} # positions of data windows relative to main spyke window
        self.caption = '' # used for setting title caption
        self.path = os.getcwd() # init
        for d in ('~/data', '/data'): # use first existing of these paths, if any
            path = os.path.expanduser(d)
            if os.path.exists(path):
                self.path = path
                break
        self.windows = {} # holds spike, chart, lfp, sort, and shell windows
        self.spiketw = DEFSPIKETW # spike window temporal window (us)
        self.charttw = DEFCHARTTW # chart window temporal window (us)
        self.lfptw = DEFLFPTW # lfp window temporal window width (us)
        self.t = None # current time position in recording (us)

        self.hpstream = None
        self.lpstream = None

        self.cchanges = core.Stack() # cluster change stack, for undo/redo
        self.cci = -1 # pointer to cluster change for the next undo (add 1 for next redo)

        for rowi in range(3): # select the first 3 dims in dimlist
            # there really should be an easier way, but .setSelection(QRect, ...) doesn't work?
            #self.ui.dimlist.setCurrentRow(rowi, QtGui.QItemSelectionModel.Select)
            self.ui.dimlist.item(rowi).setSelected(True) # a little nicer
        '''
        # disable most widgets until a .srf or .sort file is opened
        self.EnableSurfWidgets(False)
        self.EnableSortWidgets(False)
        '''
        # TODO: load recent file history

    @QtCore.pyqtSlot()
    def on_actionNew_triggered(self):
        self.DeleteSort() # don't create a new one until spikes exist

    @QtCore.pyqtSlot()
    def on_actionOpen_triggered(self):
        getOpenFileName = QtGui.QFileDialog.getOpenFileName
        fname = getOpenFileName(self, caption="Open .srf, .track or .sort file",
                                directory=self.path,
                                filter="Surf, track & sort files (*.srf *.track *.sort);;"
                                       "All files (*.*)")
        fname = str(fname)
        if fname:
            head, tail = os.path.split(fname)
            self.path = head # update path
            self.OpenFile(tail)

    @QtCore.pyqtSlot()
    def on_actionSaveSort_triggered(self):
        try:
            self.SaveSortFile(self.sort.sortfname) # save to existing sort fname
        except AttributeError: # sort or sort.sortfname don't exist
            self.on_actionSaveSortAs_triggered()

    @QtCore.pyqtSlot()
    def on_actionSaveSortAs_triggered(self):
        """Save Sort to new .sort file"""
        try:
            defaultfname = self.sort.sortfname
        except AttributeError: # sort hasn't been previously saved
            # generate default fname with hpstream.fname and datetime
            fname = self.hpstream.fname.replace(' ', '_')
            dt = str(datetime.datetime.now()) # get an export timestamp
            dt = dt.split('.')[0] # ditch the us
            dt = dt.replace(' ', '_')
            dt = dt.replace(':', '.')
            defaultfname = fname + '_' + dt + '.sort'
        #defaultfname = self.join(defaultfname) # add path to it
        getSaveFileName = QtGui.QFileDialog.getSaveFileName
        fname = getSaveFileName(self, caption="Save .sort file",
                                directory=defaultfname,
                                filter="Sort files (*.sort);;"
                                       "All files (*.*)")
        fname = str(fname)
        if fname:
            base, ext = os.path.splitext(fname)
            if ext != '.sort':
                fname = base + '.sort' # make sure it has .sort extension
            head, tail = os.path.split(fname)
            self.path = head # update path
            # make way for new .spike and .wave files
            try: del self.sort.spikefname
            except AttributeError: pass
            try: del self.sort.wavefname
            except AttributeError: pass
            self.SaveSortFile(tail)

    @QtCore.pyqtSlot()
    def on_actionSaveParse_triggered(self):
        self.hpstream.pickle()

    @QtCore.pyqtSlot()
    def on_actionSaveWave_triggered(self):
        """Save waveforms to a .wave file"""
        defaultfname = os.path.splitext(self.sort.sortfname)[0] + '.wave'
        #defaultfname = self.join(defaultfname) # add path to it
        getSaveFileName = QtGui.QFileDialog.getSaveFileName
        fname = getSaveFileName(self, caption="Save .wave file",
                                directory=defaultfname,
                                filter="Wave files (*.wave);;"
                                       "All files (*.*)")
        fname = str(fname)
        if fname:
            head, tail = os.path.split(fname)
            self.path = head # update path
            self.SaveWaveFile(tail)

    @QtCore.pyqtSlot()
    def on_actionExportPtcsFiles_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export .ptcs file(s) to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exportptcsfiles(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionExportGdfFiles_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export .gdf file(s) to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exportgdffiles(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionExportSpikes_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export .spk files to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exportspikes(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionExportTsChId_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export tschid(s) to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exporttschid(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionExportDIN_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export DIN(s) to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exportdin(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionExportTextheader_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export textheader(s) to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exporttextheader(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionExportAll_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export spikes, DIN(s) and textheader(s) to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exportall(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionExportLFP_triggered(self):
        getExistingDirectory = QtGui.QFileDialog.getExistingDirectory
        path = getExistingDirectory(self, caption="Export LFP(s) to",
                                    directory=self.path)
        path = str(path)
        if path:
            self.sort.exportlfp(path)
            # don't update path

    @QtCore.pyqtSlot()
    def on_actionClose_triggered(self):
        # TODO: add confirmation dialog if Sort not saved
        self.CloseSurfOrTrackFile()

    @QtCore.pyqtSlot()
    def on_actionQuit_triggered(self):
        self.on_actionClose_triggered()
        self.close() # call close() before destroy() to avoid segfault
        self.destroy()

    @QtCore.pyqtSlot()
    def on_actionUndo_triggered(self):
        """Undo button click. Undo previous cluster change"""
        try:
            cc = self.cchanges[self.cci]
        except IndexError:
            print('nothing to undo')
            return
        print('undoing: %s' % cc.message)
        self.ApplyClusterChange(cc, direction='back')
        self.cci -= 1 # move pointer one change back on the stack
        print('undo complete')

    @QtCore.pyqtSlot()
    def on_actionRedo_triggered(self):
        """Redo button click. Redo next cluster change"""
        try:
            cc = self.cchanges[self.cci+1]
        except IndexError:
            print('nothing to redo')
            return
        print('redoing: %s' % cc.message)
        self.ApplyClusterChange(cc, direction='forward')
        self.cci += 1 # move pointer one change forward on the stack
        print('redo complete')

    @QtCore.pyqtSlot()
    def on_actionSpikeWindow_triggered(self):
        """Spike window toggle menu/button event"""
        self.ToggleWindow('Spike')

    @QtCore.pyqtSlot()
    def on_actionChartWindow_triggered(self):
        """Chart window toggle menu/button event"""
        self.ToggleWindow('Chart')

    @QtCore.pyqtSlot()
    def on_actionLFPWindow_triggered(self):
        """LFP window toggle menu/button event"""
        self.ToggleWindow('LFP')

    @QtCore.pyqtSlot()
    def on_actionSortWindow_triggered(self):
        """Sort window toggle menu/button event"""
        self.ToggleWindow('Sort')

    @QtCore.pyqtSlot()
    def on_actionClusterWindow_triggered(self):
        """Cluster window toggle menu/button event"""
        self.ToggleWindow('Cluster')

    @QtCore.pyqtSlot()
    def on_actionShell_triggered(self):
        """Shell window toggle menu/button event"""
        #self.ToggleWindow('Shell')
        # FIXME: this blocks until you Ctrl-D out of ipython:
        embed(display_banner=False, config=load_default_config()) # "self" is accessible
        # embed() seems to override the excepthook, need to reset it:
        set_excepthook()

    @QtCore.pyqtSlot()
    def on_actionWaveforms_triggered(self):
        """Spike waveforms toggle menu event"""
        self.ToggleWaveforms()

    @QtCore.pyqtSlot()
    def on_actionRasters_triggered(self):
        """Spike rasters toggle menu event"""
        self.ToggleRasters()

    @QtCore.pyqtSlot()
    def on_actionTimeRef_triggered(self):
        """Time reference toggle menu event"""
        self.ToggleRef('TimeRef')

    @QtCore.pyqtSlot()
    def on_actionVoltageRef_triggered(self):
        """Voltage reference toggle menu event"""
        self.ToggleRef('VoltageRef')

    @QtCore.pyqtSlot()
    def on_actionCaret_triggered(self):
        """Caret toggle menu event"""
        self.ToggleRef('Caret')

    def OnSampling(self, evt):
        """Sampling frequency menu choice event"""
        menuitem = self.menubar.FindItemById(evt.GetId())
        sampfreq = int(menuitem.GetLabel().rstrip(' kHz'))
        sampfreq *= 1000 # convert from kHz to Hz
        self.SetSampfreq(sampfreq)

    @QtCore.pyqtSlot()
    def on_actionSampleAndHoldCorrect_triggered(self):
        """Sample & hold menu event"""
        enable = self.ui.actionSampleAndHoldCorrect.isChecked()
        self.SetSHCorrect(enable)

    #def onFilePosLineEdit_textChanged(self, text): # updates immediately
    def on_filePosLineEdit_editingFinished(self): # updates on Enter/loss of focus
        text = str(self.ui.filePosLineEdit.text())
        try:
            t = self.str2t[text]
        except KeyError: # convert to float to allow exp notation shorthand
            t = float(text)
        self.seek(t)

    @QtCore.pyqtSlot()
    def on_actionAboutSpyke_triggered(self):
        text = """
        <h2>spyke %s</h2>
        <p>A tool for neuronal waveform visualization and spike sorting</p>
        <p>Copyright &copy; 2008-2011 Martin Spacek, Reza Lotun<br>
           University of British Columbia</p>
        <p>Python %s, Qt %s, PyQt %s<br>
        %s</p>""" % (__version__, platform.python_version(),
        QtCore.QT_VERSION_STR, QtCore.PYQT_VERSION_STR, platform.platform())
        QtGui.QMessageBox.about(self, "About spyke", text)

    @QtCore.pyqtSlot()
    def on_actionAboutQt_triggered(self):
        QtGui.QMessageBox.aboutQt(self)

    @QtCore.pyqtSlot()
    def on_filePosStartButton_clicked(self):
        self.seek(self.str2t['start'])

    @QtCore.pyqtSlot()
    def on_filePosEndButton_clicked(self):
        self.seek(self.str2t['end'])

    @QtCore.pyqtSlot(int)
    def on_slider_sliderMoved(self, slideri):
        self.seek(slideri * SLIDERTRES)

    @QtCore.pyqtSlot()
    def on_detectButton_clicked(self):
        """Detect pane Detect button click"""
        sort = self.CreateNewSort() # create a new Sort
        self.get_detector() # update Sort's current detector with new one from widgets
        if sort.detector.extractparamsondetect:
            self.init_extractor() # init the Extractor
        sort.spikes, sort.wavedata = sort.detector.detect() # struct array of spikes, 3D array
        sort.update_usids()
        sort.sampfreq = sort.stream.sampfreq # lock down sampfreq and shcorrect attribs
        sort.shcorrect = sort.stream.shcorrect
        sort.tres = sort.stream.tres # for convenience

        self.ui.progressBar.setFormat("%d spikes" % sort.nspikes)
        self.EnableSpikeWidgets(True)
        # disable sampling menu, don't want to allow sampfreq or shcorrect changes
        # now that we've had a detection run
        self.ui.menuSampling.setEnabled(False)
        self.ui.actionRasters.setEnabled(True) # enable raster menu, now that spikes exist
        self.ShowRasters() # show spike rasters for open data windows
        sw = self.OpenWindow('Sort') # ensure it's open
        self.EnableSpikeWidgets(True) # now that we (probably) have some spikes
        if sort.nspikes > 0:
            self.on_plotButton_clicked()

    def init_extractor(self):
        """Initialize Extractor"""
        #XYmethod = self.XY_extract_radio_box.GetStringSelection()
        XYmethod = 'Gaussian fit' # hard code for now, don't really need extract pane
        ext = Extractor(self.sort, XYmethod) # or eventually, self.get_extractor()
        self.sort.extractor = ext
        #self.update_extractor(ext) # eventually, update extractor from multiple Extract pane widgets

    def OnXYExtract(self, evt=None):
        """Extract pane XY Extract button click. Extracts (or re-extracts and
        overwrites) XY parameters from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        #import cProfile
        #cProfile.runctx('self.sort.extractor.extract_all_XY()', globals(), locals())

        self.sort.extractor.extract_all_XY() # adds extracted XY params to sort.spikes
        self.windows['Sort'].uslist.updateAll() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def OnWaveletExtract(self, evt=None):
        """Extract pane wavelet Extract button click. Extracts (or re-extracts and
        overwrites) wavelet coefficients from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        #import cProfile
        #cProfile.runctx('self.sort.extractor.extract_all_XY()', globals(), locals())

        # extract coeffs of selected wavelet type, add coeffs to sort.spikes
        wavelet = self.wavelet_extract_radio_box.GetStringSelection()
        self.sort.extractor.extract_all_wcs(wavelet)
        self.windows['Sort'].uslist.updateAll() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    def OnTemporalExtract(self, evt=None):
        """Extract pane temporal Extract button click. Extracts (or re-extracts and
        overwrites) temporal params from all sort.spikes, and stores
        them as spike attribs"""
        try:
            self.sort.extractor
        except AttributeError:
            self.init_extractor()

        self.sort.extractor.extract_all_temporal()
        self.windows['Sort'].uslist.updateAll() # update any columns showing param values
        self.EnableSpikeWidgets(True) # enable cluster_pane

    @QtCore.pyqtSlot()
    def on_clusterButton_clicked(self):
        """Cluster pane Cluster button click"""
        s = self.sort
        spikes = s.spikes
        sids = self.GetImplicitSpikes() # all selected spikes
        oldclusters = self.GetClusters() # all selected clusters
        if len(sids) == 0: # nothing selected
            sids = spikes['id'] # all spikes (sorted)
            oldclusters = s.clusters.values() # all clusters
        items = self.ui.dimlist.selectedItems()
        if len(items) == 0: raise RuntimeError('No cluster dimensions selected')
        dims = [ str(item.text()) for item in items ] # dim names to cluster on
        pcs = np.any([ dim.startswith('pc') for dim in dims ])
        subsidss = []
        msgs = []
        t0 = time.time()
        if pcs and np.all(sids == spikes['id']): # doing PCA on all spikes
            if oldclusters:
                # partition data by existing clusters before clustering,
                # restrict to only clustered spikes:
                for oldcluster in oldclusters:
                    subsidss.append(oldcluster.neuron.sids)
                    msgs.append('oldcluster %d' % oldcluster.id)
                sids = np.concatenate(subsidss) # update
                sids.sort()
            else: # partition data by maxchan before clustering, includes all sids
                maxchans = np.unique(spikes['chan'])
                for maxchan in maxchans:
                    subsids, = np.where(spikes['chan'] == maxchan)
                    subsidss.append(subsids)
                    msgs.append('maxchan %d' % maxchan)
        else: # just the selected spikes
            subsidss.append(sids)
            msgs.append('%d selected sids' % len(sids))
        nids = self.subcluster(sids, subsidss, msgs, dims)
        print('clustering took %.3f sec' % (time.time()-t0))
        self.apply_clustering(oldclusters, sids, nids, verb='climb')

    def subcluster(self, sids, subsidss, msgs, dims):
        """Perform (sub)clustering according to subsids in subsidss. Incorporate results
        from each (sub)clustering into a single nids output array"""
        nids = np.zeros(len(sids), dtype=np.int32) # init nids output array
        nids.fill(-1) # init all to be unclustered
        for subsids, msg in zip(subsidss, msgs):
            print('clustering %s on dims %r' % (msg, dims))
            subnids = self.climb(subsids, dims) # subclustering result
            ci = subnids != -1 # consider only the clustered sids
            subsids = subsids[ci]
            subnids = subnids[ci]
            nidoffset = max(nids) + 1
            nidsi = sids.searchsorted(subsids)
            nids[nidsi] = subnids + nidoffset
        return nids

    def chansplit(self):
        """Split spikes into clusters of unique channel combinations"""
        s = self.sort
        spikes = s.spikes
        sids = self.GetImplicitSpikes() # all selected spikes
        oldclusters = self.GetClusters() # all selected clusters
        if len(sids) == 0: # nothing selected
            sids = spikes['id'] # all spikes
            oldclusters = s.clusters.values() # all clusters
        t0 = time.time()
        chans = spikes[sids]['chans']
        chans = tocontig(chans) # string view won't work without contiguity
        strchans = chans.view('S%d' % (chans.itemsize*chans.shape[1])) # each row becomes a string
        # each row in uchancombos is a unique combination of chans:
        uchancombos = np.unique(strchans).view(chans.dtype).reshape(-1, chans.shape[1])
        if len(uchancombos) == 1:
            print("selected spikes all share the same set of channels, can't chansplit")
            return
        nids = np.zeros(len(sids), dtype=np.int32)
        nids.fill(-1) # -ve number indicates an unclustered point, shouldn't happen for chansplit
        for nid, uchancombo in enumerate(uchancombos):
            nids[(chans == uchancombo).all(axis=1)] = nid
        if (nids == -1).any():
            raise RuntimeError("there shouldn't be any unclustered points from chansplit")
        print('chansplit took %.3f sec' % (time.time()-t0))
        self.apply_clustering(oldclusters, sids, nids, verb='chansplit')

    def climb(self, sids, dims):
        """Cluster sids along dims, using NVS's mountain climbing algorithm"""
        s = self.sort
        waveclustering = np.any([ dim.startswith('peaks') for dim in dims ])
        if waveclustering: # do waveform clustering
            if len(dims) > 1:
                raise RuntimeError("Can't do high-D clustering of spike waveforms in tandem with any other spike parameters as dimensions")
            wctype = dims[0]
            try:
                data = self.get_waveclustering_data(sids, wctype=wctype)
            except RuntimeError as msg:
                print(msg)
                return
        else: # do spike parameter (non-wavefrom) clustering
            pcchans = self.windows['Sort'].panel.chans_selected
            pcchans.sort()
            data = s.get_param_matrix(dims=dims, sids=sids, pcchans=pcchans, scale=True)
        data = tocontig(data) # ensure it's contiguous for climb()
        # grab climb() params and run it
        self.update_sort_from_cluster_pane()
        npoints, ndims = data.shape
        s.sigmasqrtndims = s.sigma * np.sqrt(ndims)
        print('clustering %d points in %d-D space' % (npoints, ndims))
        t0 = time.time()
        results = climb(data, sigma=s.sigmasqrtndims, alpha=s.alpha,
                        rmergex=s.rmergex, rneighx=s.rneighx,
                        maxnnomerges=1000,
                        minpoints=s.minpoints)
        nids, scoutpositions = results
        print('climb took %.3f sec' % (time.time()-t0))
        return nids

    def apply_clustering(self, oldclusters, sids, nids, verb=''):
        """Replace old clusters and apply the clustering described by sids
        with their new nids"""
        s = self.sort
        spikes = s.spikes
        sw = self.windows['Sort']
        cw = self.windows['Cluster']
        
        # deselect selected clusters before potentially deleting unselected junk
        # cluster, to avoid lack of Qt selection event when selection values
        # (not rows) change. Also, deselect usids while we're at it:
        self.SelectClusters(oldclusters, on=False)
        sw.uslist.clearSelection()

        # delete junk cluster if it exists and is unselected,
        # add this deletion to cluster change stack
        if -1 not in [ c.id for c in oldclusters ] and -1 in s.clusters:
            # save some undo/redo stuff
            message = 'delete junk cluster -1'
            cc = ClusterChange(s.neurons[-1].sids, spikes, message)
            cc.save_old([s.clusters[-1]], s.norder)
            # delete it
            s.remove_neuron(-1)
            # save more undo/redo stuff
            cc.save_new([], s.norder)
            self.AddClusterChangeToStack(cc)
            print(cc.message)

        # save some undo/redo stuff
        message = '%s clusters %r' % (verb, [ c.id for c in oldclusters ])
        cc = ClusterChange(sids, spikes, message)
        cc.save_old(oldclusters, s.norder)

        # start insertion indices of new clusters from first selected cluster, if any
        unids = np.unique(nids)
        nnids = len(unids)
        insertis = [None] * nnids
        if len(oldclusters) > 0:
            startinserti = s.norder.index(oldclusters[0].id)
            insertis = range(startinserti, startinserti+nnids)

        # delete old clusters
        self.DelClusters(oldclusters, update=False)

        # apply new clusters
        newclusters = []
        for nid, inserti in zip(unids, insertis):
            ii, = np.where(nids == nid)
            nsids = sids[ii] # sids belonging to this nid
            if nid != -1:
                nid = None # auto generate a new nid
            cluster = self.CreateCluster(update=False, id=nid, inserti=inserti)
            newclusters.append(cluster)
            neuron = cluster.neuron
            sw.MoveSpikes2Neuron(nsids, neuron, update=False)
            if len(nsids) == 0:
                raise RuntimeError('WARNING: neuron %d has no spikes for some reason' % neuron.id)
            cluster.update_pos()

        # save more undo/redo stuff
        cc.save_new(newclusters, s.norder)
        self.AddClusterChangeToStack(cc)

        # now do some final updates
        self.UpdateClustersGUI()
        if not np.all(sids == spikes['id']): # if clustering only some spikes,
            self.SelectClusters(newclusters) # select all newly created cluster(s)
        if np.all(sids == cw.glWidget.sids):
            self.ColourPoints(newclusters) # just recolour
        else:
            self.on_plotButton_clicked() # need to do a full replot
        cc.message += ' into %r' % [c.id for c in newclusters]
        print(cc.message)

    def get_waveclustering_data(self, sids, wctype='wave'):
        s = self.sort
        spikes = s.spikes

        # find which chans are common to all sids
        chanss = spikes['chans'][sids]
        nchanss = spikes['nchans'][sids]
        chanslist = [ chans[:nchans] for chans, nchans in zip(chanss, nchanss) ] # array list
        clusterable_chans = core.intersect1d(chanslist) # find intersection

        # get selected chans
        chans = self.windows['Sort'].panel.chans_selected
        chans.sort()
        for chan in chans:
            if chan not in clusterable_chans:
                raise RuntimeError("chan %d not common to all spikes, pick from %r"
                                   % (chan, list(clusterable_chans)))
        nchans = len(chans)
        if nchans == 0:
            raise RuntimeError("no channels selected")
        print('clustering on chans %r' % list(chans))

        # collect data from chans from all spikes:
        nspikes = len(sids)
        nt = s.wavedata.shape[2]
        data = np.zeros((nspikes, nchans, nt), dtype=np.float32)
        for sii, sid in enumerate(sids):
            spikechans = chanslist[sii]
            spikechanis = np.searchsorted(spikechans, chans)
            data[sii] = s.wavedata[sid, spikechanis]

        # find mean waveform of selected spikes, randomly sampling first for speed
        # if nspikes exceeds a threshold
        if len(sids) > MEANWAVESAMPLESIZE:
            print('get_waveclustering_data() taking random sample of %d spikes for mean '
                  'instead of all %d of them' % (MEANWAVESAMPLESIZE, len(sids)))
            siis = np.arange(nspikes)
            subsiis = np.asarray(random.sample(siis, MEANWAVESAMPLESIZE))
            template = data[subsiis].mean(axis=0)
        else:
            template = data.mean(axis=0)

        # TODO: add stdev2, stdev6 and stdev10 that use the most variable points
        # per chan, or somehow, the most non-gaussian points per chan

        if wctype == 'peaks2':
            # use data at peaks of template
            ntis = 2
            tis = np.zeros((nchans, ntis), dtype=int)
            for chani in range(nchans):
                t0, t1 = np.sort([template[chani].argmin(), template[chani].argmax()])
                tis[chani] = t0, t1
        elif wctype == 'peaks6':
            # use data at peaks of template, and before and after each peak
            ntis = 6
            tis = np.zeros((nchans, ntis), dtype=int)
            for chani in range(nchans):
                t1, t4 = np.sort([template[chani].argmin(), template[chani].argmax()])
                dt3 = max((t4 - t1) / 3.0, 1) # 1/3 the distance between peaks
                t0 = max(t1-dt3, 0)
                t2 = min(t1+dt3, nt-1)
                t3 = max(t4-dt3, 0)
                t5 = min(t4+dt3, nt-1)
                tis[chani] = intround([t0, t1, t2, t3, t4, t5])
        elif wctype == 'peaks10':
            # use data at peaks of template, and before and after each peak
            ntis = 10
            tis = np.zeros((nchans, ntis), dtype=int)
            for chani in range(nchans):
                t2, t7 = np.sort([template[chani].argmin(), template[chani].argmax()])
                dt5 = max((t7 - t2) / 5.0, 1) # 1/5 the distance between peaks
                t0 = max(t2-2*dt5, 0)
                t1 = max(t2-dt5, 0)
                t3 = min(t2+dt5, nt-1)
                t4 = min(t2+2*dt5, nt-1)
                t5 = max(t7-2*dt5, 0)
                t6 = max(t7-dt5, 0)
                t8 = min(t7+dt5, nt-1)
                t9 = min(t7+2*dt5, nt-1)
                tis[chani] = intround([t0, t1, t2, t3, t4, t5, t6, t7, t8, t9])
        else:
            raise RuntimeError('unknown wctype %r' % wctype)

        print('tis =')
        print(tis)
        for chani in range(nchans):
            assert core.is_unique(tis[chani])
            # TODO: if it isn't unique, throw out the ti repeats per channel, and have
            # potentially a different number of tis per chan. Would have to change the
            # fancy indexing operation below...

        # grab each spike's data at tis, using fancy indexing
        # see core.rowtake() or util.rowtake_cy() for indexing explanation
        data = data[:, np.arange(nchans)[:, None], tis] # shape = nspikes, nchans, ntis
        data.shape = nspikes, -1 # reshape to 2D, ie flatten across chans

        # normalize by the std of the dim with the biggest std - this allows use of reasonable
        # value of sigma (~0.15), similar to param clustering, and independent of what the
        # amplifier gain was during recording
        norm = data.std(axis=0).max()
        data /= norm
        print('normalized waveform data by %f' % norm)
        return data

    @QtCore.pyqtSlot()
    def on_x0y0VppButton_clicked(self):
        """Cluster pane x0y0Vpp button click. Set plot dims to x0, y0, and Vpp"""
        self.SetPlotDims('x0', 'y0', 'Vpp')

    @QtCore.pyqtSlot()
    def on_pc0pc1pc2Button_clicked(self):
        """Cluster pane pc0pc1pc2 button click. Set plot dims to pc0, pc1, and pc2"""
        self.SetPlotDims('pc0', 'pc1', 'pc2')

    def SetPlotDims(self, x, y, z):
        """Set plot dimensions to x, y, z, and replot"""
        xi = self.ui.xDimComboBox.findText(x)
        yi = self.ui.yDimComboBox.findText(y)
        zi = self.ui.zDimComboBox.findText(z)        
        self.ui.xDimComboBox.setCurrentIndex(xi)
        self.ui.yDimComboBox.setCurrentIndex(yi)
        self.ui.zDimComboBox.setCurrentIndex(zi)
        self.on_plotButton_clicked() # replot

    @QtCore.pyqtSlot()
    def on_plotButton_clicked(self):
        """Cluster pane plot button click. Plot points and colour them
        according to their clusters."""
        s = self.sort
        dims = self.GetClusterPlotDimNames()
        cw = self.OpenWindow('Cluster') # in case it isn't already open
        pcchans = None
        pcs = np.any([ dim.startswith('pc') for dim in dims ])
        if pcs: # do PCA on and plot only selected spikes
            sids = self.GetImplicitSpikes()
            pcchans = self.windows['Sort'].panel.chans_selected
            pcchans.sort()
        else: # plot all spikes
            sids = s.spikes['id']
        nids = s.spikes['nid'][sids]
        X = s.get_param_matrix(dims=dims, sids=sids, pcchans=pcchans, scale=True)
        #X = self.sort.get_component_matrix(dims=dims, weighting='pca')
        if len(X) == 0:
            return # nothing to plot
        cw.plot(X, sids, nids)
        
    def GetSortedSpikes(self):
        """Return IDs of currently selected sorted spikes"""
        sw = self.windows['Sort']
        srows = sw.nslist.selectedRows()
        return sw.nslist.sids[srows]

    def GetUnsortedSpikes(self):
        """Return IDs of currently selected unsorted spikes"""
        sw = self.windows['Sort']
        srows = sw.uslist.selectedRows()
        return self.sort.usids[srows]

    def GetSpikes(self):
        """Return IDs of all currently selected spikes"""
        sw = self.windows['Sort']
        return np.concatenate([ self.GetSortedSpikes(), self.GetUnsortedSpikes() ])

    def GetSpike(self):
        """Return ID of just one selected spike, from nslist or uslist"""
        sids = self.GetSpikes()
        nselected = len(sids)
        if nselected != 1:
            raise RuntimeError("can't figure out which of the %d selected spike IDs you want"
                               % nselected)
        return sids[0]

    def GetImplicitSpikes(self):
        """Return sorted IDs of all currently selected spikes, even if they're only
        implicitly selected via their parent cluster(s)"""
        sids = []
        clusters = self.GetClusters()
        for cluster in clusters:
            sids.append(cluster.neuron.sids)
        # include any selected usids as well
        sids.append(self.GetUnsortedSpikes())
        sids = np.concatenate(sids)
        sids.sort()
        return sids

    def GetClusterIDs(self):
        """Return list of IDs of currently selected clusters, in norder"""
        sw = self.windows['Sort']
        cids = [ i.data().toInt()[0] for i in sw.nlist.selectedIndexes() ]
        #cids.sort() # don't do regular sort, sort by norder
        ciis = np.argsort([ self.sort.norder.index(cid) for cid in cids ])
        return [ cids[cii] for cii in ciis ] # in norder

    def GetClusters(self):
        """Return list of currently selected clusters, in norder"""
        cids = self.GetClusterIDs() # already in norder
        return [ self.sort.clusters[cid] for cid in cids ]

    def GetCluster(self):
        """Return just one selected cluster"""
        clusters = self.GetClusters()
        nselected = len(clusters)
        if nselected != 1:
            raise RuntimeError("can't figure out which of the %d selected clusters you want"
                               % nselected)
        return clusters[0]

    def SelectClusters(self, clusters, on=True):
        """Select/deselect clusters"""
        clusters = toiter(clusters)
        try:
            selnids = [ cluster.id for cluster in clusters ]
        except AttributeError: # assume they're ints
            selnids = [ cluster for cluster in clusters ]
        rows = [ self.sort.norder.index(selnid) for selnid in selnids ]
        nlist = self.windows['Sort'].nlist
        nlist.selectRows(rows, on)
        #print('set rows %r to %r' % (rows, on))

    def ToggleCluster(self, cluster):
        """Toggle selection of given cluster"""
        sw = self.windows['Sort']
        try:
            nid = cluster.id
        except AttributeError: # assume it's an int
            nid = cluster
        row = self.sort.norder.index(nid)
        on = not sw.nlist.rowSelected(row)
        sw.nlist.selectRows(row, on=on)
        return on

    def SelectSpike(self, sid, on=True):
        """Toggle selection of given spike, as well as its current cluster, if any"""
        sw = self.windows['Sort']
        nid = self.sort.spikes[sid]['nid']
        if nid == -1: # it's unclustered
            usrow, = np.where(self.sort.usids == sid)
            sw.uslist.selectRows(usrow, on=on)
        else: # it's clustered
            nrow = self.sort.norder.index(nid)
            cluster_on = sw.nlist.rowSelected(nrow)
            if on and not cluster_on: # if selecting the spike and cluster isn't selected
                sw.nlist.selectRows(nrow, on=True) # select the cluster
            # select/deselect the spike in the nslist as well
            nsrow, = np.where(sw.nslist.sids == sid)
            sw.nslist.selectRows(nsrow, on=on)
            # if cluster is currently selected, but no spikes are selected, deselect it
            if cluster_on and sw.nslist.nrowsSelected == 0:
                sw.nlist.selectRows(nrow, on=False)

    def CreateCluster(self, update=True, id=None, inserti=None):
        """Create a new cluster, add it to the GUI, return it"""
        s = self.sort
        neuron = s.create_neuron(id, inserti=inserti)
        sw = self.windows['Sort']
        if update:
            sw.nlist.updateAll()
        from cluster import Cluster # can't delay this any longer
        cluster = Cluster(neuron)
        s.clusters[cluster.id] = cluster
        neuron.cluster = cluster
        try:
            cw = self.windows['Cluster'] # don't force its display by default
        except KeyError:
            cw = self.OpenWindow('Cluster')
        return cluster

    def DelClusters(self, clusters, update=True):
        """Delete clusters from the GUI, and delete clusters
        and their neurons from the Sort."""
        clusters = toiter(clusters)
        self.SelectClusters(clusters, on=False) # first deselect them all
        sw = self.windows['Sort']
        cw = self.windows['Cluster']
        for cluster in clusters:
            self.DeColourPoints(cluster.neuron.sids) # decolour before neuron loses its sids
            sw.RemoveNeuron(cluster.neuron, update=update)
        cw.glWidget.updateGL()
        if update:
            self.UpdateClustersGUI()

    def UpdateClustersGUI(self):
        """Update lots of stuff after modifying clusters,
        here as a separate method for speed, only call when really needed"""
        s = self.sort
        sw = self.windows['Sort']
        sw.nlist.updateAll()
        s.update_usids()
        sw.uslist.updateAll()

    def ColourPoints(self, clusters):
        """Colour the points that fall within each cluster (as specified
        by cluster.neuron.sids) the same colour as the cluster itself"""
        clusters = toiter(clusters)
        gw = self.windows['Cluster'].glWidget
        for cluster in clusters:
            neuron = cluster.neuron
            # not all (or any) of neuron.sids may currently be plotted, due to PCA
            commonsids = np.intersect1d(neuron.sids, gw.sids)
            coloris = gw.sids.searchsorted(commonsids)
            if neuron.id == -1: # junk cluster
                gw.colors[coloris] = GREYRGB
            else:
                gw.colors[coloris] = CMAP[neuron.id % len(CMAP)]
        gw.updateGL()

    def DeColourPoints(self, sids):
        """Restore spike point colour in cluster plot at spike indices to unclustered GREY.
        Need to call cw.glWidget.updateGL() afterwards"""
        gw = self.windows['Cluster'].glWidget
        # not all (or any) of sids may currently be plotted, due to PCA
        commonsids = np.intersect1d(sids, gw.sids)
        coloris = gw.sids.searchsorted(commonsids)
        gw.colors[coloris] = GREYRGB

    def GetClusterPlotDimNames(self):
        """Return 3-tuple of strings of cluster dimension names, in (x, y, z) order"""
        x = str(self.ui.xDimComboBox.currentText())
        y = str(self.ui.yDimComboBox.currentText())
        z = str(self.ui.zDimComboBox.currentText())
        return x, y, z

    def AddClusterChangeToStack(self, cc):
        """Adds cc to the cluster change stack, removing any potential redo changes"""
        self.cci += 1
        del self.cchanges[self.cci::] # remove any existing redo cluster changes
        self.cchanges.append(cc) # add to stack
        # TODO: check if stack has gotten too long, if so, remove some from the start
        # and update self.cci appropriately

    def ApplyClusterChange(self, cc, direction):
        """Apply cluster change described in cc, in either the forward or backward
        direction, to the current set of clusters"""
        s = self.sort
        spikes = s.spikes
        sw = self.windows['Sort']
        cw = self.windows['Cluster']
        sids = cc.sids

        # reverse meaning of 'new' and 'old' if direction == 'forward', ie if redoing
        if direction == 'back':
            #newnids = cc.newnids # not needed
            oldnids = cc.oldnids
            newunids = cc.newunids
            oldunids = cc.oldunids
            poss = cc.oldposs
            normposs = cc.oldnormposs
            norder = cc.oldnorder
        else: # direction == 'forward'
            #newnids = cc.oldnids # not needed
            oldnids = cc.newnids
            newunids = cc.oldunids
            oldunids = cc.newunids
            poss = cc.newposs
            normposs = cc.newnormposs
            norder = cc.newnorder

        # delete newly added clusters
        newclusters = [ s.clusters[nid] for nid in newunids ]
        self.SelectClusters(newclusters, on=False) # deselect new clusters
        # temporarily deselect any bystander clusters to get around fact that
        # selections are row-based in Qt, not value-based, which means selection
        # changes happen without a selectionChanged event when the rowCount changes
        bystanders = self.GetClusters()
        self.SelectClusters(bystanders, on=False)
        self.DelClusters(newclusters, update=False) # del new clusters

        # restore relevant spike fields
        spikes['nid'][sids] = oldnids

        # restore the old clusters
        oldclusters = []
        dims = self.GetClusterPlotDimNames()
        t0 = time.time()
        # NOTE: oldunids are not necessarily sorted
        for nid, pos, normpos in zip(oldunids, poss, normposs):
            nsids = sids[oldnids == nid] # sids belonging to this nid
            cluster = self.CreateCluster(update=False, id=nid)
            oldclusters.append(cluster)
            neuron = cluster.neuron
            sw.MoveSpikes2Neuron(nsids, neuron, update=False)
            cluster.pos = pos
            cluster.normpos = normpos
        # restore norder
        s.norder = copy(norder)

        # now do some final updates
        self.UpdateClustersGUI()
        self.ColourPoints(oldclusters)
        #print('applying clusters to plot took %.3f sec' % (time.time()-t0))
        # select newly recreated oldclusters
        self.SelectClusters(oldclusters)
        # restore bystander selections
        self.SelectClusters(bystanders)
        #print('oldclusters: %r' % [c.id for c in oldclusters])
        #print('newclusters: %r' % [c.id for c in newclusters])
        #print('bystanders: %r' % [c.id for c in bystanders])

    def join(self, fname):
        return os.path.join(self.path, fname)

    def OpenFile(self, fname):
        """Open a .srf, .sort or .wave file"""
        ext = os.path.splitext(fname)[1]
        if ext in ['.srf', '.track']:
            self.OpenSurfOrTrackFile(fname)
        elif ext == '.sort':
            self.OpenSortFile(fname)
        else:
            critical = QtGui.QMessageBox.critical
            critical(self, "Error", "%s is not a .srf, .track or .sort file" % fname)

    def OpenSurfOrTrackFile(self, fname):
        """Open a .srf or .track file, and update display accordingly"""
        if self.hpstream != None:
            self.CloseSurfOrTrackFile() # in case a .srf or .track file and windows are already open
        ext = os.path.splitext(fname)[1]
        if ext == '.srf':
            srff = surf.File(fname, self.path)
            srff.parse() # TODO: parsing progress dialog
            self.hpstream = srff.hpstream # highpass record (spike) stream
            self.lpstream = srff.lpstream # lowpassmultichan record (LFP) stream
        elif ext == '.track':
            srffs = []
            with open(self.join(fname), 'r') as trackfile:
                for line in trackfile: # one srf filename per line
                    if line.startswith('#'): # it's a comment line
                        continue # skip it
                    srffname = line.rstrip('\n')
                    srff = surf.File(srffname, self.path)
                    srff.parse()
                    srffs.append(srff) # build up list of open and parsed surf File objects
            self.hpstream = core.TrackStream(srffs, fname, kind='highpass')
            self.lpstream = core.TrackStream(srffs, fname, kind='lowpass')
        else:
            raise ValueError('unknown extension %r' % ext)

        self.caption = fname # update
        self.setWindowTitle(self.caption) # update the caption
        self.ui.__dict__['action%dkHz' % (self.hpstream.sampfreq / 1000)].setChecked(True)
        self.ui.actionSampleAndHoldCorrect.setChecked(self.hpstream.shcorrect)

        self.set_chans_enabled(self.hpstream.chans, enable=True)
        tww = self.spiketw[1]-self.spiketw[0] # window width
        self.t = intround(self.hpstream.t0 + tww/2) # set current timepoint (us)

        self.SPIKEWINDOWWIDTH = self.hpstream.probe.ncols * SPIKEWINDOWWIDTHPERCOLUMN
        self.OpenWindow('Spike')

        self.str2t = {'start': self.hpstream.t0,
                      'now': self.t, # FIXME: this won't track self.t automatically
                      'end': self.hpstream.t1}
        self.range = (self.hpstream.t0, self.hpstream.t1) # us
        self.ui.filePosLineEdit.setText(str(self.t))
        self.ui.filePosStartButton.setText(str(self.hpstream.t0))
        self.ui.filePosEndButton.setText(str(self.hpstream.t1))
        # set all slider values in multiples of SLIDERTRES
        self.ui.slider.setRange(self.range[0] // SLIDERTRES,
                                self.range[1] // SLIDERTRES) # no need to round
        self.ui.slider.setValue(self.t // SLIDERTRES)
        self.ui.slider.setSingleStep(1)
        self.ui.slider.setPageStep((self.spiketw[1]-self.spiketw[0]) // SLIDERTRES)

        self.EnableSurfWidgets(True)

    def CreateNewSort(self):
        """Create a new Sort, bind it to self, and return it"""
        self.DeleteSort()
        self.sort = Sort(detector=None, # detector is assigned in on_detectButton_clicked
                         stream=self.hpstream)
        self.EnableSortWidgets(True)
        return self.sort

    def DeleteSort(self):
        """Delete any existing Sort"""
        try:
            # TODO: if Save button is enabled, check if Sort is saved,
            # if not, prompt to save
            print('deleting existing Sort and entries in list controls')
            clusters = self.sort.clusters # need it below
            #self.sort.spikes.resize(0, recheck=False) # doesn't work, doesn't own memory
            del self.sort
        except AttributeError:
            clusters = {}
        if 'Sort' in self.windows:
            sw = self.windows['Sort']
            sw.nlist.reset()
            sw.nslist.reset()
            sw.uslist.reset()
            sw.panel.removeAllItems()
        if 'Cluster' in self.windows:
            cw = self.windows['Cluster']
            cw.glWidget.reset()
        del self.cchanges[:]
        self.cci = -1
        self.ui.progressBar.setFormat('0 spikes')
        # make sure self.sort and especially self.sort.spikes is really gone
        # TODO: check if this is necessary once everything works with new streamlined
        # (no objects) spikes struct array
        gc.collect()

    def get_chans_enabled(self):
        return np.asarray([ chan for (chan, enable) in self._chans_enabled.iteritems() if enable ], dtype=np.uint8)

    def set_chans_enabled(self, chans, enable=None):
        """Updates which chans are enabled in ._chans_enabled dict and in the
        plot panels, and in the highpass stream. If enable is set, chans specifies
        which chans should have their enable flag overwritten. Otherwise,
        chans specifies all the chans we want enabled.
        The code for the 2nd case is quite elaborate, such that the visibility
        state of any given plot in all plotpanels isn't needlessly toggled,
        which slows things down and causes flicker, I think"""

        # inits and checks
        try:
            allchans = self.hpstream.chans # not sure if this needs to be copy()'d or not
        except AttributeError: # no hpstream yet
            allchans = []
        if chans == None: # None means all chans
            chans = allchans
        chans = toiter(chans) # need not be contiguous
        try:
            self._chans_enabled
        except AttributeError:
            self._chans_enabled = {} #dict(zip(allchans, [ True for chan in allchans ]))

        # overwrite enable flag of chans...
        if enable != None:
            for chan in chans:
                self._chans_enabled[chan] = enable
            for windowtype in WINDOWUPDATEORDER:
                try:
                    self.windows[windowtype].panel.enable_chans(chans, enable=enable)
                except KeyError: # windowtype hasn't been opened yet
                    pass
        # ...or, leave only chans enabled
        else:
            enabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==True ]
            disabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==False ]
            notchans = set(allchans).difference(chans) # chans we don't want enabled
            # find the difference between currently enabled chans and the chans we want enabled
            chans2disable = set(enabledchans).difference(chans)
            # find the difference between currently disabled chans and the chans we want disabled
            chans2enable = set(disabledchans).difference(notchans)
            for chan in chans2enable:
                self._chans_enabled[chan] = True
            for chan in chans2disable:
                self._chans_enabled[chan] = False
            # now change the actual plots in the plotpanels
            for windowtype in WINDOWUPDATEORDER:
                try:
                    self.windows[windowtype].panel.enable_chans(chans2enable, enable=True)
                    self.windows[windowtype].panel.enable_chans(chans2disable, enable=False)
                except KeyError: # windowtype hasn't been opened yet
                    pass

        # update stream, might trigger change of stream type
        if self.hpstream != None:
            self.hpstream.chans = self.chans_enabled

    chans_enabled = property(get_chans_enabled, set_chans_enabled)

    def CloseSurfOrTrackFile(self):
        """Destroy data and sort windows, clean up, close streams,
        and metaphorically, .sort file too"""
        # need to specifically get a list of keys, not an iterator,
        # since self.windows dict changes size during iteration
        for windowtype in self.windows.keys():
            if windowtype != 'Shell': # leave shell window alone
                self.CloseWindow(windowtype) # deletes from dict
        for stream in [self.hpstream, self.lpstream]:
            if stream: stream.close()
        self.hpstream = None
        self.lpstream = None
        self.chans_enabled = []
        self.t = None
        self.spiketw = DEFSPIKETW # reset
        self.charttw = DEFCHARTTW
        self.lfptw = DEFLFPTW
        self.ShowRasters(False) # reset
        self.setWindowTitle('spyke') # update caption
        self.EnableSurfWidgets(False)
        self.caption = ''
        self.CloseSortFile()

    def CloseSortFile(self):
        self.DeleteSort()
        self.EnableSortWidgets(False)

    def OpenSortFile(self, fname):
        """Open a Sort from a .sort file, try and open a .wave file
        with the same name, restore the stream"""
        self.DeleteSort() # delete any existing Sort
        print('opening sort file %r' % fname)
        t0 = time.time()
        f = open(self.join(fname), 'rb')
        sort = cPickle.load(f)
        print('done opening sort file, took %.3f sec' % (time.time()-t0))
        print('sort file was %d bytes long' % f.tell())
        f.close()
        self.sort = sort
        sortProbeType = type(sort.probe)
        if self.hpstream != None:
            streamProbeType = type(self.hpstream.probe)
            if sortProbeType != streamProbeType:
                self.CreateNewSort() # overwrite the failed Sort
                raise RuntimeError(".sort file's probe type %r doesn't match .srf file's probe type %r"
                                   % (sortProbeType, streamProbeType))

        self.OpenSpikeFile(sort.spikefname)

        if self.hpstream != None:
            sort.stream = self.hpstream # restore missing stream object to Sort
        self.SetSampfreq(sort.sampfreq)
        self.SetSHCorrect(sort.shcorrect)
        self.ShowRasters(True) # turn rasters on and update rasters menu item now that we have a sort
        self.ui.menuSampling.setEnabled(False) # disable sampling menu
        self.ui.progressBar.setFormat("%d spikes" % sort.nspikes)
        self.EnableSpikeWidgets(True)

        self.SPIKEWINDOWWIDTH = sort.probe.ncols * SPIKEWINDOWWIDTHPERCOLUMN
        sw = self.OpenWindow('Sort') # ensure it's open
        # restore unsorted spike listview
        sw.uslist.updateAll()

        cw = self.OpenWindow('Cluster')
        self.on_plotButton_clicked() # create glyph on first open
        # try and restore saved camera view
        try: cw.glWidget.MV, cw.glWidget.focus = sort.MV, sort.focus
        except AttributeError: pass
        self.RestoreClusters2GUI()
        # try and restore saved cluster selection
        try: self.SelectClusters(sort.selnids)
        except AttributeError: pass
        self.setWindowTitle(self.caption + ' | ' + self.sort.sortfname)
        self.update_gui_from_sort()
        self.EnableSortWidgets(True)

    def OpenSpikeFile(self, fname):
        sort = self.sort
        print('loading spike file %r' % fname)
        t0 = time.time()
        f = open(self.join(fname), 'rb')
        spikes = np.load(f)
        print('done opening spike file, took %.3f sec' % (time.time()-t0))
        print('spike file was %d bytes long' % f.tell())
        f.close()
        sort.spikes = spikes
        # when loading a spike file, make sure the nid field is overwritten
        # in the spikes array. The nids in sort.neurons are always the definitive ones
        for neuron in sort.neurons.values():
            spikes['nid'][neuron.sids] = neuron.id
        sort.update_usids()
        # try loading .wave file of the same name
        wavefname = os.path.splitext(fname)[0] + '.wave'
        sort.wavedata = self.OpenWaveFile(wavefname)

    def OpenWaveFile(self, fname):
        """Open a .wave file and return wavedata array"""
        sort = self.sort
        print('opening wave file %r' % fname)
        t0 = time.time()
        try: f = open(self.join(fname), 'rb')
        except IOError:
            print("can't find file %r" % fname)
            return
        try:
            del sort.wavedata
            #gc.collect() # ensure memory is freed up to prepare for new wavedata, necessary?
        except AttributeError: pass
        wavedata = np.load(f)
        print('done opening wave file, took %.3f sec' % (time.time()-t0))
        print('wave file was %d bytes long' % f.tell())
        f.close()
        if len(wavedata) != sort.nspikes:
            critical = QtGui.QMessageBox.critical
            critical(self, "Error",
                     ".wave file has a different number of spikes from the current Sort")
            raise RuntimeError
        return wavedata

    def RestoreClusters2GUI(self):
        """Stuff that needs to be done to synch the GUI with newly imported clusters"""
        self.UpdateClustersGUI() # restore nlist and uslist
        try:
            self.sort.spikes
            self.ColourPoints(self.sort.clusters.values()) # colour points for all clusters in one shot
        except AttributeError: pass # no spikes
        self.OpenWindow('Sort')

    def SaveSortFile(self, fname):
        """Save sort to a .sort file"""
        s = self.sort
        try: s.spikes
        except AttributeError: raise RuntimeError("Sort has no spikes to save")
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.sort'
        try: s.spikefname
        except AttributeError: # corresponding .spike filename hasn't been gemerated yet
            s.spikefname = os.path.splitext(fname)[0] + '.spike'
        self.SaveSpikeFile(s.spikefname) # always (re)save .spike when saving .sort
        print('saving sort file %r' % fname)
        t0 = time.time()
        try:
            cw = self.windows['Cluster']
            s.MV, s.focus = cw.glWidget.MV, cw.glWidget.focus # save camera view
        except KeyError: pass # cw hasn't been opened yet, no camera view to save
        s.selnids = self.GetClusterIDs() # save current cluster selection
        s.sortfname = fname # bind it now that it's about to be saved
        f = open(self.join(fname), 'wb')
        cPickle.dump(s, f, protocol=-1) # pickle with most efficient protocol
        f.close()
        print('done saving sort file, took %.3f sec' % (time.time()-t0))
        self.setWindowTitle(self.caption + ' | ' + s.sortfname)

    def SaveSpikeFile(self, fname):
        """Save spikes to a .spike file"""
        s = self.sort
        try: s.spikes
        except AttributeError: raise RuntimeError("Sort has no spikes to save")
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.spike'
        try: s.wavefname
        except AttributeError: # corresponding .wave filename hasn't been generated yet
            wavefname = os.path.splitext(fname)[0] + '.wave'
            self.SaveWaveFile(wavefname) # only (re)save .wave if missing s.wavefname attrib
        print('saving spike file %r' % fname)
        t0 = time.time()
        f = open(self.join(fname), 'wb')
        np.save(f, s.spikes)
        f.close()
        print('done saving spike file, took %.3f sec' % (time.time()-t0))
        s.spikefname = fname # used to indicate that the spikes have been saved

    def SaveWaveFile(self, fname):
        """Save waveform data to a .wave file"""
        s = self.sort
        try: s.wavedata
        except AttributeError: return # no wavedata to save
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.wave'
        print('saving wave file %r' % fname)
        t0 = time.time()
        f = open(self.join(fname), 'wb')
        np.save(f, s.wavedata)
        f.close()
        print('done saving wave file, took %.3f sec' % (time.time()-t0))
        s.wavefname = fname

    def OpenWindow(self, windowtype):
        """Create and bind a window, show it, plot its data if applicable"""
        new = windowtype not in self.windows
        if new:
            if windowtype == 'Spike':
                x = self.pos().x()
                y = self.pos().y() + self.size().height() + METACITYHACK
                window = SpikeWindow(parent=self, tw=self.spiketw, pos=(x, y),
                                     size=(self.SPIKEWINDOWWIDTH, SPIKEWINDOWHEIGHT))
            elif windowtype == 'Chart':
                x = self.pos().x() + self.SPIKEWINDOWWIDTH
                y = self.pos().y() + self.size().height() + METACITYHACK
                window = ChartWindow(parent=self, tw=self.charttw, cw=self.spiketw,
                                     pos=(x, y), size=CHARTWINDOWSIZE)
            elif windowtype == 'LFP':
                x = self.pos().x() + self.SPIKEWINDOWWIDTH + CHARTWINDOWSIZE[0]
                y = self.pos().y() + self.size().height() + METACITYHACK
                window = LFPWindow(parent=self, tw=self.lfptw, cw=self.charttw,
                                   pos=(x, y), size=LFPWINDOWSIZE)
            elif windowtype == 'Sort':
                x = self.pos().x() + self.size().width()
                y = self.pos().y()
                window = SortWindow(parent=self, pos=(x, y))
            elif windowtype == 'Cluster':
                x = self.pos().x() + self.size().width() + self.windows['Sort'].size().height()
                y = self.pos().y()
                from cluster import ClusterWindow # can't delay this any longer
                window = ClusterWindow(parent=self, pos=(x, y), size=CLUSTERWINDOWSIZE)
            self.windows[windowtype] = window
            self.dpos[windowtype] = window.pos() - self.pos()
        self.ShowWindow(windowtype) # just show it
        if new: # do stuff that only works after first show
            if windowtype != 'Cluster':
                window.panel.draw_refs() # prevent plot artifacts
            if windowtype == 'Sort':
                window.mainsplitter.moveSplitter(MAINSPLITTERPOS, 1)
        return self.windows[windowtype] # 'window' isn't necessarily in local namespace

    def ShowWindow(self, windowtype, enable=True):
        """Show/hide a window, force menu and toolbar states to correspond"""
        window = self.windows[windowtype]
        if enable:
            window.show()
        else:
            window.hide()
        self.ui.__dict__['action%sWindow' % windowtype].setChecked(enable)
        if enable and isinstance(window, DataWindow):
            # update the newly shown data window's data, in case self.t changed since
            # it was last visible
            self.plot(windowtype)

    def HideWindow(self, windowtype):
        self.ShowWindow(windowtype, False)

    def ToggleWindow(self, windowtype):
        """Toggle visibility of a data window"""
        try:
            window = self.windows[windowtype]
            self.ShowWindow(windowtype, not window.isVisible()) # toggle it
        except KeyError: # window hasn't been opened yet
            self.OpenWindow(windowtype)

    def CloseWindow(self, windowtype):
        """Hide window, remove it from windows dict, destroy it"""
        self.HideWindow(windowtype)
        window = self.windows.pop(windowtype)
        window.destroy()

    def ToggleWaveforms(self):
        raise NotImplementedError

    def ToggleRasters(self):
        """Toggle visibility of rasters"""
        enable = self.ui.actionRasters.isChecked()
        self.ShowRasters(enable)

    def ShowRasters(self, enable=True):
        """Show/hide rasters for all applicable windows. Force menu states to correspond"""
        self.ui.actionRasters.setChecked(enable)
        for windowtype, window in self.windows.iteritems():
            if windowtype in ['Spike', 'Chart', 'LFP']:
                window.panel.show_rasters(enable=enable)
                self.plot(windowtype)

    def ToggleRef(self, ref):
        """Toggle visibility of TimeRef, VoltageRef, or the Caret"""
        enable = self.ui.__dict__['action%s' % ref].isChecked()
        self.ShowRef(ref, enable)

    def ShowRef(self, ref, enable=True):
        """Show/hide a TimeRef, VoltageRef, or the Caret. Force menu states to correspond"""
        self.ui.__dict__['action%s' % ref].setChecked(enable)
        for windowtype, window in self.windows.items():
            if windowtype in ['Spike', 'Chart', 'LFP']:
                window.panel.show_ref(ref, enable=enable)
            elif windowtype == 'Sort':
                window.spikesortpanel.show_ref(ref, enable=enable)
                #window.chartsortpanel.show_ref(ref, enable=enable)

    def SetSampfreq(self, sampfreq):
        """Set highpass stream sampling frequency, update widgets"""
        if self.hpstream != None:
            self.hpstream.sampfreq = sampfreq
            # since slider is in multiples of SLIDERTRES, doesn't need to be updated
            self.plot()
        self.ui.__dict__['action%dkHz' % (sampfreq / 1000)].setChecked(True)

    def SetSHCorrect(self, enable):
        """Set highpass stream sample & hold correct flag, update widgets"""
        if self.hpstream != None:
            self.hpstream.shcorrect = enable
        self.ui.actionSampleAndHoldCorrect.setChecked(enable)
        self.plot()

    def EnableSurfWidgets(self, enable):
        """Enable/disable all widgets that require an open .srf file"""
        return # do nothing, at least for now
        '''
        self.menubar.Enable(wx.ID_NEW, enable)
        self.menubar.Enable(wx.ID_SPIKEWIN, enable)
        self.menubar.Enable(wx.ID_CHARTWIN, enable)
        self.menubar.Enable(wx.ID_LFPWIN, enable)
        self.menubar.Enable(wx.ID_TREF, enable)
        self.menubar.Enable(wx.ID_VREF, enable)
        self.menubar.Enable(wx.ID_CARET, enable)
        self.menubar.Enable(wx.ID_SAMPLING, enable)
        self.menubar.Enable(wx.ID_WAVEFORMS, enable)
        self.toolbar.EnableTool(wx.ID_NEW, enable)
        self.toolbar.EnableTool(wx.ID_SPIKEWIN, enable)
        self.toolbar.EnableTool(wx.ID_CHARTWIN, enable)
        self.toolbar.EnableTool(wx.ID_LFPWIN, enable)
        self.file_pos_control_panel.Show(enable)
        self.notebook.Show(enable)
        self.detect_button.Enable(enable)
        self.file_min_label.Show(enable)
        self.file_max_label.Show(enable)
        '''
    def EnableSortWidgets(self, enable):
        """Enable/disable all widgets that require an "open" .sort file"""
        '''
        self.menubar.Enable(wx.ID_SORTWIN, enable)
        self.toolbar.EnableTool(wx.ID_SORTWIN, enable)
        self.menubar.Enable(wx.ID_CLUSTERWIN, enable)
        self.toolbar.EnableTool(wx.ID_CLUSTERWIN, enable)
        self.menubar.Enable(wx.ID_SAVE, enable)
        self.toolbar.EnableTool(wx.ID_SAVE, enable)
        self.menubar.Enable(wx.ID_RASTERS, enable)
        '''
        self.EnableSpikeWidgets(enable)

    def EnableSpikeWidgets(self, enable):
        """Enable/disable all widgets that require the current Sort to have spikes"""
        return # do nothing for now
        '''
        try:
            if len(self.sort.spikes) == 0: enable = False # no spikes
        except AttributeError: enable = False # self.sort doesn't exist yet
        self.extract_pane.Enable(enable)
        try: self.sort.extractor
        except AttributeError: enable = False # no params extracted, or .sort doesn't exist
        self.cluster_pane.Enable(enable)
        try:
            if len(self.sort.clusters) == 0: enable = False # no clusters exist yet
        except AttributeError: enable = False
        self.cluster_params_pane.Enable(enable)
        try:
            if len(self.sort.neurons) == 0: enable = False # no neurons
        except AttributeError: enable = False # self.sort doesn't exist yet
        self.validate_pane.Enable(enable)
        '''
    def get_detector(self):
        """Create and bind Detector object, update sort from gui"""
        self.sort.detector = Detector(sort=self.sort)
        self.update_sort_from_gui()

    def update_sort_from_gui(self):
        self.update_sort_from_detector_pane()
        self.update_sort_from_cluster_pane()

    def update_sort_from_detector_pane(self):
        ui = self.ui
        det = self.sort.detector
        det.chans = self.chans_enabled
        if ui.globalFixedRadioButton.isChecked():
            threshmethod = 'GlobalFixed'
        elif ui.channelFixedRadioButton.isChecked():
            threshmethod = 'ChanFixed'
        elif ui.dynamicRadioButton.isChecked():
            threshmethod = 'Dynamic'
        else:
            raise ValueError
        det.threshmethod = threshmethod
        det.fixedthreshuV = ui.globalFixedSpinBox.value()
        det.noisemult = ui.dynamicNoiseXSpinBox.value()
        det.noisemethod = str(ui.noiseMethodComboBox.currentText())
        det.ppthreshmult = ui.vppThreshXSpinBox.value()
        det.dt = ui.phaseDTSpinBox.value()
        det.trange = self.get_detectortrange()
        det.blocksize = int(float(ui.blockSizeLineEdit.text())) # allow exp notation
        det.lockr = ui.lockRSpinBox.value()
        det.inclr = ui.inclRSpinBox.value()

    def update_sort_from_cluster_pane(self):
        ui = self.ui
        s = self.sort
        s.sigma = ui.sigmaSpinBox.value()
        s.rmergex = ui.rmergeXSpinBox.value()
        s.rneighx = ui.rneighXSpinBox.value()
        s.alpha = ui.alphaSpinBox.value()
        s.maxstill = ui.maxstillSpinBox.value()
        s.minpoints = ui.minpointsSpinBox.value()

    def update_gui_from_sort(self):
        ui = self.ui
        s = self.sort
        det = s.detector
        self.chans_enabled = det.chans
        # update detector pane
        meth2widget = {'GlobalFixed': ui.globalFixedRadioButton,
                       'ChanFixed': ui.channelFixedRadioButton,
                       'Dynamic': ui.dynamicRadioButton}
        meth2widget[det.threshmethod].setChecked(True)
        ui.globalFixedSpinBox.setValue(det.fixedthreshuV)
        ui.dynamicNoiseXSpinBox.setValue(det.noisemult)
        ui.noiseMethodComboBox.setCurrentIndex(ui.noiseMethodComboBox.findText(det.noisemethod))
        ui.vppThreshXSpinBox.setValue(det.ppthreshmult)
        ui.phaseDTSpinBox.setValue(det.dt)
        ui.rangeStartLineEdit.setText(str(det.trange[0]))
        ui.rangeEndLineEdit.setText(str(det.trange[1]))
        ui.blockSizeLineEdit.setText(str(det.blocksize))
        ui.lockRSpinBox.setValue(det.lockr)
        ui.inclRSpinBox.setValue(det.inclr)
        # update cluster pane
        ui.sigmaSpinBox.setValue(s.sigma)
        ui.rmergeXSpinBox.setValue(s.rmergex)
        ui.rneighXSpinBox.setValue(s.rneighx)
        ui.alphaSpinBox.setValue(s.alpha)
        ui.maxstillSpinBox.setValue(s.maxstill)
        ui.minpointsSpinBox.setValue(s.minpoints)

    def get_detectortrange(self):
        """Get detector time range from combo boxes, and convert
        start, now, and end to appropriate vals"""
        t0 = str(self.ui.rangeStartLineEdit.text())
        t1 = str(self.ui.rangeEndLineEdit.text())
        try:
            t0 = self.str2t[t0]
        except KeyError:
            t0 = int(float(t0)) # convert to float to allow exp notation shorthand
        try:
            t1 = self.str2t[t1]
        except KeyError:
            t1 = int(float(t1))
        return t0, t1

    def seek(self, offset=0):
        """Seek to position in stream. offset is time in us"""
        oldt = self.t
        # round to nearest (possibly interpolated) sample
        self.t = intround(offset / self.hpstream.tres) * self.hpstream.tres
        self.t = min(max(self.t, self.range[0]), self.range[1]) # constrain to within .range
        self.str2t['now'] = self.t # update
        # only plot if t has actually changed, though this doesn't seem to improve
        # performance, maybe mpl is already doing something like this?
        if self.t != oldt: # update controls first so they don't lag
            self.ui.filePosLineEdit.setText(str(self.t))
            self.ui.slider.setValue(self.t // SLIDERTRES)
            self.plot()
    '''
    def step(self, direction):
        """Step one timepoint left or right"""
        self.seek(self.t + direction*self.hpstream.tres)

    def page(self, direction):
        """Page left or right"""
        self.seek(self.t + direction*self.hpstream.tres)
    '''
    def tell(self):
        """Return current position in surf file"""
        return self.t

    def plot(self, windowtypes=None):
        """Update the contents of all the data windows, or just specific ones.
        Center each data window on self.t"""
        if windowtypes == None: # update all visible windows
            windowtypes = self.windows.keys()
        else: # update only specific windows, if visible
            windowtypes = toiter(windowtypes)
        windowtypes = [ windowtype for windowtype in WINDOWUPDATEORDER if windowtype in windowtypes ] # reorder
        windows = [ self.windows[windowtype] for windowtype in windowtypes ] # get windows in order
        for windowtype, window in zip(windowtypes, windows):
            if window.isVisible(): # for performance, only update if window is shown
                if windowtype == 'Spike':
                    wave = self.hpstream[self.t+self.spiketw[0] : self.t+self.spiketw[1]]
                elif windowtype == 'Chart':
                    wave = self.hpstream[self.t+self.charttw[0] : self.t+self.charttw[1]]
                elif windowtype == 'LFP':
                    wave = self.lpstream[self.t+self.lfptw[0] : self.t+self.lfptw[1]]
                window.panel.plot(wave, tref=self.t) # plot it


class DataWindow(SpykeToolWindow):
    """Base data window to hold a custom spyke panel widget"""
    def setupUi(self, pos, size):
        self.setCentralWidget(self.panel)
        self.resize(*size)
        self.move(*pos)

    def closeEvent(self, event):
        # remove 'Window' from class name
        windowtype = type(self).__name__.replace('Window', '')
        self.parent().HideWindow(windowtype)


class SpikeWindow(DataWindow):
    """Window to hold the custom spike panel widget"""
    def __init__(self, parent=None, tw=None, cw=None, pos=None, size=None):
        DataWindow.__init__(self, parent)
        self.panel = SpikePanel(self, tw=tw, cw=cw)
        self.setupUi(pos, size)
        self.setWindowTitle("Spike Window")


class ChartWindow(DataWindow):
    """Window to hold the custom chart panel widget"""
    def __init__(self, parent=None, tw=None, cw=None, pos=None, size=None):
        DataWindow.__init__(self, parent)
        self.panel = ChartPanel(self, tw=tw, cw=cw)
        self.setupUi(pos, size)
        self.setWindowTitle("Chart Window")


class LFPWindow(DataWindow):
    """Window to hold the custom LFP panel widget"""
    def __init__(self, parent=None, tw=None, cw=None, pos=None, size=None):
        DataWindow.__init__(self, parent)
        self.panel = LFPPanel(self, tw=tw, cw=cw)
        self.setupUi(pos, size)
        self.setWindowTitle("LFP Window")


def set_excepthook():
    """Drops us into IPython's debugger on any error"""
    sys.excepthook = ultratb.FormattedTB(mode='Verbose', call_pdb=1)


if __name__ == '__main__':
    QtCore.pyqtRemoveInputHook() # prevents "The event loop is already running" errors
    set_excepthook()
    #from IPython.lib.guisupport import get_app_qt4, start_event_loop_qt4
    #app = get_app_qt4(sys.argv)
    app = QtGui.QApplication(sys.argv)
    spykewindow = SpykeWindow()
    spykewindow.show()
    '''
    # this used to work in IPython 0.10:
    from IPython import appstart_qt4
    appstart_qt4(app)
    '''
    #start_event_loop_qt4(app)
    sys.exit(app.exec_())
