"""Main spyke window"""

from __future__ import division

__authors__ = ['Martin Spacek', 'Reza Lotun']

import wx
import wx.html
import wx.py
import cPickle
import os
import sys
import time
import datetime
import gzip
from copy import copy

import spyke
from spyke import core, surf, detect
from spyke.sort import Sort, Detection
from spyke.core import toiter, MU, intround
from spyke.gui.plot import ChartPanel, LFPPanel, SpikePanel
from spyke.sort import SortFrame
import wxglade_gui

DEFSPIKETW = (-500, 500) # spike frame temporal window (us)
DEFCHARTTW = (-25000, 25000) # chart frame temporal window (us)
DEFLFPTW = (-500000, 500000) # lfp frame temporal window (us)

SPIKEFRAMEWIDTHPERCOLUMN = 80
SPIKEFRAMEHEIGHT = 700
CHARTFRAMESIZE = (900, SPIKEFRAMEHEIGHT)
LFPFRAMESIZE = (250, SPIKEFRAMEHEIGHT)
PYSHELLSIZE = (CHARTFRAMESIZE[0], CHARTFRAMESIZE[1]/2)

FRAMEUPDATEORDER = ['spike', 'lfp', 'chart'] # chart goes last cuz it's slowest

PYSHELLCFGFNAME = 'pyshell_cfg'


class SpykeFrame(wxglade_gui.SpykeFrame):
    """spyke's main frame, inherits gui layout code auto-generated by wxGlade"""

    DEFAULTDIR = os.path.abspath('/data/ptc15')
    FRAMETYPE2ID = {'spike': wx.ID_SPIKEWIN,
                    'chart': wx.ID_CHARTWIN,
                    'lfp': wx.ID_LFPWIN,
                    'sort': wx.ID_SORTWIN,
                    'pyshell': wx.ID_PYSHELL}
    REFTYPE2ID = {'tref': wx.ID_TREF,
                  'vref': wx.ID_VREF,
                  'caret': wx.ID_CARET}
    SAMPFREQ2ID = {25000: wx.ID_25,
                   50000: wx.ID_50,
                   100000: wx.ID_100}

    def __init__(self, *args, **kwargs):
        wxglade_gui.SpykeFrame.__init__(self, *args, **kwargs)
        self.SetPosition(wx.Point(x=0, y=0)) # upper left corner
        self.dpos = {} # positions of data frames relative to main spyke frame
        self.srff = None # Surf File object
        self.srffname = '' # used for setting title caption
        self.sortfname = '' # used for setting title caption
        self.frames = {} # holds spike, chart, lfp, sort, and pyshell frames
        self.spiketw = DEFSPIKETW # spike frame temporal window (us)
        self.charttw = DEFCHARTTW # chart frame temporal window (us)
        self.lfptw = DEFLFPTW # lfp frame temporal window width (us)
        self.t = None # current time position in recording (us)

        self.hpstream = None
        self.lpstream = None

        self.Bind(wx.EVT_MOVE, self.OnMove)
        self.Bind(wx.EVT_CLOSE, self.OnExit)

        self.slider.Bind(wx.EVT_SLIDER, self.OnSlider)
        self.detection_list.Bind(wx.EVT_KEY_DOWN, self.OnDetectionListKeyDown)

        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)

        columnlabels = ['detID', 'class', 'thresh', 'trange', 'nspikes', 'slock', 'datetime']
        for coli, label in enumerate(columnlabels):
            self.detection_list.InsertColumn(coli, label)
        for coli in range(len(columnlabels)): # this needs to be in a separate loop it seems
            self.detection_list.SetColumnWidth(coli, wx.LIST_AUTOSIZE_USEHEADER) # resize columns to fit

        self.set_detect_pane_defaults()

        self.file_pos_combo_box_units_label.SetLabel(MU+'s') # can't seem to set mu symbol from within wxGlade
        self.fixedthresh_units_label.SetLabel(MU+'V')
        self.range_units_label.SetLabel(MU+'s')
        self.blocksize_units_label.SetLabel(MU+'s')
        self.spatial_units_label.SetLabel(MU+'m')

        # disable most widgets until a .srf or .sort file is opened
        self.EnableSurfWidgets(False)
        self.EnableSortWidgets(False)

        # TODO: load recent file history and add it to menu (see wxGlade code that uses wx.FileHistory)

        # for faster testing:
        srffname = os.path.join(self.DEFAULTDIR, '87 - track 7c spontaneous craziness.srf')
        #sortfname = self.DEFAULTDIR + '/87 testing.sort'
        self.OpenSurfFile(srffname)
        #self.OpenSortFile(sortfname)

    def set_detect_pane_defaults(self):
        """Set widget initial values and limits"""
        self.METH2RADIOBTN = {'GlobalFixed': self.globalfixedthresh_radio_btn,
                              'ChanFixed': self.chanfixedthresh_radio_btn,
                              'Dynamic': self.dynamicthresh_radio_btn}
        self.METH2RADIOBTN[detect.Detector.DEFTHRESHMETHOD].SetValue(True) # enable the appropriate radio button
        self.fixedthresh_spin_ctrl.SetRange(-sys.maxint, sys.maxint)
        self.fixedthresh_spin_ctrl.SetValue(detect.Detector.DEFFIXEDTHRESH)
        self.noisemult_text_ctrl.SetValue(str(detect.Detector.DEFNOISEMULT))
        self.noise_method_choice.SetStringSelection(detect.Detector.DEFNOISEMETHOD)
        self.ppthreshmult_text_ctrl.SetValue(str(detect.Detector.DEFPPTHRESHMULT))
        self.nspikes_spin_ctrl.SetRange(0, sys.maxint)
        self.nspikes_spin_ctrl.SetValue(detect.Detector.DEFMAXNSPIKES)

        # temporary, for faster testing
        #self.range_start_combo_box.SetValue('0')
        self.range_end_combo_box.SetValue('1e6')

        self.blocksize_combo_box.SetValue(str(detect.Detector.DEFBLOCKSIZE))
        self.slock_spin_ctrl.SetRange(0, sys.maxint)
        self.slock_spin_ctrl.SetValue(detect.Detector.DEFSLOCK)
        self.random_sample_checkbox.SetValue(detect.Detector.DEFRANDOMSAMPLE)

    def OnNew(self, evt):
        self.CreateNewSort()

    def OnOpen(self, evt):
        dlg = wx.FileDialog(self, message="Open surf or sort file",
                            defaultDir=self.DEFAULTDIR, defaultFile='',
                            wildcard="All files (*.*)|*.*|Surf files (*.srf)|*.srf|Sort files (*.sort)|*.sort",
                            style=wx.OPEN)
        if dlg.ShowModal() == wx.ID_OK:
            fname = dlg.GetPath()
            self.OpenFile(fname)
        dlg.Destroy()

    def OnSave(self, evt):
        if not self.sortfname:
            self.OnSaveAs(evt)
        else:
            self.SaveSortFile(self.sortfname) # save to existing sort fname

    def OnSaveAs(self, evt):
        """Save sort session to new .sort file"""
        dlg = wx.FileDialog(self, message="Save sort session as",
                            defaultDir=self.DEFAULTDIR, defaultFile='',
                            wildcard="Sort files (*.sort)|*.sort|All files (*.*)|*.*",
                            style=wx.SAVE | wx.OVERWRITE_PROMPT)
        if dlg.ShowModal() == wx.ID_OK:
            fname = dlg.GetPath()
            self.SaveSortFile(fname)
        dlg.Destroy()

    def OnClose(self, evt):
        # TODO: add confirmation dialog if sort session not saved
        self.CloseSurfFile()

    def OnExit(self, evt):
        # TODO: add confirmation dialog if sort session not saved
        self.CloseSurfFile()
        self.Destroy()

    def OnAbout(self, evt):
        dlg = SpykeAbout(self)
        dlg.ShowModal()
        dlg.Destroy()

    def OnSpike(self, evt):
        """Spike window toggle menu/button event"""
        self.ToggleFrame('spike')

    def OnChart(self, evt):
        """Chart window toggle menu/button event"""
        self.ToggleFrame('chart')

    def OnLFP(self, evt):
        """LFP window toggle menu/button event"""
        self.ToggleFrame('lfp')

    def OnSort(self, evt):
        """Sort window toggle menu/button event"""
        self.ToggleFrame('sort')

    def OnPyShell(self, evt):
        """PyShell window toggle menu/button event"""
        self.ToggleFrame('pyshell')

    def OnWaveforms(self, evt):
        """Spike waveforms toggle menu event"""
        self.ToggleWaveforms()

    def OnRasters(self, evt):
        """Spike rasters toggle menu event"""
        self.ToggleRasters()

    def OnTref(self, evt):
        """Time reference toggle menu event"""
        self.ToggleRef('tref')

    def OnVref(self, evt):
        """Voltage reference toggle menu event"""
        self.ToggleRef('vref')

    def OnCaret(self, evt):
        """Caret toggle menu event"""
        self.ToggleRef('caret')

    def OnSampling(self, evt):
        """Sampling frequency menu choice event"""
        menuitem = self.menubar.FindItemById(evt.GetId())
        sampfreq = int(menuitem.GetLabel().rstrip(' kHz'))
        sampfreq *= 1000 # convert from kHz to Hz
        self.SetSampfreq(sampfreq)

    def OnSHCorrect(self, evt):
        """Sample & hold menu event"""
        enable = self.menubar.IsChecked(wx.ID_SHCORRECT) # maybe not safe, but seems to work
        self.SetSHCorrect(enable)

    def OnMove(self, evt):
        """Move frame, and all dataframes as well, like docked windows"""
        for frametype, frame in self.frames.iteritems():
            frame.Move(self.GetPosition() + self.dpos[frametype])
        #evt.Skip() # apparently this isn't needed for a move event,
        # I guess the OS moves the frame no matter what you do with the event

    def OnFilePosComboBox(self, evt):
        """Change file position using combo box control,
        convert start, now, and end to appropriate vals"""
        """
        TODO: I set a value manually, but the OS overrides the value
        after this handler finishes handling the event. Eg, I want 'start'
        to be replaced with the actual self.t0 timestamp, which it is, but is then
        immediately replaced back to 'start' by the OS. Don't know how to
        prevent its propagation to the OS. ComboBoxEvent is a COMMAND event
        """
        t = self.file_pos_combo_box.GetValue()
        try:
            t = self.str2t[t]
        except KeyError:
            # convert to float first so you can use exp notation as shorthand
            t = float(t)
        self.seek(t)

    def OnSlider(self, evt):
        """Strange: keyboard press or page on mouse click when slider in focus generates
        two slider events, and hence two plot events - mouse drag only generates one slider event"""
        self.seek(self.slider.GetValue())
        #print time.time(), 'OnSlider()'
        #evt.Skip() # doesn't seem to be necessary

    def OnSearch(self, evt):
        """Detect pane Search button click"""
        self.sort.detector = self.get_detector() # update sort session's current detector with a new one from widget values
        spikes = self.sort.detector.search() # list of Spikes
        detection = Detection(self.sort, self.sort.detector, # create a new Detection run
                              id=self.sort._detid,
                              datetime=datetime.datetime.now(),
                              spikes=spikes)
        # compare this detection to all previous ones, ignore it if it has a set of spikes
        # overlapping with any other (see Detection.__eq__ and Spike.__eq__)
        for det in self.sort.detections.values():
            if detection == det:
                raise ValueError("Identical detection ignored")
            else:
                intersect = set(detection._spikes).intersection(det._spikes)
                if intersect:
                    raise ValueError("New detection ignored for sharing the following"
                                     "spikes with existing detection %d: %r" %
                                     (det.id, intersect))
        self.sort._detid += 1 # inc for next unique Detection run
        detection.set_spikeids() # now that we know this detection isn't redundant, assign IDs to spikes
        self.sort.detections[detection.id] = detection
        uniquespikes = self.sort.append_spikes(detection.spikes)
        self.append_detection_list(detection)
        # disable sampling menu, don't want to allow sampfreq or shcorrect changes
        # now that we've had at least one detection run
        self.menubar.Enable(wx.ID_SAMPLING, False)
        self.menubar.Enable(wx.ID_RASTERS, True) # enable raster menu, now that spikes exist
        self.ShowRasters() # show spike rasters for open windows other than sort
        sf = self.OpenFrame('sort') # ensure it's open
        #self.OpenFrame('pyshell') # for testing
        t0 = time.clock()
        sf.Append2SpikeList(uniquespikes)
        print 'sf.Append2SpikeList(uniquespikes) took %.3f sec' % (time.clock()-t0)
        #print '%r' % detection.spikes

    def OnMatch(self, evt):
        """Sort pane Match button click"""
        self.sort.match()

    def OnKeyDown(self, evt):
        """Handle key presses
        TODO: might be able to clean this up by having a handler for wx.EVT_NAVIGATION_KEY
        """
        key = evt.GetKeyCode()
        #print 'key: %r' % key
        in_widget = evt.GetEventObject().ClassName in ['wxComboBox', 'wxSpinCtrl', 'wxSlider']
        in_file_pos_combo_box = evt.GetEventObject() == self.file_pos_combo_box
        if not evt.ControlDown():
            if key == wx.WXK_LEFT and not in_widget or key == wx.WXK_DOWN and in_file_pos_combo_box:
                    self.seek(self.t - self.hpstream.tres)
            elif key == wx.WXK_RIGHT and not in_widget or key == wx.WXK_UP and in_file_pos_combo_box:
                    self.seek(self.t + self.hpstream.tres)
            elif key == wx.WXK_PRIOR: # PGUP
                self.seek(self.t - (self.spiketw[1]-self.spiketw[0])) # go back 1 spike frame temporal window width
            elif key == wx.WXK_NEXT: # PGDN
                self.seek(self.t + (self.spiketw[1]-self.spiketw[0])) # go forward 1 spike frame temporal window width
            elif key == wx.WXK_F2: # search for previous spike
                self.findspike(which='previous')
            elif key == wx.WXK_F3: # search for next spike
                self.findspike(which='next')
        else: # CTRL is down
            if key == wx.WXK_PRIOR: # PGUP
                self.seek(self.t - (self.charttw[1]-self.charttw[0])) # go back 1 chart frame temporal window width
            elif key == wx.WXK_NEXT: # PGDN
                self.seek(self.t + (self.charttw[1]-self.charttw[0])) # go forward 1 chart frame temporal window width
        # when key event comes from file_pos_combo_box, reserve down/up for seeking through file
        if in_widget and not in_file_pos_combo_box or in_file_pos_combo_box and key not in [wx.WXK_DOWN, wx.WXK_UP]:
            evt.Skip() # pass event on to OS to handle cursor movement

    def OnDetectionListKeyDown(self, evt):
        key = evt.GetKeyCode()
        if key == wx.WXK_DELETE:
            self.delete_selected_detections()
        evt.Skip()

    def append_detection_list(self, detection):
        """Appends Detection run to the detection list control"""
        row = [str(detection.id),
               detection.detector.threshmethod,
               str(detection.detector.fixedthresh or detection.det.noisemult),
               str(detection.detector.trange),
               str(len(detection.spikes)),
               str(detection.detector.slock),
               str(detection.datetime).rpartition('.')[0] ]
        self.detection_list.Append(row)
        for coli in range(len(row)):
            self.detection_list.SetColumnWidth(coli, wx.LIST_AUTOSIZE_USEHEADER) # resize columns to fit
        self.total_nspikes_label.SetLabel(str(len(self.sort.st)))

    def delete_selected_detections(self):
        """Delete selected rows in detection list"""
        selectedRows = self.detection_list.GetSelections()
        selectedDetections = [ self.listRow2Detection(row) for row in selectedRows ]
        for det in selectedDetections:
            for spike in det.spikes.values(): # first check all detection's spikes to ensure they aren't neuron members
                if spike.neuron != None:
                    wx.MessageBox("can't remove detection %d: spike %d is a"
                                  "member of neuron %d"
                                  % (det.id, spike.id, spike.neuron.id),
                                  "Error", wx.OK|wx.ICON_EXCLAMATION)
                    raise RuntimeError
            for spikei in det.spikes.keys(): # now do the actual removal
                try:
                    del self.sort.spikes[spikei] # remove from unsorted spikes dict
                    if 'sort' in self.frames.keys(): # if sort frame exists, which it should
                        self.frames['sort'].list.DeleteItemByData(spikei) # remove from spike listctrl
                except KeyError: # check if it's in the trash
                    try:
                        del self.sort.trash[spikei] # remove from trash
                    except KeyError:
                        print "can't find spike %d in sort.spikes or in sort.trash, it may have been a duplicate" % spikei
            del self.sort.detections[det.id] # remove from sort's detections dict
            self.detection_list.DeleteItemByData(det.id) # remove from detection listctrl
        self.sort.update_st()
        self.plot() # update rasters
        if len(self.sort.detections) == 0: # if no detection runs are left
            self.menubar.Enable(wx.ID_SAMPLING, True) # reenable sampling menu
        self.total_nspikes_label.SetLabel(str(len(self.sort.st))) # update

    def listRow2Detection(self, row):
        """Return Detection at detection list row"""
        detectioni = int(self.detection_list.GetItemText(row))
        detection = self.sort.detections[detectioni]
        return detection

    def OpenFile(self, fname):
        """Open either .srf or .sort file"""
        ext = os.path.splitext(fname)[1]
        if ext == '.srf':
            self.OpenSurfFile(fname)
        elif ext == '.sort':
            self.OpenSortFile(fname)
        else:
            wx.MessageBox("%s is not a .srf or .sort file" % fname,
                          caption="Error", style=wx.OK|wx.ICON_EXCLAMATION)
            return

    def OpenSurfFile(self, fname):
        """Open a .srf file, and update display accordingly"""
        self.CloseSurfFile() # in case a .srf file and frames are already open
        self.srff = surf.File(fname)
        # TODO: parsing progress dialog
        self.srff.parse()
        self.srffname = self.srff.fname # update
        self.SetTitle(os.path.basename(self.srffname)) # update the caption

        self.hpstream = self.srff.hpstream # highpass record (spike) stream
        try: # check if lowpassmultichanrecords are present
            self.lpstream = self.srff.lpstream # lowpassmultichan record (LFP) stream
        except AttributeError:
            pass
        self.set_chans_enabled(self.hpstream.chans, enable=True)
        tww = self.spiketw[1]-self.spiketw[0] # window width
        self.t = intround(self.hpstream.t0 + tww/2) # set current time position in recording (us)

        self.SPIKEFRAMEWIDTH = self.hpstream.probe.ncols * SPIKEFRAMEWIDTHPERCOLUMN
        self.OpenFrame('spike')
        #self.OpenFrame('chart')
        #self.OpenFrame('lfp')
        #self.OpenFrame('sort')
        #self.OpenFrame('pyshell')
        # these happen in callAfterFrameInit:
        #self.ShowRef('tref')
        #self.ShowRef('vref')
        #self.ShowRef('caret')

        # self has focus, but isn't in foreground after opening data frames
        #self.Raise() # doesn't seem to bring self to foreground
        #wx.GetApp().SetTopWindow(self) # neither does this

        self.str2t = {'start': self.hpstream.t0,
                      'now': self.t,
                      'end': self.hpstream.tend}

        self.range = (self.hpstream.t0, self.hpstream.tend) # us
        self.file_pos_combo_box.SetValue(str(self.t))
        self.file_min_label.SetLabel(str(self.hpstream.t0))
        self.file_max_label.SetLabel(str(self.hpstream.tend))
        self.slider.SetRange(self.range[0], self.range[1])
        self.slider.SetValue(self.t)
        self.slider.SetLineSize(self.hpstream.tres) # us, TODO: this should be based on level of interpolation
        self.slider.SetPageSize(self.spiketw[1]-self.spiketw[0]) # us

        self.SetSampfreq(spyke.core.DEFHIGHPASSSAMPFREQ)
        self.SetSHCorrect(spyke.core.DEFHIGHPASSSHCORRECT)

        self.CreateNewSortSession() # create a new sort session
        self.menubar.Enable(wx.ID_RASTERS, False) # disable until spikes exist

        self.EnableSurfWidgets(True)
        #self.detection_list.SetToolTip(wx.ToolTip('hello world'))

    def CreateNewSortSession(self):
        """Create a new sort session and bind it to .self"""
        self.DeleteSortSession()
        self.sort = Sort(detector=self.get_detector(),
                         probe=self.hpstream.probe,
                         stream=self.hpstream)
        self.EnableSortWidgets(True)

    def DeleteSortSession(self):
        """Delete any existing sort session"""
        try:
            # TODO: if Save button is enabled, check if sort session is saved,
            # if not, prompt to save
            print 'deleting existing sort session and entries in list controls'
            del self.sort
        except AttributeError:
            pass
        self.detection_list.DeleteAllItems()
        if 'sort' in self.frames:
            sf = self.frames['sort']
            sf.list.DeleteAllItems()
            sf.tree.DeleteAllItems()
            sf.lastSelectedListSpikes = []
            sf.lastSelectedTreeObjects = []
            sf.spikesortpanel.removeAllObjects()
            #sf.chartsortpanel.removeAllObjects()
        else: # sort window hasn't been opened yet
            pass
        self.total_nspikes_label.SetLabel(str(0))

    def get_chans_enabled(self):
        return [ chan for (chan, enable) in self._chans_enabled.iteritems() if enable ]

    def set_chans_enabled(self, chans, enable=None):
        """Updates which chans are enabled in ._chans_enabled dict and in the plot panels.
        If enable is set, chans specifies which chans should have their enable
        flag overwritten. Otherwise, chans specifies all the chans we want enabled.
        The code for the 2nd case is quite elaborate, such that the visibility
        state of any given plot in all plotpanels isn't needlessly toggled,
        which slows things down and causes flicker, I think"""

        # inits and checks
        try:
            allchans = self.hpstream.chans # not sure if this needs to be copy()'d or not
        except AttributeError: # no hpstream yet
            allchans = []
        if chans == None: # None means all chans
            chans = allchans
        chans = toiter(chans) # need not be contiguous
        try:
            self._chans_enabled
        except AttributeError:
            self._chans_enabled = {} #dict(zip(allchans, [ True for chan in allchans ]))

        # overwrite enable flag of chans...
        if enable != None:
            for chan in chans:
                self._chans_enabled[chan] = enable
            for frametype in FRAMEUPDATEORDER:
                try:
                    self.frames[frametype].panel.enable_chans(chans, enable=enable)
                except KeyError: # frametype hasn't been opened yet
                    pass
            return

        # ...or, leave only chans enabled
        enabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==True ]
        disabledchans = [ chan for (chan, enabled) in self._chans_enabled.iteritems() if enabled==False ]
        notchans = set(allchans).difference(chans) # chans we don't want enabled
        # find the difference between currently enabled chans and the chans we want enabled
        chans2disable = set(enabledchans).difference(chans)
        # find the difference between currently disabled chans and the chans we want disabled
        chans2enable = set(disabledchans).difference(notchans)
        for chan in chans2enable:
            self._chans_enabled[chan] = True
        for chan in chans2disable:
            self._chans_enabled[chan] = False
        # now change the actual plots in the plotpanels
        for frametype in FRAMEUPDATEORDER:
            try:
                self.frames[frametype].panel.enable_chans(chans2enable, enable=True)
                self.frames[frametype].panel.enable_chans(chans2disable, enable=False)
            except KeyError: # frametype hasn't been opened yet
                pass

    chans_enabled = property(get_chans_enabled, set_chans_enabled)

    def CloseSurfFile(self):
        """Destroy data and sort frames, clean up, close .srf file,
        and metaphorically, .sort file too"""
        # need to specifically get a list of keys, not an iterator,
        # since self.frames dict changes size during iteration
        for frametype in self.frames.keys():
            if frametype != 'pyshell': # leave pyshell frame alone
                self.CloseFrame(frametype) # deletes from dict
        self.hpstream = None
        self.lpstream = None
        self.chans_enabled = []
        self.t = None
        self.spiketw = DEFSPIKETW # reset
        self.charttw = DEFCHARTTW
        self.lfptw = DEFLFPTW
        self.ShowRasters(False) # reset
        self.SetTitle('spyke') # update caption
        self.EnableSurfWidgets(False)
        try:
            self.srff.close()
        except AttributeError: # self.srff is already None, no .close() method
            pass
        self.srff = None
        self.srffname = ''
        self.CloseSortFile()

    def CloseSortFile(self):
        self.DeleteSortSession()
        self.EnableSortWidgets(False)
        self.sortfname = '' # forces a SaveAs on next Save event

    def OpenSortFile(self, fname):
        """Open a sort session from a .sort file"""
        self.DeleteSortSession() # delete any existing sort Session
        pf = gzip.open(fname, 'rb')
        print 'unpickling sort file'
        t0 = time.clock()
        self.sort = cPickle.load(pf)
        print 'done unpickling sort file, took %.3f sec' % (time.clock()-t0)
        pf.close()
        sortProbe = self.sort.probe.__class__
        if self.hpstream != None:
            if sortProbe != self.hpstream.probe.__class__:
                self.CreateNewSortSession() # overwrite the failed sort session
                raise RuntimeError, ".sort file's probe type %r doesn't match .srf file's probe type %r" \
                                    % (sortProbe, self.hpstream.probe.__class__)
        self.sort.stream = self.hpstream # restore missing stream object to sort session
        self.SetSampfreq(self.sort.sampfreq)
        self.SetSHCorrect(self.sort.shcorrect)
        self.menubar.Enable(wx.ID_SAMPLING, False) # disable sampling menu
        if self.srff == None: # no .srf file is open
            self.notebook.Show(True) # lets us do stuff with the sort session
        for detection in self.sort.detections.values(): # restore detections to detection list
            self.append_detection_list(detection)
        sf = self.OpenFrame('sort') # ensure it's open
        sf.Append2SpikeList(self.sort.spikes) # restore unsorted spikes to spike list
        for neuron in self.sort.neurons.values(): # restore neurons and their sorted spikes to tree
            sf.AddNeuron2Tree(neuron)
            for spike in neuron.spikes.values():
                sf.AddSpike2Tree(neuron.itemID, spike)
        self.sortfname = fname # bind it now that it's been successfully loaded
        self.SetTitle(os.path.basename(self.srffname) + ' | ' + os.path.basename(self.sortfname))
        self.update_detect_pane(self.sort.detector)
        self.EnableSortWidgets(True)
        print 'done opening sort file'

    def SaveSortFile(self, fname):
        """Save sort sort to a .sort file"""
        if not os.path.splitext(fname)[1]: # if it doesn't have an extension
            fname = fname + '.sort'
        pf = gzip.open(fname, 'wb') # compress pickle with gzip, can also control compression level
        p = cPickle.Pickler(pf, protocol=-1) # make a Pickler, use most efficient (least human readable) protocol
        print 'pickling sort file'
        t0 = time.clock()
        p.dump(self.sort)
        print 'done pickling sort file, took %.3f sec' % (time.clock()-t0)
        pf.close()
        self.sortfname = fname # bind it now that it's been successfully saved
        self.SetTitle(os.path.basename(self.srffname) + ' | ' + os.path.basename(self.sortfname))
        print 'done saving sort file'

    def OpenFrame(self, frametype):
        """Create and bind a frame, show it, plot its data if applicable"""
        if frametype not in self.frames: # check it doesn't already exist
            if frametype == 'spike':
                x = self.GetPosition()[0]
                y = self.GetPosition()[1] + self.GetSize()[1]
                frame = SpikeFrame(parent=self, stream=self.hpstream,
                                   tw=self.spiketw,
                                   pos=wx.Point(x, y), size=(self.SPIKEFRAMEWIDTH, SPIKEFRAMEHEIGHT))
                frame.panel.callAfterFrameInit() # post frame creation tasks for panel
            elif frametype == 'chart':
                x = self.GetPosition()[0] + self.SPIKEFRAMEWIDTH
                y = self.GetPosition()[1] + self.GetSize()[1]
                frame = ChartFrame(parent=self, stream=self.hpstream,
                                   tw=self.charttw, cw=self.spiketw,
                                   pos=wx.Point(x, y), size=CHARTFRAMESIZE)
                frame.panel.callAfterFrameInit() # post frame creation tasks for panel
            elif frametype == 'lfp':
                x = self.GetPosition()[0] + self.SPIKEFRAMEWIDTH + CHARTFRAMESIZE[0]
                y = self.GetPosition()[1] + self.GetSize()[1]
                frame = LFPFrame(parent=self, stream=self.lpstream,
                                 tw=self.lfptw, cw=self.charttw,
                                 pos=wx.Point(x, y), size=LFPFRAMESIZE)
                frame.panel.callAfterFrameInit() # post frame creation tasks for panel
            elif frametype == 'sort':
                x = self.GetPosition()[0] + self.GetSize()[0]
                y = self.GetPosition()[1]
                frame = SortFrame(parent=self, pos=wx.Point(x, y))
                for panel in [frame.spikesortpanel]:#, frame.chartsortpanel]:
                    panel.callAfterFrameInit(self.sort.probe) # post frame creation tasks for panel
            elif frametype == 'pyshell':
                try:
                    ncols = self.hpstream.probe.ncols
                except AttributeError:
                    ncols = 2 # assume 2 columns
                x = self.GetPosition()[0] + ncols*SPIKEFRAMEWIDTHPERCOLUMN
                y = self.GetPosition()[1] + self.GetSize()[1] + SPIKEFRAMEHEIGHT - PYSHELLSIZE[1]
                frame = PyShellFrame(parent=self, pos=wx.Point(x, y), size=PYSHELLSIZE)
            self.frames[frametype] = frame
            self.dpos[frametype] = frame.GetPosition() - self.GetPosition()
        self.ShowFrame(frametype)
        return self.frames[frametype] # 'frame' isn't necessarily in local namespace

    def ShowFrame(self, frametype, enable=True):
        """Show/hide a frame, force menu and toolbar states to correspond"""
        self.frames[frametype].Show(enable)
        id = self.FRAMETYPE2ID[frametype]
        self.menubar.Check(id, enable)
        self.toolbar.ToggleTool(id, enable)
        if enable and frametype not in ['sort', 'pyshell']:
            self.plot(frametype) # update only the newly shown data frame's data, in case self.t changed since it was last visible

    def HideFrame(self, frametype):
        self.ShowFrame(frametype, False)

    def ToggleFrame(self, frametype):
        """Toggle visibility of a data frame"""
        try:
            frame = self.frames[frametype]
            self.ShowFrame(frametype, not frame.IsShown()) # toggle it
        except KeyError: # frame hasn't been opened yet
            self.OpenFrame(frametype)

    def CloseFrame(self, frametype):
        """Hide frame, remove it from frames dict, destroy it"""
        self.HideFrame(frametype)
        frame = self.frames.pop(frametype)
        frame.Destroy()

    def ToggleWaveforms(self):
        pass

    def ToggleRasters(self):
        """Toggle visibility of rasters"""
        enable = self.menubar.IsChecked(wx.ID_RASTERS) # maybe not safe, but seems to work
        self.ShowRasters(enable)

    def ShowRasters(self, enable=True):
        """Show/hide rasters for all applicable frames. Force menu states to correspond"""
        self.menubar.Check(wx.ID_RASTERS, enable)
        for frametype, frame in self.frames.iteritems():
            if frametype in ['spike', 'chart', 'lfp']:
                frame.panel.show_rasters(enable=enable)
                self.plot(frametype)

    def ToggleRef(self, ref):
        """Toggle visibility of tref, vref, or the caret"""
        enable = self.menubar.IsChecked(self.REFTYPE2ID[ref]) # maybe not safe, but seems to work
        self.ShowRef(ref, enable)

    def ShowRef(self, ref, enable=True):
        """Show/hide a tref, vref, or the caret. Force menu states to correspond"""
        self.menubar.Check(self.REFTYPE2ID[ref], enable)
        for frametype, frame in self.frames.iteritems():
            if frametype in ['spike', 'chart', 'lfp']:
                frame.panel.show_ref(ref, enable=enable)
            elif frametype == 'sort':
                frame.spikesortpanel.show_ref(ref, enable=enable)
                #frame.chartsortpanel.show_ref(ref, enable=enable)

    def SetSampfreq(self, sampfreq):
        """Set highpass stream sampling frequency, update widgets"""
        if self.hpstream != None:
            self.hpstream.sampfreq = sampfreq
        self.menubar.Check(self.SAMPFREQ2ID[sampfreq], True)
        tres = intround(1 / sampfreq * 1e6)
        self.slider.SetLineSize(tres)
        self.plot()

    def SetSHCorrect(self, enable):
        """Set highpass stream sample & hold correct flag, update widgets"""
        if self.hpstream != None:
            self.hpstream.shcorrect = enable
        self.menubar.Check(wx.ID_SHCORRECT, enable)
        self.plot()

    def EnableSurfWidgets(self, enable):
        """Enable/disable all widgets that require an open .srf file"""
        self.menubar.Enable(wx.ID_NEW, enable)
        self.menubar.Enable(wx.ID_SPIKEWIN, enable)
        self.menubar.Enable(wx.ID_CHARTWIN, enable)
        self.menubar.Enable(wx.ID_LFPWIN, enable)
        self.menubar.Enable(wx.ID_TREF, enable)
        self.menubar.Enable(wx.ID_VREF, enable)
        self.menubar.Enable(wx.ID_CARET, enable)
        self.menubar.Enable(wx.ID_SAMPLING, enable)
        self.menubar.Enable(wx.ID_WAVEFORMS, enable)
        self.toolbar.EnableTool(wx.ID_NEW, enable)
        self.toolbar.EnableTool(wx.ID_SPIKEWIN, enable)
        self.toolbar.EnableTool(wx.ID_CHARTWIN, enable)
        self.toolbar.EnableTool(wx.ID_LFPWIN, enable)
        self.file_pos_control_panel.Show(enable)
        self.notebook.Show(enable)
        self.search_button.Enable(enable)
        self.file_min_label.Show(enable)
        self.file_max_label.Show(enable)

    def EnableSortWidgets(self, enable):
        """Enable/disable all widgets that require an "open" .sort file"""
        self.menubar.Enable(wx.ID_SORTWIN, enable)
        self.toolbar.EnableTool(wx.ID_SORTWIN, enable)
        self.menubar.Enable(wx.ID_SAVE, enable)
        self.toolbar.EnableTool(wx.ID_SAVE, enable)
        self.menubar.Enable(wx.ID_RASTERS, enable)
        self.sort_pane.Enable()

    def get_detector(self):
        """Create a Detector object based on widget values"""
        det = detect.Detector(stream=self.hpstream)
        self.update_detector(det)
        return det

    def update_detector(self, det):
        """Update detector from detect pane widget values"""
        det.chans = self.chans_enabled
        if self.globalfixedthresh_radio_btn.GetValue():
            threshmethod = 'GlobalFixed'
        elif self.chanfixedthresh_radio_btn.GetValue():
            threshmethod = 'ChanFixed'
        elif self.dynamicthresh_radio_btn.GetValue():
            threshmethod = 'Dynamic'
        else:
            raise ValueError
        det.threshmethod = threshmethod
        det.fixedthresh = self.fixedthresh_spin_ctrl.GetValue()
        det.noisemult = float(self.noisemult_text_ctrl.GetValue())
        det.noisemethod = self.noise_method_choice.GetStringSelection()
        #det.noisewindow = self.noisewindow_spin_ctrl # not in the gui yet
        det.ppthreshmult = float(self.ppthreshmult_text_ctrl.GetValue())
        det.trange = self.get_detectortrange()
        det.maxnspikes = self.nspikes_spin_ctrl.GetValue() or sys.maxint # if 0, use unlimited
        det.blocksize = int(self.blocksize_combo_box.GetValue())
        det.slock = self.slock_spin_ctrl.GetValue()
        det.randomsample = self.random_sample_checkbox.GetValue()

    def update_detect_pane(self, det):
        """Update detect pane widgets from detector attribs"""
        self.set_detectorthresh(det)
        self.chans_enabled = det.chans
        self.fixedthresh_spin_ctrl.SetValue(det.fixedthresh)
        self.noisemult_text_ctrl.SetValue(str(det.noisemult))
        #self.noisewindow_spin_ctrl.SetValue(det.noisewindow) # not in the gui yet
        self.range_start_combo_box.SetValue(str(det.trange[0]))
        self.range_end_combo_box.SetValue(str(det.trange[1]))
        if det.maxnspikes == sys.maxint:
            self.nspikes_spin_ctrl.SetValue(0) # represent unlimited with 0
        else:
            self.nspikes_spin_ctrl.SetValue(det.maxnspikes)
        self.blocksize_combo_box.SetValue(str(det.blocksize))
        self.slock_spin_ctrl.SetValue(det.slock)
        self.random_sample_checkbox.SetValue(det.randomsample)

    def set_detectorthresh(self, det):
        """Update threshmethod radio buttons to match current Detector"""
        self.METH2RADIOBTN[det.threshmethod].SetValue(True) # enable the appropriate radio button

    def get_detectortrange(self):
        """Get detector time range from combo boxes, and convert
        start, now, and end to appropriate vals"""
        tstart = self.range_start_combo_box.GetValue()
        tend = self.range_end_combo_box.GetValue()
        try:
            tstart = self.str2t[tstart]
        except KeyError:
            tstart = int(float(tstart)) # convert to float first so you can use exp notation as shorthand
        try:
            tend = self.str2t[tend]
        except KeyError:
            tend = int(float(tend))
        return tstart, tend

    def findspike(self, which='next'):
        """Find next or previous spike, depending on direction"""
        det = self.sort.detector
        self.update_detector(det)
        det.maxnspikes = 1 # override whatever was in nspikes spin edit
        det.blocksize = 50000 # smaller blocksize, since we're only looking for 1 spike
        det.randomsample = False # ensure random sampling is turned off
        if which == 'next':
            det.trange = (self.t+1, self.hpstream.tend)
        elif which == 'previous':
            det.trange = (self.t-1, self.hpstream.t0)
        else:
            raise ValueError, which
        spike = det.search() # don't bother saving it, don't update total_nspikes_label
        wx.SafeYield(win=self, onlyIfNeeded=True) # allow controls to update
        try: # if a spike was found
            t = spike[0, 0]
            self.seek(t) # seek to it
            print '%r' % spike
        except IndexError: # if not, do nothing
            pass

    def seek(self, offset=0):
        """Seek to position in surf file. offset is time in us"""
        self.oldt = self.t
        self.t = offset
        self.t = intround(self.t / self.hpstream.tres) * self.hpstream.tres # round to nearest (possibly interpolated) sample
        self.t = min(max(self.t, self.range[0]), self.range[1]) # constrain to within .range
        self.str2t['now'] = self.t # update
        # only plot if t has actually changed, though this doesn't seem to improve
        # performance, maybe mpl is already doing something like this?
        if self.t != self.oldt:
            # update controls first so they don't lag
            self.file_pos_combo_box.SetValue(str(self.t)) # update file combo box
            self.slider.SetValue(self.t) # update slider
            wx.SafeYield(win=self, onlyIfNeeded=True) # allow controls to update
            self.plot()
    '''
    def step(self, direction):
        """Step one timepoint left or right"""
        self.seek(self.t + direction*self.hpstream.tres)

    def page(self, direction):
        """Page left or right"""
        self.seek(self.t + direction*self.hpstream.tres)
    '''
    def tell(self):
        """Return current position in surf file"""
        return self.t

    def plot(self, frametypes=None):
        """Update the contents of all the data frames, or just specific ones.
        Center each data frame on self.t"""
        if frametypes == None: # update all visible frames
            frametypes = self.frames.keys()
        else: # update only specific frames, if visible
            frametypes = toiter(frametypes)
        frametypes = [ frametype for frametype in FRAMEUPDATEORDER if frametype in frametypes ] # reorder
        frames = [ self.frames[frametype] for frametype in frametypes ] # get frames in order
        for frametype, frame in zip(frametypes, frames):
            if frame.IsShown(): # for performance, only update if frame is shown
                if frametype == 'spike':
                    wave = self.hpstream[self.t+self.spiketw[0] : self.t+self.spiketw[1]]
                elif frametype == 'chart':
                    wave = self.hpstream[self.t+self.charttw[0] : self.t+self.charttw[1]]
                elif frametype == 'lfp':
                    wave = self.lpstream[self.t+self.lfptw[0] : self.t+self.lfptw[1]]
                frame.panel.plot(wave, tref=self.t) # plot it


class DataFrame(wx.MiniFrame):
    """Base data frame to hold a custom spyke panel widget.
    Copied and modified from auto-generated wxglade_gui.py code"""

    # no actual maximize button, but allows caption double-click to maximize
    # need SYSTEM_MENU to make close box appear in a TOOL_WINDOW, at least on win32
    STYLE = wx.CAPTION|wx.CLOSE_BOX|wx.MAXIMIZE_BOX|wx.SYSTEM_MENU|wx.RESIZE_BORDER|wx.FRAME_TOOL_WINDOW

    def __init__(self, *args, **kwds):
        kwds["style"] = self.STYLE
        wx.MiniFrame.__init__(self, *args, **kwds)

        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def set_properties(self):
        self.SetTitle("data window")
        self.SetSize((160, 24))

    def do_layout(self):
        dataframe_sizer = wx.BoxSizer(wx.HORIZONTAL)
        dataframe_sizer.Add(self.panel, 1, wx.EXPAND, 0)
        self.SetSizer(dataframe_sizer)
        self.Layout()

    def OnSize(self, evt):
        """Re-save reflines_background after resizing the frame"""
        # resize doesn't actually happen until after this handler exits,
        # so we have to CallAfter
        wx.CallAfter(self.DrawRefs)
        evt.Skip()

    def OnClose(self, evt):
        frametype = self.__class__.__name__.lower().replace('frame', '') # remove 'Frame' from class name
        self.Parent.HideFrame(frametype)

    def DrawRefs(self):
        """Redraws refs and resaves panel background"""
        self.panel.draw_refs()


class SpikeFrame(DataFrame):
    """Frame to hold the custom spike panel widget"""
    def __init__(self, parent=None, stream=None, tw=None, cw=None, *args, **kwds):
        DataFrame.__init__(self, parent, *args, **kwds)
        self.panel = SpikePanel(self, -1, stream=stream, tw=tw, cw=cw)

        self.set_properties()
        self.do_layout()

    def set_properties(self):
        self.SetTitle("spike window")


class ChartFrame(DataFrame):
    """Frame to hold the custom chart panel widget"""
    def __init__(self, parent=None, stream=None, tw=None, cw=None, *args, **kwds):
        DataFrame.__init__(self, parent, *args, **kwds)
        self.panel = ChartPanel(self, -1, stream=stream, tw=tw, cw=cw)

        self.set_properties()
        self.do_layout()

    def set_properties(self):
        self.SetTitle("chart window")


class LFPFrame(DataFrame):
    """Frame to hold the custom LFP panel widget"""
    def __init__(self, parent=None, stream=None, tw=None, cw=None, *args, **kwds):
        DataFrame.__init__(self, parent, *args, **kwds)
        self.panel = LFPPanel(self, -1, stream=stream, tw=tw, cw=cw)

        self.set_properties()
        self.do_layout()

    def set_properties(self):
        self.SetTitle("LFP window")


class PyShellFrame(wx.MiniFrame,
                   wx.py.shell.ShellFrame,
                   wx.py.frame.Frame,
                   wx.py.frame.ShellFrameMixin):
    """PyShell frame"""
    STYLE = wx.CAPTION|wx.CLOSE_BOX|wx.MAXIMIZE_BOX|wx.SYSTEM_MENU|wx.RESIZE_BORDER|wx.FRAME_TOOL_WINDOW

    def __init__(self, *args, **kwargs):
        """TODO: get my startup script to actually run on startup"""
        self.config = wx.FileConfig(localFilename=PYSHELLCFGFNAME) # get config fom file
        self.config.SetRecordDefaults(True)
        startupScript = 'pyshell_startup.py'
        title = 'spyke PyShell'
        kwargs['style'] = self.STYLE
        kwargs['title'] = title

        wx.MiniFrame.__init__(self, *args, **kwargs)
        wx.py.frame.ShellFrameMixin.__init__(self, config=self.config, dataDir=os.path.dirname(PYSHELLCFGFNAME))
        del kwargs['parent']
        del kwargs['title']
        self.shell = wx.py.shell.Shell(parent=self, id=-1, introText='',
                                       locals=None, InterpClass=None,
                                       startupScript=startupScript, # doesn't seem to work
                                       execStartupScript=True,
                                       *args, **kwargs)
        # Override the shell so that status messages go to the status bar.
        self.shell.setStatusText = self.SetStatusText

        self.shell.SetFocus()
        self.LoadSettings()

        self.CreateStatusBar()
        wx.py.frame.Frame._Frame__createMenus(self) # stupid __ name mangling, see Python docs

        self.iconized = False
        self.findDlg = None
        self.findData = wx.FindReplaceData()
        self.findData.SetFlags(wx.FR_DOWN)

        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_ICONIZE, self.OnIconize) # maybe this should be commented out?

        #self.shell.run('from __future__ import division')
        #self.shell.run('import numpy as np')
        #self.shell.runfile(startupScript)
        #self.shell.run('from '+startupScript+' import *')
        self.shell.run('self = app.spykeframe')
        self.shell.run("sf = self.frames['sort']") # convenience
        self.shell.run('s = self.sort') # convenience

    def OnClose(self, evt):
        frametype = self.__class__.__name__.lower().replace('frame', '') # remove 'Frame' from class name
        self.Parent.HideFrame(frametype)


class SpykeAbout(wx.Dialog):
    text = '''
        <html>
        <body bgcolor="#D4D0C8">
        <center><table bgcolor="#000000" width="100%" cellspacing="0"
        cellpadding="0" border="0">
        <tr>
            <td align="center"><h1><font color="#00FF00">spyke</font></h1></td>
        </tr>
        </table>
        </center>
        <p><b>spyke</b> is a tool for neuronal waveform visualization and spike sorting.
        </p>

        <p>Copyright &copy; 2008-2009 Martin Spacek, Reza Lotun<br>
           University of British Columbia</p>
        </body>
        </html>'''

    def __init__(self, parent):
        wx.Dialog.__init__(self, parent, -1, 'About spyke', size=(350, 260))

        html = wx.html.HtmlWindow(self)
        html.SetPage(self.text)
        button = wx.Button(self, wx.ID_OK, "OK")

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(html, 1, wx.EXPAND|wx.ALL, 5)
        sizer.Add(button, 0, wx.ALIGN_CENTER|wx.ALL, 5)

        self.SetSizer(sizer)
        self.Layout()


class SpykeApp(wx.App):
    def OnInit(self, splash=False):
        if splash:
            bmp = wx.Image("res/splash.png").ConvertToBitmap()
            wx.SplashScreen(bmp, wx.SPLASH_CENTRE_ON_SCREEN | wx.SPLASH_TIMEOUT, 1000, None, -1)
            wx.Yield()
        self.spykeframe = SpykeFrame(None)
        self.spykeframe.Show()
        self.SetTopWindow(self.spykeframe)

        # key presses aren't CommandEvents, and don't propagate up the window hierarchy, but
        # if left unhandled, are tested one final time here in the wx.App. Catch unhandled keypresses
        # here and call appropriate methods in the main spyke frame
        #self.Bind(wx.EVT_KEY_DOWN, self.spykeframe.OnKeyDown)

        return True


if __name__ == '__main__':
    app = SpykeApp(redirect=False) # output to stderr and stdout
    app.MainLoop()
